#pragma version 10
#pragma typetrack false

// smart_contracts.proposal.contract.Proposal.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1 10 20 10000
    bytecblock 0x0000 0x737461747573 0x 0x70726f706f736572 0x66756e64696e675f63617465676f7279 "M" 0x72656769737472795f6170705f6964 0x636f6d6d69747465655f6d656d62657273 0x636f6f6c5f646f776e5f73746172745f7473 "voters_count" 0x636f6d6d69747465655f766f746573 0x766f7465645f6d656d62657273 0x617070726f76616c73 0x72656a656374696f6e73 "assigned_votes" 0x6c6f636b65645f616d6f756e74 0x6e756c6c73 0x151f7c75 0x7375626d697373696f6e5f74696d657374616d70 0x766f74655f6f70656e696e675f74696d657374616d70 0x636f6d6d69747465655f6964 0x00 0x00194552523a57726f6e672050726f706f73616c20537461747573 0x7469746c65 0x66696e616c697a6174696f6e5f74696d657374616d70 0x666f637573 0x66756e64696e675f74797065 0x7265717565737465645f616d6f756e74 "V" 0x636f6d6d69747465655f7075626c6973686572
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/proposal/contract.py:44
    // Txn.global_num_byte_slice == prop_cfg.GLOBAL_BYTES
    txn GlobalNumByteSlice
    pushint 3 // 3
    ==
    // smart_contracts/proposal/contract.py:42-45
    // # Preconditions
    // assert (
    //     Txn.global_num_byte_slice == prop_cfg.GLOBAL_BYTES
    // ), err.WRONG_GLOBAL_BYTES
    assert // Wrong Global Bytes allocation
    // smart_contracts/proposal/contract.py:46
    // assert Txn.global_num_uint == prop_cfg.GLOBAL_UINTS, err.WRONG_GLOBAL_UINTS
    txn GlobalNumUint
    pushint 19 // 19
    ==
    assert // Wrong Global UInts allocation
    // smart_contracts/proposal/contract.py:47
    // assert Txn.local_num_byte_slice == prop_cfg.LOCAL_BYTES, err.WRONG_LOCAL_BYTES
    txn LocalNumByteSlice
    !
    assert // Wrong Local Bytes allocation
    // smart_contracts/proposal/contract.py:48
    // assert Txn.local_num_uint == prop_cfg.LOCAL_UINTS, err.WRONG_LOCAL_UINTS
    txn LocalNumUint
    !
    assert // Wrong Local UInts allocation
    // smart_contracts/proposal/contract.py:52
    // key=prop_cfg.GS_KEY_PROPOSER,
    bytec_3 // 0x70726f706f736572
    // smart_contracts/proposal/contract.py:51
    // Account(),
    global ZeroAddress
    // smart_contracts/proposal/contract.py:50-53
    // self.proposer = GlobalState(
    //     Account(),
    //     key=prop_cfg.GS_KEY_PROPOSER,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:56
    // key=prop_cfg.GS_KEY_REGISTRY_APP_ID,
    bytec 6 // 0x72656769737472795f6170705f6964
    // smart_contracts/proposal/contract.py:55
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:54-57
    // self.registry_app_id = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_REGISTRY_APP_ID,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:60
    // key=prop_cfg.GS_KEY_TITLE,
    bytec 23 // 0x7469746c65
    // smart_contracts/proposal/contract.py:59
    // String(),
    bytec_2 // ""
    // smart_contracts/proposal/contract.py:58-61
    // self.title = GlobalState(
    //     String(),
    //     key=prop_cfg.GS_KEY_TITLE,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:64
    // key=prop_cfg.GS_KEY_SUBMISSION_TS,
    bytec 18 // 0x7375626d697373696f6e5f74696d657374616d70
    // smart_contracts/proposal/contract.py:63
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:62-65
    // self.submission_ts = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_SUBMISSION_TS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:68
    // key=prop_cfg.GS_KEY_FINALIZATION_TS,
    bytec 24 // 0x66696e616c697a6174696f6e5f74696d657374616d70
    // smart_contracts/proposal/contract.py:67
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:66-69
    // self.finalization_ts = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_FINALIZATION_TS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:72
    // key=prop_cfg.GS_KEY_VOTE_OPEN_TS,
    bytec 19 // 0x766f74655f6f70656e696e675f74696d657374616d70
    // smart_contracts/proposal/contract.py:71
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:70-73
    // self.vote_open_ts = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_VOTE_OPEN_TS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:76
    // key=prop_cfg.GS_KEY_STATUS,
    bytec_1 // 0x737461747573
    // smart_contracts/proposal/contract.py:75
    // UInt64(enm.STATUS_EMPTY),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:74-77
    // self.status = GlobalState(
    //     UInt64(enm.STATUS_EMPTY),
    //     key=prop_cfg.GS_KEY_STATUS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:80
    // key=prop_cfg.GS_KEY_FUNDING_CATEGORY,
    bytec 4 // 0x66756e64696e675f63617465676f7279
    // smart_contracts/proposal/contract.py:79
    // UInt64(enm.FUNDING_CATEGORY_NULL),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:78-81
    // self.funding_category = GlobalState(
    //     UInt64(enm.FUNDING_CATEGORY_NULL),
    //     key=prop_cfg.GS_KEY_FUNDING_CATEGORY,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:84
    // key=prop_cfg.GS_KEY_FOCUS,
    bytec 25 // 0x666f637573
    // smart_contracts/proposal/contract.py:83
    // UInt64(enm.FOCUS_NULL),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:82-85
    // self.focus = GlobalState(
    //     UInt64(enm.FOCUS_NULL),
    //     key=prop_cfg.GS_KEY_FOCUS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:88
    // key=prop_cfg.GS_KEY_FUNDING_TYPE,
    bytec 26 // 0x66756e64696e675f74797065
    // smart_contracts/proposal/contract.py:87
    // UInt64(enm.FUNDING_NULL),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:86-89
    // self.funding_type = GlobalState(
    //     UInt64(enm.FUNDING_NULL),
    //     key=prop_cfg.GS_KEY_FUNDING_TYPE,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:92
    // key=prop_cfg.GS_KEY_REQUESTED_AMOUNT,
    bytec 27 // 0x7265717565737465645f616d6f756e74
    // smart_contracts/proposal/contract.py:91
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:90-93
    // self.requested_amount = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_REQUESTED_AMOUNT,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:96
    // key=prop_cfg.GS_KEY_LOCKED_AMOUNT,
    bytec 15 // 0x6c6f636b65645f616d6f756e74
    // smart_contracts/proposal/contract.py:95
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:94-97
    // self.locked_amount = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_LOCKED_AMOUNT,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:100
    // key=prop_cfg.GS_KEY_COMMITTEE_ID,
    bytec 20 // 0x636f6d6d69747465655f6964
    // smart_contracts/proposal/contract.py:99
    // typ.Bytes32.from_bytes(b""),
    bytec_2 // 0x
    // smart_contracts/proposal/contract.py:98-101
    // self.committee_id = GlobalState(
    //     typ.Bytes32.from_bytes(b""),
    //     key=prop_cfg.GS_KEY_COMMITTEE_ID,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:104
    // key=prop_cfg.GS_KEY_COMMITTEE_MEMBERS,
    bytec 7 // 0x636f6d6d69747465655f6d656d62657273
    // smart_contracts/proposal/contract.py:103
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:102-105
    // self.committee_members = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_COMMITTEE_MEMBERS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:108
    // key=prop_cfg.GS_KEY_COMMITTEE_VOTES,
    bytec 10 // 0x636f6d6d69747465655f766f746573
    // smart_contracts/proposal/contract.py:107
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:106-109
    // self.committee_votes = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_COMMITTEE_VOTES,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:112
    // key=prop_cfg.GS_KEY_VOTED_MEMBERS,
    bytec 11 // 0x766f7465645f6d656d62657273
    // smart_contracts/proposal/contract.py:111
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:110-113
    // self.voted_members = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_VOTED_MEMBERS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:116
    // key=prop_cfg.GS_KEY_APPROVALS,
    bytec 12 // 0x617070726f76616c73
    // smart_contracts/proposal/contract.py:115
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:114-117
    // self.approvals = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_APPROVALS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:120
    // key=prop_cfg.GS_KEY_REJECTIONS,
    bytec 13 // 0x72656a656374696f6e73
    // smart_contracts/proposal/contract.py:119
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:118-121
    // self.rejections = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_REJECTIONS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:124
    // key=prop_cfg.GS_KEY_NULLS,
    bytec 16 // 0x6e756c6c73
    // smart_contracts/proposal/contract.py:123
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:122-125
    // self.nulls = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_NULLS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:128
    // key=prop_cfg.GS_KEY_COOL_DOWN_START_TS,
    bytec 8 // 0x636f6f6c5f646f776e5f73746172745f7473
    // smart_contracts/proposal/contract.py:127
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:126-129
    // self.cool_down_start_ts = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_COOL_DOWN_START_TS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:134
    // self.voters_count = UInt64(0)
    bytec 9 // "voters_count"
    intc_0 // 0
    app_global_put
    // smart_contracts/proposal/contract.py:135
    // self.assigned_votes = UInt64(0)
    bytec 14 // "assigned_votes"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/proposal/contract.py:32-40
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txn NumAppArgs
    bz main_after_if_else@19
    pushbytess 0xcc694eaa 0x1ec3853f 0x7143994f 0x5fcdfdee 0x23d8b7ce 0x74e6557e 0x1841a0d2 0x734dbecc 0x212d9f07 0x8a5e4c80 0x2ac19b05 0x69ecf4a2 0x1feb95da 0xc3a39fcc // method "create(address)void", method "submit(pay,string,uint64,uint64,uint8)void", method "upload_metadata(byte[],bool)void", method "drop()void", method "finalize()void", method "assign_voter(address,uint64)void", method "vote(address,uint64,uint64)string", method "scrutiny()void", method "review(bool)void", method "fund()string", method "unassign_voters(address[])void", method "decommission()string", method "delete()string", method "get_state()(address,uint64,string,uint64,uint64,uint64,uint64,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64,uint64)"
    txna ApplicationArgs 0
    match main_create_route@5 main_submit_route@6 main_upload_metadata_route@7 main_drop_route@8 main_finalize_route@9 main_assign_voter_route@10 main_vote_route@11 main_scrutiny_route@12 main_review_route@13 main_fund_route@14 main_unassign_voters_route@15 main_decommission_route@16 main_delete_route@17 main_get_state_route@18

main_after_if_else@19:
    // smart_contracts/proposal/contract.py:32-40
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    intc_0 // 0
    return

main_get_state_route@18:
    // smart_contracts/proposal/contract.py:968
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_state
    bytec 17 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_delete_route@17:
    // smart_contracts/proposal/contract.py:952
    // @arc4.abimethod(allow_actions=("DeleteApplication",))
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    assert // OnCompletion is not DeleteApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub delete
    bytec 17 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_decommission_route@16:
    // smart_contracts/proposal/contract.py:913
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub decommission
    bytec 17 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_unassign_voters_route@15:
    // smart_contracts/proposal/contract.py:891
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:32-40
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/proposal/contract.py:891
    // @arc4.abimethod()
    callsub unassign_voters
    intc_1 // 1
    return

main_fund_route@14:
    // smart_contracts/proposal/contract.py:867
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub fund
    bytec 17 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_review_route@13:
    // smart_contracts/proposal/contract.py:839
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:32-40
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    intc_0 // 0
    getbit
    // smart_contracts/proposal/contract.py:839
    // @arc4.abimethod()
    callsub review
    intc_1 // 1
    return

main_scrutiny_route@12:
    // smart_contracts/proposal/contract.py:794
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub scrutiny
    intc_1 // 1
    return

main_vote_route@11:
    // smart_contracts/proposal/contract.py:744
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:32-40
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/proposal/contract.py:744
    // @arc4.abimethod()
    callsub vote
    bytec 17 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_assign_voter_route@10:
    // smart_contracts/proposal/contract.py:708
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:32-40
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/proposal/contract.py:708
    // @arc4.abimethod()
    callsub assign_voter
    intc_1 // 1
    return

main_finalize_route@9:
    // smart_contracts/proposal/contract.py:662
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub finalize
    intc_1 // 1
    return

main_drop_route@8:
    // smart_contracts/proposal/contract.py:641
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub drop
    intc_1 // 1
    return

main_upload_metadata_route@7:
    // smart_contracts/proposal/contract.py:609
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:32-40
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/proposal/contract.py:609
    // @arc4.abimethod()
    callsub upload_metadata
    intc_1 // 1
    return

main_submit_route@6:
    // smart_contracts/proposal/contract.py:556
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:32-40
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/proposal/contract.py:556
    // @arc4.abimethod()
    callsub submit
    intc_1 // 1
    return

main_create_route@5:
    // smart_contracts/proposal/contract.py:542
    // @arc4.abimethod(create="require")
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/proposal/contract.py:32-40
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/proposal/contract.py:542
    // @arc4.abimethod(create="require")
    callsub create
    intc_1 // 1
    return


// smart_contracts.proposal.contract.Proposal.is_voting_open() -> uint64, bytes:
is_voting_open:
    // smart_contracts/proposal/contract.py:141-142
    // @subroutine
    // def is_voting_open(self) -> tuple[bool, typ.Error]:
    proto 0 2
    intc_0 // 0
    bytec_2 // ""
    // smart_contracts/proposal/contract.py:143
    // voting_duration = Global.latest_timestamp - self.vote_open_ts.value
    global LatestTimestamp
    intc_0 // 0
    bytec 19 // 0x766f74655f6f70656e696e675f74696d657374616d70
    app_global_get_ex
    assert // check self.vote_open_ts exists
    -
    // smart_contracts/proposal/contract.py:145
    // self.funding_category.value
    intc_0 // 0
    bytec 4 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:290
    // if category == enm.FUNDING_CATEGORY_SMALL:
    intc_2 // 10
    ==
    bz is_voting_open_else_body@5
    // smart_contracts/proposal/contract.py:292
    // Bytes(reg_cfg.GS_KEY_VOTING_DURATION_SMALL)
    pushbytes 0x766f74696e675f6475726174696f6e5f736d616c6c
    // smart_contracts/proposal/contract.py:291-293
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_VOTING_DURATION_SMALL)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    frame_bury 1

is_voting_open_after_inlined_smart_contracts.proposal.contract.Proposal.get_voting_duration@8:
    // smart_contracts/proposal/contract.py:147
    // if error != typ.Error(""):
    frame_dig 0
    bytec_0 // 0x0000
    !=
    bz is_voting_open_after_if_else@2
    // smart_contracts/proposal/contract.py:148
    // return False, error
    intc_0 // 0
    frame_dig 0
    frame_bury 1
    frame_bury 0
    retsub

is_voting_open_after_if_else@2:
    // smart_contracts/proposal/contract.py:150
    // return voting_duration <= maximum_voting_duration, typ.Error("")
    frame_dig 2
    frame_dig 1
    <=
    bytec_0 // 0x0000
    frame_bury 1
    frame_bury 0
    retsub

is_voting_open_else_body@5:
    // smart_contracts/proposal/contract.py:294
    // elif category == enm.FUNDING_CATEGORY_MEDIUM:
    frame_dig 3
    intc_3 // 20
    ==
    bz is_voting_open_else_body@7
    // smart_contracts/proposal/contract.py:296
    // Bytes(reg_cfg.GS_KEY_VOTING_DURATION_MEDIUM)
    pushbytes 0x766f74696e675f6475726174696f6e5f6d656469756d
    // smart_contracts/proposal/contract.py:295-297
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_VOTING_DURATION_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    frame_bury 1
    // smart_contracts/proposal/contract.py:144-146
    // maximum_voting_duration, error = self.get_voting_duration(
    //     self.funding_category.value
    // )
    b is_voting_open_after_inlined_smart_contracts.proposal.contract.Proposal.get_voting_duration@8

is_voting_open_else_body@7:
    // smart_contracts/proposal/contract.py:300
    // Bytes(reg_cfg.GS_KEY_VOTING_DURATION_LARGE)
    pushbytes 0x766f74696e675f6475726174696f6e5f6c61726765
    // smart_contracts/proposal/contract.py:299-301
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_VOTING_DURATION_LARGE)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    frame_bury 1
    // smart_contracts/proposal/contract.py:144-146
    // maximum_voting_duration, error = self.get_voting_duration(
    //     self.funding_category.value
    // )
    b is_voting_open_after_inlined_smart_contracts.proposal.contract.Proposal.get_voting_duration@8


// smart_contracts.proposal.contract.Proposal.assert_draft_and_proposer() -> void:
assert_draft_and_proposer:
    // smart_contracts/proposal/contract.py:363
    // assert self.is_proposer(), err.UNAUTHORIZED
    callsub is_proposer
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:364
    // assert self.status.value == enm.STATUS_DRAFT, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_2 // 10
    ==
    assert // Wrong Proposal Status
    retsub


// smart_contracts.proposal.contract.Proposal.get_expected_locked_amount(requested_amount: uint64) -> uint64:
get_expected_locked_amount:
    // smart_contracts/proposal/contract.py:432-433
    // @subroutine
    // def get_expected_locked_amount(self, requested_amount: UInt64) -> UInt64:
    proto 1 1
    // smart_contracts/proposal/contract.py:435
    // Bytes(reg_cfg.GS_KEY_PROPOSAL_COMMITMENT_BPS)
    pushbytes 0x70726f706f73616c5f636f6d6d69746d656e745f627073
    // smart_contracts/proposal/contract.py:434-436
    // proposal_commitment_bps, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PROPOSAL_COMMITMENT_BPS)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:437
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:430
    // return amount * fraction_in_bps // const.BPS
    frame_dig -1
    *
    intc 4 // 10000
    /
    // smart_contracts/proposal/contract.py:438-441
    // return self.relative_to_absolute_amount(
    //     requested_amount,
    //     proposal_commitment_bps,
    // )
    retsub


// smart_contracts.proposal.contract.Proposal.get_uint_from_registry_config(global_state_key: bytes) -> uint64, bytes:
get_uint_from_registry_config:
    // smart_contracts/proposal/contract.py:474-477
    // @subroutine
    // def get_uint_from_registry_config(
    //     self, global_state_key: Bytes
    // ) -> tuple[UInt64, typ.Error]:
    proto 1 2
    // smart_contracts/proposal/contract.py:479
    // self.registry_app_id.value, global_state_key
    intc_0 // 0
    bytec 6 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:478-480
    // value, exists = AppGlobal.get_ex_uint64(
    //     self.registry_app_id.value, global_state_key
    // )
    frame_dig -1
    app_global_get_ex
    // smart_contracts/proposal/contract.py:481
    // error = typ.Error("")
    bytec_0 // 0x0000
    swap
    // smart_contracts/proposal/contract.py:482
    // if not exists:
    bnz get_uint_from_registry_config_after_if_else@2
    // smart_contracts/proposal/contract.py:483
    // error = typ.Error(err.ARC_65_PREFIX + err.MISSING_CONFIG)
    pushbytes 0x00124552523a4d697373696e6720436f6e666967
    frame_bury 1

get_uint_from_registry_config_after_if_else@2:
    // smart_contracts/proposal/contract.py:484
    // return value, error
    frame_dig 0
    frame_dig 1
    uncover 3
    uncover 3
    retsub


// smart_contracts.proposal.contract.Proposal.get_bytes_from_registry_config(global_state_key: bytes) -> bytes:
get_bytes_from_registry_config:
    // smart_contracts/proposal/contract.py:486-487
    // @subroutine
    // def get_bytes_from_registry_config(self, global_state_key: Bytes) -> Bytes:
    proto 1 1
    // smart_contracts/proposal/contract.py:489
    // self.registry_app_id.value, global_state_key
    intc_0 // 0
    bytec 6 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:488-490
    // value, exists = AppGlobal.get_ex_bytes(
    //     self.registry_app_id.value, global_state_key
    // )
    frame_dig -1
    app_global_get_ex
    // smart_contracts/proposal/contract.py:491
    // assert exists, err.MISSING_CONFIG
    assert // Missing Config
    // smart_contracts/proposal/contract.py:492
    // return value
    retsub


// smart_contracts.proposal.contract.Proposal.check_registry_not_paused() -> void:
check_registry_not_paused:
    // smart_contracts/proposal/contract.py:497
    // Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    pushbytes 0x7061757365645f7265676973747279
    // smart_contracts/proposal/contract.py:496-498
    // registry_paused, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:500
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:501
    // assert not registry_paused, err.PAUSED_REGISTRY
    !
    assert // Registry's non-admin methods are paused
    retsub


// smart_contracts.proposal.contract.Proposal.is_proposer() -> uint64:
is_proposer:
    // smart_contracts/proposal/contract.py:509
    // return Txn.sender == self.proposer.value
    txn Sender
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.is_committee_publisher() -> uint64:
is_committee_publisher:
    // smart_contracts/proposal/contract.py:519
    // return Txn.sender == Account(
    txn Sender
    // smart_contracts/proposal/contract.py:521
    // Bytes(reg_cfg.GS_KEY_COMMITTEE_PUBLISHER)
    bytec 29 // 0x636f6d6d69747465655f7075626c6973686572
    // smart_contracts/proposal/contract.py:520-522
    // self.get_bytes_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COMMITTEE_PUBLISHER)
    // )
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:519-523
    // return Txn.sender == Account(
    //     self.get_bytes_from_registry_config(
    //         Bytes(reg_cfg.GS_KEY_COMMITTEE_PUBLISHER)
    //     )
    // )
    dup
    len
    pushint 32 // 32
    ==
    assert // Address length is 32 bytes
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.is_registry_call() -> uint64:
is_registry_call:
    // smart_contracts/proposal/contract.py:527
    // return Global.caller_application_id == self.registry_app_id.value
    global CallerApplicationID
    intc_0 // 0
    bytec 6 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.pay(receiver: bytes, amount: uint64) -> void:
pay:
    // smart_contracts/proposal/contract.py:529-530
    // @subroutine
    // def pay(self, receiver: Account, amount: UInt64) -> None:
    proto 2 0
    // smart_contracts/proposal/contract.py:531-535
    // itxn.Payment(
    //     receiver=receiver,
    //     amount=amount,
    //     fee=UInt64(0),  # enforces the sender to pay the fee
    // ).submit()
    itxn_begin
    frame_dig -1
    itxn_field Amount
    frame_dig -2
    itxn_field Receiver
    // smart_contracts/proposal/contract.py:531
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/proposal/contract.py:534
    // fee=UInt64(0),  # enforces the sender to pay the fee
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/proposal/contract.py:531-535
    // itxn.Payment(
    //     receiver=receiver,
    //     amount=amount,
    //     fee=UInt64(0),  # enforces the sender to pay the fee
    // ).submit()
    itxn_submit
    retsub


// smart_contracts.proposal.contract.Proposal.transfer_locked_amount(receiver: bytes) -> void:
transfer_locked_amount:
    // smart_contracts/proposal/contract.py:537-538
    // @subroutine
    // def transfer_locked_amount(self, receiver: Account) -> None:
    proto 1 0
    // smart_contracts/proposal/contract.py:539
    // self.pay(receiver, self.locked_amount.value)
    intc_0 // 0
    bytec 15 // 0x6c6f636b65645f616d6f756e74
    app_global_get_ex
    assert // check self.locked_amount exists
    frame_dig -1
    swap
    callsub pay
    // smart_contracts/proposal/contract.py:540
    // self.locked_amount.value = UInt64(0)
    bytec 15 // 0x6c6f636b65645f616d6f756e74
    intc_0 // 0
    app_global_put
    retsub


// smart_contracts.proposal.contract.Proposal.create(proposer: bytes) -> void:
create:
    // smart_contracts/proposal/contract.py:542-543
    // @arc4.abimethod(create="require")
    // def create(self, proposer: arc4.Address) -> None:
    proto 1 0
    // smart_contracts/proposal/contract.py:550
    // Global.caller_application_id != 0
    global CallerApplicationID
    // smart_contracts/proposal/contract.py:549-551
    // assert (
    //     Global.caller_application_id != 0
    // ), err.UNAUTHORIZED  # Only callable by another contract
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:553
    // self.proposer.value = proposer.native
    bytec_3 // 0x70726f706f736572
    frame_dig -1
    app_global_put
    // smart_contracts/proposal/contract.py:554
    // self.registry_app_id.value = Global.caller_application_id
    bytec 6 // 0x72656769737472795f6170705f6964
    global CallerApplicationID
    app_global_put
    retsub


// smart_contracts.proposal.contract.Proposal.submit(payment: uint64, title: bytes, funding_type: bytes, requested_amount: bytes, focus: bytes) -> void:
submit:
    // smart_contracts/proposal/contract.py:556-564
    // @arc4.abimethod()
    // def submit(
    //     self,
    //     payment: gtxn.PaymentTransaction,
    //     title: arc4.String,
    //     funding_type: arc4.UInt64,
    //     requested_amount: arc4.UInt64,
    //     focus: arc4.UInt8,
    // ) -> None:
    proto 5 0
    bytec_2 // ""
    // smart_contracts/proposal/contract.py:589
    // self.check_registry_not_paused()
    callsub check_registry_not_paused
    // smart_contracts/proposal/contract.py:392
    // assert self.is_proposer(), err.UNAUTHORIZED
    callsub is_proposer
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:393
    // assert self.status.value == enm.STATUS_EMPTY, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    !
    assert // Wrong Proposal Status
    // smart_contracts/proposal/contract.py:594
    // title.native, funding_type.native, requested_amount.native
    frame_dig -4
    extract 2 0
    frame_bury -4
    frame_dig -3
    btoi
    dup
    frame_dig -2
    btoi
    swap
    // smart_contracts/proposal/contract.py:403
    // assert title.bytes.length <= const.TITLE_MAX_BYTES, err.WRONG_TITLE_LENGTH
    frame_dig -4
    len
    pushint 123 // 123
    <=
    assert // Wrong Title length
    // smart_contracts/proposal/contract.py:404
    // assert title != "", err.WRONG_TITLE_LENGTH
    frame_dig -4
    bytec_2 // ""
    !=
    assert // Wrong Title length
    // smart_contracts/proposal/contract.py:407
    // funding_type == enm.FUNDING_PROACTIVE
    intc_2 // 10
    ==
    // smart_contracts/proposal/contract.py:407-408
    // funding_type == enm.FUNDING_PROACTIVE
    // or funding_type == enm.FUNDING_RETROACTIVE
    bnz submit_bool_true@5
    // smart_contracts/proposal/contract.py:408
    // or funding_type == enm.FUNDING_RETROACTIVE
    frame_dig 1
    intc_3 // 20
    ==
    // smart_contracts/proposal/contract.py:407-408
    // funding_type == enm.FUNDING_PROACTIVE
    // or funding_type == enm.FUNDING_RETROACTIVE
    bz submit_bool_false@6

submit_bool_true@5:
    intc_1 // 1

submit_bool_merge@7:
    // smart_contracts/proposal/contract.py:406-409
    // assert (
    //     funding_type == enm.FUNDING_PROACTIVE
    //     or funding_type == enm.FUNDING_RETROACTIVE
    // ), err.WRONG_FUNDING_TYPE
    assert // Wrong Funding Type
    // smart_contracts/proposal/contract.py:412
    // Bytes(reg_cfg.GS_KEY_MIN_REQUESTED_AMOUNT)
    pushbytes 0x6d696e5f7265717565737465645f616d6f756e74
    // smart_contracts/proposal/contract.py:411-413
    // min_requested_amount, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MIN_REQUESTED_AMOUNT)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:414
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:417
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_LARGE)
    pushbytes 0x6d61785f7265717565737465645f616d6f756e745f6c61726765
    // smart_contracts/proposal/contract.py:416-418
    // max_requested_amount_large, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_LARGE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:419
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:421
    // assert requested_amount >= min_requested_amount, err.WRONG_MIN_REQUESTED_AMOUNT
    frame_dig 2
    dup
    uncover 3
    >=
    assert // Requested amount is less than the minimum requested amount
    // smart_contracts/proposal/contract.py:423
    // requested_amount <= max_requested_amount_large
    dup
    uncover 2
    <=
    // smart_contracts/proposal/contract.py:422-424
    // assert (
    //     requested_amount <= max_requested_amount_large
    // ), err.WRONG_MAX_REQUESTED_AMOUNT
    assert // Requested amount is more than the maximum requested amount
    // smart_contracts/proposal/contract.py:447
    // expected_lock_amount = self.get_expected_locked_amount(requested_amount)
    dup
    callsub get_expected_locked_amount
    // smart_contracts/proposal/contract.py:449
    // assert payment.sender == self.proposer.value, err.WRONG_SENDER
    frame_dig -5
    gtxns Sender
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    ==
    assert // Wrong Sender
    // smart_contracts/proposal/contract.py:451
    // payment.receiver == Global.current_application_address
    frame_dig -5
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/proposal/contract.py:450-452
    // assert (
    //     payment.receiver == Global.current_application_address
    // ), err.WRONG_RECEIVER
    assert // Wrong Receiver
    // smart_contracts/proposal/contract.py:453
    // assert payment.amount == expected_lock_amount, err.WRONG_LOCKED_AMOUNT
    frame_dig -5
    gtxns Amount
    ==
    assert // Locked amount is incorrect
    // smart_contracts/proposal/contract.py:598
    // self.title.value = title.native
    bytec 23 // 0x7469746c65
    frame_dig -4
    app_global_put
    // smart_contracts/proposal/contract.py:458
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_SMALL)
    pushbytes 0x6d61785f7265717565737465645f616d6f756e745f736d616c6c
    // smart_contracts/proposal/contract.py:457-459
    // max_requested_amount_small, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_SMALL)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:460
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:463
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_MEDIUM)
    pushbytes 0x6d61785f7265717565737465645f616d6f756e745f6d656469756d
    // smart_contracts/proposal/contract.py:462-464
    // max_requested_amount_medium, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    swap
    frame_bury 0
    // smart_contracts/proposal/contract.py:465
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:467
    // if requested_amount <= max_requested_amount_small:
    <=
    bz submit_else_body@13
    // smart_contracts/proposal/contract.py:468
    // self.funding_category.value = UInt64(enm.FUNDING_CATEGORY_SMALL)
    bytec 4 // 0x66756e64696e675f63617465676f7279
    intc_2 // 10
    app_global_put

submit_after_if_else@16:
    // smart_contracts/proposal/contract.py:600
    // self.funding_type.value = funding_type.native
    bytec 26 // 0x66756e64696e675f74797065
    frame_dig 1
    app_global_put
    // smart_contracts/proposal/contract.py:601
    // self.requested_amount.value = requested_amount.native
    bytec 27 // 0x7265717565737465645f616d6f756e74
    frame_dig 2
    dup
    cover 2
    app_global_put
    // smart_contracts/proposal/contract.py:602
    // self.focus.value = focus.native
    frame_dig -1
    btoi
    bytec 25 // 0x666f637573
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:603-605
    // self.locked_amount.value = self.get_expected_locked_amount(
    //     requested_amount.native
    // )
    callsub get_expected_locked_amount
    // smart_contracts/proposal/contract.py:603
    // self.locked_amount.value = self.get_expected_locked_amount(
    bytec 15 // 0x6c6f636b65645f616d6f756e74
    // smart_contracts/proposal/contract.py:603-605
    // self.locked_amount.value = self.get_expected_locked_amount(
    //     requested_amount.native
    // )
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:606
    // self.submission_ts.value = Global.latest_timestamp
    bytec 18 // 0x7375626d697373696f6e5f74696d657374616d70
    global LatestTimestamp
    app_global_put
    // smart_contracts/proposal/contract.py:607
    // self.status.value = UInt64(enm.STATUS_DRAFT)
    bytec_1 // 0x737461747573
    intc_2 // 10
    app_global_put
    retsub

submit_else_body@13:
    // smart_contracts/proposal/contract.py:469
    // elif requested_amount <= max_requested_amount_medium:
    frame_dig 2
    frame_dig 0
    <=
    bz submit_else_body@15
    // smart_contracts/proposal/contract.py:470
    // self.funding_category.value = UInt64(enm.FUNDING_CATEGORY_MEDIUM)
    bytec 4 // 0x66756e64696e675f63617465676f7279
    intc_3 // 20
    app_global_put
    b submit_after_if_else@16

submit_else_body@15:
    // smart_contracts/proposal/contract.py:472
    // self.funding_category.value = UInt64(enm.FUNDING_CATEGORY_LARGE)
    bytec 4 // 0x66756e64696e675f63617465676f7279
    pushint 33 // 33
    app_global_put
    b submit_after_if_else@16

submit_bool_false@6:
    intc_0 // 0
    b submit_bool_merge@7


// smart_contracts.proposal.contract.Proposal.upload_metadata(payload: bytes, is_first_in_group: bytes) -> void:
upload_metadata:
    // smart_contracts/proposal/contract.py:609-612
    // @arc4.abimethod()
    // def upload_metadata(
    //     self, payload: arc4.DynamicBytes, is_first_in_group: arc4.Bool
    // ) -> None:
    proto 2 0
    // smart_contracts/proposal/contract.py:626
    // self.check_registry_not_paused()
    callsub check_registry_not_paused
    // smart_contracts/proposal/contract.py:384
    // self.assert_draft_and_proposer()
    callsub assert_draft_and_proposer
    // smart_contracts/proposal/contract.py:388
    // assert payload.length > 0, err.EMPTY_PAYLOAD
    frame_dig -2
    intc_0 // 0
    extract_uint16
    dup
    assert // Empty payload
    // smart_contracts/proposal/contract.py:631
    // if is_first_in_group:
    frame_dig -1
    bytec 21 // 0x00
    !=
    bz upload_metadata_else_body@2
    // smart_contracts/proposal/contract.py:632-633
    // # clear and write the metadata to the box
    // self.metadata.delete()
    bytec 5 // "M"
    box_del
    pop
    // smart_contracts/proposal/contract.py:634
    // self.metadata.put(payload.native)
    frame_dig -2
    extract 2 0
    bytec 5 // "M"
    swap
    box_put
    retsub

upload_metadata_else_body@2:
    // smart_contracts/proposal/contract.py:636-637
    // # append the metadata to the box
    // old_size = self.metadata.length
    bytec 5 // "M"
    box_len
    assert // check self.metadata exists
    // smart_contracts/proposal/contract.py:638
    // self.metadata.resize(self.metadata.length + payload.length)
    bytec 5 // "M"
    box_len
    assert // check self.metadata exists
    frame_dig 0
    +
    bytec 5 // "M"
    swap
    box_resize
    // smart_contracts/proposal/contract.py:639
    // self.metadata.replace(old_size, payload.native)
    frame_dig -2
    extract 2 0
    bytec 5 // "M"
    cover 2
    box_replace
    retsub


// smart_contracts.proposal.contract.Proposal.drop() -> void:
drop:
    // smart_contracts/proposal/contract.py:651
    // self.check_registry_not_paused()
    callsub check_registry_not_paused
    // smart_contracts/proposal/contract.py:380
    // self.assert_draft_and_proposer()
    callsub assert_draft_and_proposer
    // smart_contracts/proposal/contract.py:656
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:655-657
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount
    // smart_contracts/proposal/contract.py:659
    // self.metadata.delete()
    bytec 5 // "M"
    box_del
    pop
    // smart_contracts/proposal/contract.py:660
    // self.status.value = UInt64(enm.STATUS_DECOMMISSIONED)
    bytec_1 // 0x737461747573
    pushint 70 // 70
    app_global_put
    retsub


// smart_contracts.proposal.contract.Proposal.finalize() -> void:
finalize:
    // smart_contracts/proposal/contract.py:662-663
    // @arc4.abimethod()
    // def finalize(self) -> None:
    proto 0 0
    intc_0 // 0
    // smart_contracts/proposal/contract.py:678
    // self.check_registry_not_paused()
    callsub check_registry_not_paused
    // smart_contracts/proposal/contract.py:369
    // self.assert_draft_and_proposer()
    callsub assert_draft_and_proposer
    // smart_contracts/proposal/contract.py:371
    // discussion_duration = Global.latest_timestamp - self.submission_ts.value
    global LatestTimestamp
    intc_0 // 0
    bytec 18 // 0x7375626d697373696f6e5f74696d657374616d70
    app_global_get_ex
    assert // check self.submission_ts exists
    -
    // smart_contracts/proposal/contract.py:373
    // self.funding_category.value
    intc_0 // 0
    bytec 4 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:273
    // if category == enm.FUNDING_CATEGORY_SMALL:
    intc_2 // 10
    ==
    bz finalize_else_body@3
    // smart_contracts/proposal/contract.py:275
    // Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_SMALL)
    pushbytes 0x64697363757373696f6e5f6475726174696f6e5f736d616c6c
    // smart_contracts/proposal/contract.py:274-276
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_SMALL)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0

finalize_after_if_else@7:
    // smart_contracts/proposal/contract.py:285
    // assert error == typ.Error(""), err.MISSING_CONFIG
    frame_dig 0
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:376
    // assert discussion_duration >= minimum_discussion_duration, err.TOO_EARLY
    frame_dig 1
    <=
    assert // Too early
    // smart_contracts/proposal/contract.py:341
    // self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_COMMITTEE_ID))
    bytec 20 // 0x636f6d6d69747465655f6964
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:343
    // assert committee_id != typ.Bytes32.from_bytes(b""), err.EMPTY_COMMITTEE_ID
    dup
    bytec_2 // 0x
    !=
    assert // Empty Committee ID
    // smart_contracts/proposal/contract.py:346
    // Bytes(reg_cfg.GS_KEY_COMMITTEE_MEMBERS)
    bytec 7 // 0x636f6d6d69747465655f6d656d62657273
    // smart_contracts/proposal/contract.py:345-347
    // committee_members, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COMMITTEE_MEMBERS)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:348
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:349
    // assert committee_members > UInt64(0), err.WRONG_COMMITTEE_MEMBERS
    dup
    assert // Wrong Committee Members
    // smart_contracts/proposal/contract.py:352
    // Bytes(reg_cfg.GS_KEY_COMMITTEE_VOTES)
    bytec 10 // 0x636f6d6d69747465655f766f746573
    // smart_contracts/proposal/contract.py:351-353
    // committee_votes, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COMMITTEE_VOTES)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:354
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:355
    // assert committee_votes > UInt64(0), err.WRONG_COMMITTEE_VOTES
    dup
    assert // Wrong Committee Votes
    // smart_contracts/proposal/contract.py:357
    // self.committee_id.value = committee_id.copy()
    bytec 20 // 0x636f6d6d69747465655f6964
    uncover 3
    app_global_put
    // smart_contracts/proposal/contract.py:358
    // self.committee_members.value = committee_members
    bytec 7 // 0x636f6d6d69747465655f6d656d62657273
    uncover 2
    app_global_put
    // smart_contracts/proposal/contract.py:359
    // self.committee_votes.value = committee_votes
    bytec 10 // 0x636f6d6d69747465655f766f746573
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:684
    // self.status.value = UInt64(enm.STATUS_FINAL)
    bytec_1 // 0x737461747573
    intc_3 // 20
    app_global_put
    // smart_contracts/proposal/contract.py:685
    // self.finalization_ts.value = Global.latest_timestamp
    bytec 24 // 0x66696e616c697a6174696f6e5f74696d657374616d70
    global LatestTimestamp
    app_global_put
    // smart_contracts/proposal/contract.py:688
    // Bytes(reg_cfg.GS_KEY_PROPOSAL_FEE)
    pushbytes 0x70726f706f73616c5f666565
    // smart_contracts/proposal/contract.py:687-689
    // proposal_fee, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PROPOSAL_FEE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:690
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:692
    // assert self.metadata, err.MISSING_METADATA
    bytec 5 // "M"
    box_len
    bury 1
    assert // Missing Metadata
    // smart_contracts/proposal/contract.py:695
    // Bytes(reg_cfg.GS_KEY_PROPOSAL_PUBLISHING_BPS)
    pushbytes 0x70726f706f73616c5f7075626c697368696e675f627073
    // smart_contracts/proposal/contract.py:694-696
    // publishing_fee_bps, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PROPOSAL_PUBLISHING_BPS)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:697
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:702
    // Bytes(reg_cfg.GS_KEY_COMMITTEE_PUBLISHER)
    bytec 29 // 0x636f6d6d69747465655f7075626c6973686572
    // smart_contracts/proposal/contract.py:701-703
    // self.get_bytes_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COMMITTEE_PUBLISHER)
    // )
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:700-704
    // receiver=Account(
    //     self.get_bytes_from_registry_config(
    //         Bytes(reg_cfg.GS_KEY_COMMITTEE_PUBLISHER)
    //     )
    // ),
    dup
    len
    pushint 32 // 32
    ==
    assert // Address length is 32 bytes
    // smart_contracts/proposal/contract.py:430
    // return amount * fraction_in_bps // const.BPS
    cover 2
    *
    intc 4 // 10000
    /
    // smart_contracts/proposal/contract.py:699-706
    // self.pay(
    //     receiver=Account(
    //         self.get_bytes_from_registry_config(
    //             Bytes(reg_cfg.GS_KEY_COMMITTEE_PUBLISHER)
    //         )
    //     ),
    //     amount=self.relative_to_absolute_amount(proposal_fee, publishing_fee_bps),
    // )
    callsub pay
    retsub

finalize_else_body@3:
    // smart_contracts/proposal/contract.py:277
    // elif category == enm.FUNDING_CATEGORY_MEDIUM:
    frame_dig 2
    intc_3 // 20
    ==
    bz finalize_else_body@5
    // smart_contracts/proposal/contract.py:279
    // Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_MEDIUM)
    pushbytes 0x64697363757373696f6e5f6475726174696f6e5f6d656469756d
    // smart_contracts/proposal/contract.py:278-280
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b finalize_after_if_else@7

finalize_else_body@5:
    // smart_contracts/proposal/contract.py:283
    // Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_LARGE)
    pushbytes 0x64697363757373696f6e5f6475726174696f6e5f6c61726765
    // smart_contracts/proposal/contract.py:282-284
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_LARGE)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b finalize_after_if_else@7


// smart_contracts.proposal.contract.Proposal.assign_voter(voter: bytes, voting_power: bytes) -> void:
assign_voter:
    // smart_contracts/proposal/contract.py:708-709
    // @arc4.abimethod()
    // def assign_voter(self, voter: arc4.Address, voting_power: arc4.UInt64) -> None:
    proto 2 0
    // smart_contracts/proposal/contract.py:261
    // assert self.is_committee_publisher(), err.UNAUTHORIZED
    callsub is_committee_publisher
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:262
    // assert self.status.value == enm.STATUS_FINAL, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_3 // 20
    ==
    assert // Wrong Proposal Status
    // smart_contracts/proposal/contract.py:727
    // self.assign_voter_input_validation(voter.native, voting_power.native)
    frame_dig -1
    btoi
    // smart_contracts/proposal/contract.py:268
    // assert voter not in self.voters, err.VOTER_ALREADY_ASSIGNED
    bytec 28 // "V"
    frame_dig -2
    concat
    dup
    box_len
    bury 1
    !
    assert // Voter Already Assigned
    // smart_contracts/proposal/contract.py:269
    // assert voting_power > 0, err.INVALID_VOTING_POWER
    dig 1
    assert // Invalid Voting Power
    // smart_contracts/proposal/contract.py:729-732
    // self.voters[voter.native] = typ.VoterBox(
    //     votes=voting_power,
    //     voted=arc4.Bool(False),  # noqa: FBT003
    // )
    frame_dig -1
    // smart_contracts/proposal/contract.py:731
    // voted=arc4.Bool(False),  # noqa: FBT003
    bytec 21 // 0x00
    // smart_contracts/proposal/contract.py:729-732
    // self.voters[voter.native] = typ.VoterBox(
    //     votes=voting_power,
    //     voted=arc4.Bool(False),  # noqa: FBT003
    // )
    concat
    box_put
    // smart_contracts/proposal/contract.py:734
    // self.voters_count += 1
    intc_0 // 0
    bytec 9 // "voters_count"
    app_global_get_ex
    assert // check self.voters_count exists
    intc_1 // 1
    +
    bytec 9 // "voters_count"
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:735
    // self.assigned_votes += voting_power.native
    intc_0 // 0
    bytec 14 // "assigned_votes"
    app_global_get_ex
    assert // check self.assigned_votes exists
    +
    bytec 14 // "assigned_votes"
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:737
    // if self.voters_count == self.committee_members.value:
    intc_0 // 0
    bytec 9 // "voters_count"
    app_global_get_ex
    assert // check self.voters_count exists
    intc_0 // 0
    bytec 7 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    ==
    bz assign_voter_after_if_else@2
    // smart_contracts/proposal/contract.py:739
    // self.assigned_votes == self.committee_votes.value
    intc_0 // 0
    bytec 14 // "assigned_votes"
    app_global_get_ex
    assert // check self.assigned_votes exists
    intc_0 // 0
    bytec 10 // 0x636f6d6d69747465655f766f746573
    app_global_get_ex
    assert // check self.committee_votes exists
    ==
    // smart_contracts/proposal/contract.py:738-740
    // assert (
    //     self.assigned_votes == self.committee_votes.value
    // ), err.VOTING_POWER_MISMATCH
    assert // Voting Power Mismatch
    // smart_contracts/proposal/contract.py:741
    // self.status.value = UInt64(enm.STATUS_VOTING)
    bytec_1 // 0x737461747573
    pushint 25 // 25
    app_global_put
    // smart_contracts/proposal/contract.py:742
    // self.vote_open_ts.value = Global.latest_timestamp
    bytec 19 // 0x766f74655f6f70656e696e675f74696d657374616d70
    global LatestTimestamp
    app_global_put

assign_voter_after_if_else@2:
    retsub


// smart_contracts.proposal.contract.Proposal.vote(voter: bytes, approvals: bytes, rejections: bytes) -> bytes:
vote:
    // smart_contracts/proposal/contract.py:744-747
    // @arc4.abimethod()
    // def vote(
    //     self, voter: arc4.Address, approvals: arc4.UInt64, rejections: arc4.UInt64
    // ) -> typ.Error:
    proto 3 1
    intc_0 // 0
    dupn 2
    bytec_2 // ""
    dupn 2
    // smart_contracts/proposal/contract.py:766
    // self.check_registry_not_paused()
    callsub check_registry_not_paused
    // smart_contracts/proposal/contract.py:216
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:218
    // if self.status.value != enm.STATUS_VOTING:
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 25 // 25
    !=
    bz vote_after_if_else@15
    // smart_contracts/proposal/contract.py:219
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 22 // 0x00194552523a57726f6e672050726f706f73616c20537461747573
    frame_bury 0

vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_check_authorization@20:
    // smart_contracts/proposal/contract.py:769
    // if error != typ.Error(""):
    frame_dig 0
    bytec_0 // 0x0000
    !=
    bz vote_after_if_else@2
    // smart_contracts/proposal/contract.py:770
    // return error
    retsub

vote_after_if_else@2:
    // smart_contracts/proposal/contract.py:773
    // voter.native, approvals.native, rejections.native
    frame_dig -2
    btoi
    frame_bury 3
    frame_dig -1
    btoi
    frame_bury 5
    // smart_contracts/proposal/contract.py:234
    // if voter not in self.voters:
    bytec 28 // "V"
    frame_dig -3
    concat
    dup
    frame_bury 1
    box_len
    bury 1
    bnz vote_after_if_else@7
    // smart_contracts/proposal/contract.py:235
    // return typ.Error(err.ARC_65_PREFIX + err.VOTER_NOT_FOUND)
    pushbytes 0x00134552523a566f746572206e6f7420666f756e64
    frame_bury 0

vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_input_validation@12:
    // smart_contracts/proposal/contract.py:775
    // if error != typ.Error(""):
    frame_dig 0
    bytec_0 // 0x0000
    !=
    bz vote_after_if_else@4
    // smart_contracts/proposal/contract.py:776
    // return error
    retsub

vote_after_if_else@4:
    // smart_contracts/proposal/contract.py:778
    // voter_box = self.voters[voter.native].copy()
    frame_dig 1
    dup
    box_get
    assert // check self.voters entry exists
    // smart_contracts/proposal/contract.py:780
    // votes=voter_box.votes,
    dup
    extract 0 8 // on error: Index access is out of bounds
    // smart_contracts/proposal/contract.py:781
    // voted=arc4.Bool(True),  # noqa: FBT003
    pushbytes 0x80
    // smart_contracts/proposal/contract.py:779-782
    // self.voters[voter.native] = typ.VoterBox(
    //     votes=voter_box.votes,
    //     voted=arc4.Bool(True),  # noqa: FBT003
    // )
    concat
    uncover 2
    swap
    box_put
    // smart_contracts/proposal/contract.py:784
    // self.voted_members.value += 1
    intc_0 // 0
    bytec 11 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    intc_1 // 1
    +
    bytec 11 // 0x766f7465645f6d656d62657273
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:786
    // nulls = voter_box.votes.native - approvals.native - rejections.native
    intc_0 // 0
    extract_uint64
    frame_dig 3
    dup
    cover 2
    -
    frame_dig 5
    dup
    cover 3
    -
    // smart_contracts/proposal/contract.py:788
    // self.approvals.value += approvals.native
    intc_0 // 0
    bytec 12 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    uncover 2
    +
    bytec 12 // 0x617070726f76616c73
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:789
    // self.rejections.value += rejections.native
    intc_0 // 0
    bytec 13 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    uncover 2
    +
    bytec 13 // 0x72656a656374696f6e73
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:790
    // self.nulls.value += nulls
    intc_0 // 0
    bytec 16 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    +
    bytec 16 // 0x6e756c6c73
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:792
    // return typ.Error("")
    bytec_0 // 0x0000
    frame_bury 0
    retsub

vote_after_if_else@7:
    // smart_contracts/proposal/contract.py:237
    // voter_box = self.voters[voter].copy()
    frame_dig 1
    box_get
    swap
    dup
    cover 2
    frame_bury 2
    assert // check self.voters entry exists
    // smart_contracts/proposal/contract.py:238
    // if voter_box.voted:
    pushint 64 // 64
    getbit
    bytec 21 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 21 // 0x00
    !=
    bz vote_after_if_else@9
    // smart_contracts/proposal/contract.py:239
    // return typ.Error(err.ARC_65_PREFIX + err.VOTER_ALREADY_VOTED)
    pushbytes 0x00174552523a566f74657220616c726561647920766f746564
    frame_bury 0
    // smart_contracts/proposal/contract.py:772-774
    // error = self.vote_input_validation(
    //     voter.native, approvals.native, rejections.native
    // )
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_input_validation@12

vote_after_if_else@9:
    // smart_contracts/proposal/contract.py:241
    // if approvals + rejections > voter_box.votes:
    frame_dig 2
    extract 0 8 // on error: Index access is out of bounds
    frame_dig 3
    frame_dig 5
    +
    itob
    b<
    bz vote_after_if_else@11
    // smart_contracts/proposal/contract.py:242
    // return typ.Error(err.ARC_65_PREFIX + err.VOTES_EXCEEDED)
    pushbytes 0x00124552523a566f746573206578636565646564
    frame_bury 0
    // smart_contracts/proposal/contract.py:772-774
    // error = self.vote_input_validation(
    //     voter.native, approvals.native, rejections.native
    // )
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_input_validation@12

vote_after_if_else@11:
    // smart_contracts/proposal/contract.py:244
    // return typ.Error("")
    bytec_0 // 0x0000
    frame_bury 0
    // smart_contracts/proposal/contract.py:772-774
    // error = self.vote_input_validation(
    //     voter.native, approvals.native, rejections.native
    // )
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_input_validation@12

vote_after_if_else@15:
    // smart_contracts/proposal/contract.py:221
    // is_voting_open, error = self.is_voting_open()
    callsub is_voting_open
    dup
    cover 2
    frame_bury 0
    frame_bury 4
    // smart_contracts/proposal/contract.py:222
    // if error != typ.Error(""):
    bytec_0 // 0x0000
    !=
    bnz vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_check_authorization@20
    // smart_contracts/proposal/contract.py:225
    // if not is_voting_open:
    frame_dig 4
    bnz vote_after_if_else@19
    // smart_contracts/proposal/contract.py:226
    // return typ.Error(err.ARC_65_PREFIX + err.VOTING_PERIOD_EXPIRED)
    pushbytes 0x00194552523a566f74696e6720506572696f642045787069726564
    frame_bury 0
    // smart_contracts/proposal/contract.py:768
    // error = self.vote_check_authorization()
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_check_authorization@20

vote_after_if_else@19:
    // smart_contracts/proposal/contract.py:228
    // return typ.Error("")
    bytec_0 // 0x0000
    frame_bury 0
    // smart_contracts/proposal/contract.py:768
    // error = self.vote_check_authorization()
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_check_authorization@20


// smart_contracts.proposal.contract.Proposal.scrutiny() -> void:
scrutiny:
    // smart_contracts/proposal/contract.py:794-795
    // @arc4.abimethod()
    // def scrutiny(self) -> None:
    proto 0 0
    intc_0 // 0
    bytec_2 // ""
    dupn 3
    // smart_contracts/proposal/contract.py:805
    // self.check_registry_not_paused()
    callsub check_registry_not_paused
    // smart_contracts/proposal/contract.py:248
    // assert self.status.value == enm.STATUS_VOTING, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 25 // 25
    ==
    assert // Wrong Proposal Status
    // smart_contracts/proposal/contract.py:250
    // is_voting_open, error = self.is_voting_open()
    callsub is_voting_open
    // smart_contracts/proposal/contract.py:251
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:254
    // not is_voting_open  # voting period has ended
    bz scrutiny_bool_true@8
    // smart_contracts/proposal/contract.py:255
    // or self.voted_members.value
    intc_0 // 0
    bytec 11 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    // smart_contracts/proposal/contract.py:256
    // == self.committee_members.value  # all committee members have voted
    intc_0 // 0
    bytec 7 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    // smart_contracts/proposal/contract.py:255-256
    // or self.voted_members.value
    // == self.committee_members.value  # all committee members have voted
    ==
    // smart_contracts/proposal/contract.py:254-256
    // not is_voting_open  # voting period has ended
    // or self.voted_members.value
    // == self.committee_members.value  # all committee members have voted
    bz scrutiny_bool_false@9

scrutiny_bool_true@8:
    intc_1 // 1

scrutiny_bool_merge@10:
    // smart_contracts/proposal/contract.py:253-257
    // assert (
    //     not is_voting_open  # voting period has ended
    //     or self.voted_members.value
    //     == self.committee_members.value  # all committee members have voted
    // ), err.VOTING_ONGOING
    assert // Voting Ongoing
    // smart_contracts/proposal/contract.py:809-811
    // # A category dependent quorum of all xGov Voting Committee (1 xGov, 1 vote) is reached.
    // # Null votes affect this quorum.
    // quorum_bps = self.get_quorum(self.funding_category.value)
    intc_0 // 0
    bytec 4 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    swap
    dup
    cover 2
    frame_bury 1
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:305
    // if category == enm.FUNDING_CATEGORY_SMALL:
    intc_2 // 10
    ==
    bz scrutiny_else_body@14
    // smart_contracts/proposal/contract.py:307
    // Bytes(reg_cfg.GS_KEY_QUORUM_SMALL)
    pushbytes 0x71756f72756d5f736d616c6c
    // smart_contracts/proposal/contract.py:306-308
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_QUORUM_SMALL)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0

scrutiny_after_if_else@18:
    // smart_contracts/proposal/contract.py:317
    // assert error == typ.Error(""), err.MISSING_CONFIG
    frame_dig 0
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:813
    // self.committee_members.value, quorum_bps
    intc_0 // 0
    bytec 7 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    // smart_contracts/proposal/contract.py:430
    // return amount * fraction_in_bps // const.BPS
    *
    intc 4 // 10000
    /
    frame_bury 2
    // smart_contracts/proposal/contract.py:816-818
    // # A category dependent weighted quorum of all xGov Voting Committee voting power (1 vote) is reached.
    // # Null votes affect this quorum.
    // weighted_quorum_bps = self.get_weighted_quorum(self.funding_category.value)
    intc_0 // 0
    bytec 4 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    swap
    dup
    cover 2
    frame_bury 1
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:322
    // if category == enm.FUNDING_CATEGORY_SMALL:
    intc_2 // 10
    ==
    bz scrutiny_else_body@22
    // smart_contracts/proposal/contract.py:324
    // Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_SMALL)
    pushbytes 0x77656967687465645f71756f72756d5f736d616c6c
    // smart_contracts/proposal/contract.py:323-325
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_SMALL)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0

scrutiny_after_if_else@26:
    // smart_contracts/proposal/contract.py:334
    // assert error == typ.Error(""), err.MISSING_CONFIG
    frame_dig 0
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:819
    // total_votes = self.approvals.value + self.rejections.value + self.nulls.value
    intc_0 // 0
    bytec 12 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    intc_0 // 0
    bytec 13 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    +
    intc_0 // 0
    bytec 16 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    +
    frame_bury 4
    // smart_contracts/proposal/contract.py:821
    // self.committee_votes.value, weighted_quorum_bps
    intc_0 // 0
    bytec 10 // 0x636f6d6d69747465655f766f746573
    app_global_get_ex
    assert // check self.committee_votes exists
    // smart_contracts/proposal/contract.py:430
    // return amount * fraction_in_bps // const.BPS
    *
    intc 4 // 10000
    /
    frame_bury 3
    // smart_contracts/proposal/contract.py:825
    // self.voted_members.value >= minimum_voters_required
    intc_0 // 0
    bytec 11 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    frame_dig 2
    >=
    // smart_contracts/proposal/contract.py:825-829
    // self.voted_members.value >= minimum_voters_required
    // and total_votes >= minimum_votes_required
    // # The relative majority of Approved over Rejected votes is reached.
    // # Null votes do not affect the relative majority.
    // and self.approvals.value > self.rejections.value
    bz scrutiny_else_body@4
    // smart_contracts/proposal/contract.py:826
    // and total_votes >= minimum_votes_required
    frame_dig 4
    frame_dig 3
    >=
    // smart_contracts/proposal/contract.py:825-829
    // self.voted_members.value >= minimum_voters_required
    // and total_votes >= minimum_votes_required
    // # The relative majority of Approved over Rejected votes is reached.
    // # Null votes do not affect the relative majority.
    // and self.approvals.value > self.rejections.value
    bz scrutiny_else_body@4
    // smart_contracts/proposal/contract.py:827-829
    // # The relative majority of Approved over Rejected votes is reached.
    // # Null votes do not affect the relative majority.
    // and self.approvals.value > self.rejections.value
    intc_0 // 0
    bytec 12 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    intc_0 // 0
    bytec 13 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    >
    // smart_contracts/proposal/contract.py:825-829
    // self.voted_members.value >= minimum_voters_required
    // and total_votes >= minimum_votes_required
    // # The relative majority of Approved over Rejected votes is reached.
    // # Null votes do not affect the relative majority.
    // and self.approvals.value > self.rejections.value
    bz scrutiny_else_body@4
    // smart_contracts/proposal/contract.py:831
    // self.status.value = UInt64(enm.STATUS_APPROVED)
    bytec_1 // 0x737461747573
    pushint 30 // 30
    app_global_put
    retsub

scrutiny_else_body@4:
    // smart_contracts/proposal/contract.py:833
    // self.status.value = UInt64(enm.STATUS_REJECTED)
    bytec_1 // 0x737461747573
    pushint 40 // 40
    app_global_put
    // smart_contracts/proposal/contract.py:835
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:834-836
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount
    // smart_contracts/proposal/contract.py:837
    // self.cool_down_start_ts.value = Global.latest_timestamp
    bytec 8 // 0x636f6f6c5f646f776e5f73746172745f7473
    global LatestTimestamp
    app_global_put
    retsub

scrutiny_else_body@22:
    // smart_contracts/proposal/contract.py:326
    // elif category == enm.FUNDING_CATEGORY_MEDIUM:
    frame_dig 1
    intc_3 // 20
    ==
    bz scrutiny_else_body@24
    // smart_contracts/proposal/contract.py:328
    // Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_MEDIUM)
    pushbytes 0x77656967687465645f71756f72756d5f6d656469756d
    // smart_contracts/proposal/contract.py:327-329
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b scrutiny_after_if_else@26

scrutiny_else_body@24:
    // smart_contracts/proposal/contract.py:332
    // Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_LARGE)
    pushbytes 0x77656967687465645f71756f72756d5f6c61726765
    // smart_contracts/proposal/contract.py:331-333
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_LARGE)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b scrutiny_after_if_else@26

scrutiny_else_body@14:
    // smart_contracts/proposal/contract.py:309
    // elif category == enm.FUNDING_CATEGORY_MEDIUM:
    frame_dig 1
    intc_3 // 20
    ==
    bz scrutiny_else_body@16
    // smart_contracts/proposal/contract.py:311
    // Bytes(reg_cfg.GS_KEY_QUORUM_MEDIUM)
    pushbytes 0x71756f72756d5f6d656469756d
    // smart_contracts/proposal/contract.py:310-312
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_QUORUM_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b scrutiny_after_if_else@18

scrutiny_else_body@16:
    // smart_contracts/proposal/contract.py:315
    // Bytes(reg_cfg.GS_KEY_QUORUM_LARGE)
    pushbytes 0x71756f72756d5f6c61726765
    // smart_contracts/proposal/contract.py:314-316
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_QUORUM_LARGE)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b scrutiny_after_if_else@18

scrutiny_bool_false@9:
    intc_0 // 0
    b scrutiny_bool_merge@10


// smart_contracts.proposal.contract.Proposal.review(block: uint64) -> void:
review:
    // smart_contracts/proposal/contract.py:839-840
    // @arc4.abimethod()
    // def review(self, block: bool) -> None:  # noqa: FBT001
    proto 1 0
    // smart_contracts/proposal/contract.py:513
    // return Txn.sender == Account(
    txn Sender
    // smart_contracts/proposal/contract.py:514
    // self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_REVIEWER))
    pushbytes 0x78676f765f7265766965776572
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:513-515
    // return Txn.sender == Account(
    //     self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_REVIEWER))
    // )
    dup
    len
    pushint 32 // 32
    ==
    assert // Address length is 32 bytes
    ==
    // smart_contracts/proposal/contract.py:154
    // assert self.is_reviewer(), err.UNAUTHORIZED
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:155
    // assert self.status.value == enm.STATUS_APPROVED, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 30 // 30
    ==
    assert // Wrong Proposal Status
    // smart_contracts/proposal/contract.py:854
    // if block:
    frame_dig -1
    bz review_else_body@2
    // smart_contracts/proposal/contract.py:855
    // self.status.value = UInt64(enm.STATUS_BLOCKED)
    bytec_1 // 0x737461747573
    pushint 60 // 60
    app_global_put
    // smart_contracts/proposal/contract.py:857-858
    // # slashing: send locked amount to the registry treasury
    // reg_app = Application(self.registry_app_id.value)
    intc_0 // 0
    bytec 6 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:860
    // receiver=reg_app.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/proposal/contract.py:859-861
    // self.transfer_locked_amount(
    //     receiver=reg_app.address,
    // )
    callsub transfer_locked_amount
    // smart_contracts/proposal/contract.py:863
    // self.cool_down_start_ts.value = Global.latest_timestamp
    bytec 8 // 0x636f6f6c5f646f776e5f73746172745f7473
    global LatestTimestamp
    app_global_put
    retsub

review_else_body@2:
    // smart_contracts/proposal/contract.py:865
    // self.status.value = UInt64(enm.STATUS_REVIEWED)
    bytec_1 // 0x737461747573
    pushint 45 // 45
    app_global_put
    retsub


// smart_contracts.proposal.contract.Proposal.fund() -> bytes:
fund:
    // smart_contracts/proposal/contract.py:867-868
    // @arc4.abimethod()
    // def fund(self) -> typ.Error:
    proto 0 1
    intc_0 // 0
    // smart_contracts/proposal/contract.py:159
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:160
    // if self.status.value != enm.STATUS_REVIEWED:
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 45 // 45
    !=
    bz fund_after_if_else@5
    // smart_contracts/proposal/contract.py:161
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 22 // 0x00194552523a57726f6e672050726f706f73616c20537461747573
    frame_bury 0

fund_after_inlined_smart_contracts.proposal.contract.Proposal.fund_check_authorization@6:
    // smart_contracts/proposal/contract.py:877
    // if error != typ.Error(""):
    frame_dig 0
    bytec_0 // 0x0000
    !=
    bz fund_after_if_else@2
    // smart_contracts/proposal/contract.py:878
    // return error
    frame_dig 0
    swap
    retsub

fund_after_if_else@2:
    // smart_contracts/proposal/contract.py:880
    // self.status.value = UInt64(enm.STATUS_FUNDED)
    bytec_1 // 0x737461747573
    pushint 50 // 50
    app_global_put
    // smart_contracts/proposal/contract.py:884
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:882-885
    // # refund the locked amount to the proposer
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount
    // smart_contracts/proposal/contract.py:887
    // self.cool_down_start_ts.value = Global.latest_timestamp
    bytec 8 // 0x636f6f6c5f646f776e5f73746172745f7473
    global LatestTimestamp
    app_global_put
    // smart_contracts/proposal/contract.py:889
    // return typ.Error("")
    bytec_0 // 0x0000
    swap
    retsub

fund_after_if_else@5:
    // smart_contracts/proposal/contract.py:163
    // return typ.Error("")
    bytec_0 // 0x0000
    frame_bury 0
    // smart_contracts/proposal/contract.py:876
    // error = self.fund_check_authorization()
    b fund_after_inlined_smart_contracts.proposal.contract.Proposal.fund_check_authorization@6


// smart_contracts.proposal.contract.Proposal.unassign_voters(voters: bytes) -> void:
unassign_voters:
    // smart_contracts/proposal/contract.py:891-892
    // @arc4.abimethod()
    // def unassign_voters(self, voters: arc4.DynamicArray[arc4.Address]) -> None:
    proto 1 0
    intc_0 // 0
    bytec_2 // ""
    dup
    // smart_contracts/proposal/contract.py:167
    // assert self.is_committee_publisher(), err.UNAUTHORIZED
    callsub is_committee_publisher
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:169
    // self.status.value == enm.STATUS_FUNDED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 50 // 50
    ==
    // smart_contracts/proposal/contract.py:169-171
    // self.status.value == enm.STATUS_FUNDED
    // or self.status.value == enm.STATUS_BLOCKED
    // or self.status.value == enm.STATUS_REJECTED
    bnz unassign_voters_bool_true@10
    // smart_contracts/proposal/contract.py:170
    // or self.status.value == enm.STATUS_BLOCKED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 60 // 60
    ==
    // smart_contracts/proposal/contract.py:169-171
    // self.status.value == enm.STATUS_FUNDED
    // or self.status.value == enm.STATUS_BLOCKED
    // or self.status.value == enm.STATUS_REJECTED
    bnz unassign_voters_bool_true@10
    // smart_contracts/proposal/contract.py:171
    // or self.status.value == enm.STATUS_REJECTED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 40 // 40
    ==
    // smart_contracts/proposal/contract.py:169-171
    // self.status.value == enm.STATUS_FUNDED
    // or self.status.value == enm.STATUS_BLOCKED
    // or self.status.value == enm.STATUS_REJECTED
    bz unassign_voters_bool_false@11

unassign_voters_bool_true@10:
    intc_1 // 1

unassign_voters_bool_merge@12:
    // smart_contracts/proposal/contract.py:168-172
    // assert (
    //     self.status.value == enm.STATUS_FUNDED
    //     or self.status.value == enm.STATUS_BLOCKED
    //     or self.status.value == enm.STATUS_REJECTED
    // ), err.WRONG_PROPOSAL_STATUS
    assert // Wrong Proposal Status
    // smart_contracts/proposal/contract.py:906-907
    // # remove voters
    // for voter in voters:
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_bury 1
    intc_0 // 0
    frame_bury 2

unassign_voters_for_header@1:
    // smart_contracts/proposal/contract.py:906-907
    // # remove voters
    // for voter in voters:
    frame_dig 2
    frame_dig 1
    <
    bz unassign_voters_after_for@6
    frame_dig -1
    extract 2 0
    frame_dig 2
    pushint 32 // 32
    *
    pushint 32 // 32
    extract3 // on error: Index access is out of bounds
    // smart_contracts/proposal/contract.py:908
    // if voter.native in self.voters:
    bytec 28 // "V"
    swap
    concat
    dup
    frame_bury 0
    box_len
    bury 1
    bz unassign_voters_after_if_else@4
    // smart_contracts/proposal/contract.py:909
    // self.voters_count -= 1
    intc_0 // 0
    bytec 9 // "voters_count"
    app_global_get_ex
    assert // check self.voters_count exists
    intc_1 // 1
    -
    bytec 9 // "voters_count"
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:910
    // self.assigned_votes -= self.voters[voter.native].votes.native
    intc_0 // 0
    bytec 14 // "assigned_votes"
    app_global_get_ex
    assert // check self.assigned_votes exists
    frame_dig 0
    dup
    cover 2
    box_get
    assert // check self.voters entry exists
    intc_0 // 0
    extract_uint64
    -
    bytec 14 // "assigned_votes"
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:911
    // del self.voters[voter.native]
    box_del
    pop

unassign_voters_after_if_else@4:
    frame_dig 2
    intc_1 // 1
    +
    frame_bury 2
    b unassign_voters_for_header@1

unassign_voters_after_for@6:
    retsub

unassign_voters_bool_false@11:
    intc_0 // 0
    b unassign_voters_bool_merge@12


// smart_contracts.proposal.contract.Proposal.decommission() -> bytes:
decommission:
    // smart_contracts/proposal/contract.py:913-914
    // @arc4.abimethod()
    // def decommission(self) -> typ.Error:
    proto 0 1
    intc_0 // 0
    bytec_2 // ""
    // smart_contracts/proposal/contract.py:176
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:179
    // self.status.value != enm.STATUS_EMPTY
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    // smart_contracts/proposal/contract.py:179-183
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz decommission_after_if_else@13
    // smart_contracts/proposal/contract.py:180
    // and self.status.value != enm.STATUS_DRAFT
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_2 // 10
    !=
    // smart_contracts/proposal/contract.py:179-183
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz decommission_after_if_else@13
    // smart_contracts/proposal/contract.py:181
    // and self.status.value != enm.STATUS_FUNDED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 50 // 50
    !=
    // smart_contracts/proposal/contract.py:179-183
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz decommission_after_if_else@13
    // smart_contracts/proposal/contract.py:182
    // and self.status.value != enm.STATUS_BLOCKED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 60 // 60
    !=
    // smart_contracts/proposal/contract.py:179-183
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz decommission_after_if_else@13
    // smart_contracts/proposal/contract.py:183
    // and self.status.value != enm.STATUS_REJECTED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 40 // 40
    !=
    // smart_contracts/proposal/contract.py:179-183
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz decommission_after_if_else@13
    // smart_contracts/proposal/contract.py:185
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 22 // 0x00194552523a57726f6e672050726f706f73616c20537461747573
    frame_bury 0

decommission_after_inlined_smart_contracts.proposal.contract.Proposal.decommission_check_authorization@21:
    // smart_contracts/proposal/contract.py:926
    // if error != typ.Error(""):
    frame_dig 0
    bytec_0 // 0x0000
    !=
    bz decommission_after_if_else@2
    // smart_contracts/proposal/contract.py:927
    // return error
    retsub

decommission_after_if_else@2:
    // smart_contracts/proposal/contract.py:929-930
    // # check no assigned voters
    // if self.voters_count > UInt64(0):
    intc_0 // 0
    bytec 9 // "voters_count"
    app_global_get_ex
    assert // check self.voters_count exists
    bz decommission_after_if_else@4
    // smart_contracts/proposal/contract.py:931
    // return typ.Error(err.ARC_65_PREFIX + err.VOTERS_ASSIGNED)
    pushbytes 0x002e4552523a54686572652061726520766f746572732061737369676e656420746f20746869732070726f706f73616c
    frame_bury 0
    retsub

decommission_after_if_else@4:
    // smart_contracts/proposal/contract.py:933-934
    // # delete metadata box if it exists
    // self.metadata.delete()
    bytec 5 // "M"
    box_del
    pop
    // smart_contracts/proposal/contract.py:936-939
    // # refund the locked amount for DRAFT proposals
    // # for REJECTED proposals, the locked amount is already refunded in the scrutiny method
    // # for EMPTY, FUNDED, or BLOCKED proposals, the locked amount is not refundable
    // if self.status.value == enm.STATUS_DRAFT:
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_2 // 10
    ==
    bz decommission_after_if_else@6
    // smart_contracts/proposal/contract.py:941
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:940-942
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount

decommission_after_if_else@6:
    // smart_contracts/proposal/contract.py:943
    // reg_app = Application(self.registry_app_id.value)
    intc_0 // 0
    bytec 6 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:945
    // receiver=reg_app.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/proposal/contract.py:946
    // amount=Global.current_application_address.balance,
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/proposal/contract.py:944-947
    // self.pay(
    //     receiver=reg_app.address,
    //     amount=Global.current_application_address.balance,
    // )
    callsub pay
    // smart_contracts/proposal/contract.py:948
    // self.status.value = UInt64(enm.STATUS_DECOMMISSIONED)
    bytec_1 // 0x737461747573
    pushint 70 // 70
    app_global_put
    // smart_contracts/proposal/contract.py:950
    // return typ.Error("")
    bytec_0 // 0x0000
    frame_bury 0
    retsub

decommission_after_if_else@13:
    // smart_contracts/proposal/contract.py:188
    // self.status.value != enm.STATUS_EMPTY
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    // smart_contracts/proposal/contract.py:188-189
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    bz decommission_after_if_else@20
    // smart_contracts/proposal/contract.py:189
    // and self.status.value != enm.STATUS_DRAFT
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_2 // 10
    !=
    // smart_contracts/proposal/contract.py:188-189
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    bz decommission_after_if_else@20
    // smart_contracts/proposal/contract.py:192
    // Bytes(reg_cfg.GS_KEY_COOL_DOWN_DURATION)
    pushbytes 0x636f6f6c5f646f776e5f6475726174696f6e
    // smart_contracts/proposal/contract.py:191-193
    // cooldown_duration, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COOL_DOWN_DURATION)
    // )
    callsub get_uint_from_registry_config
    dup
    cover 2
    frame_bury 0
    frame_bury 1
    // smart_contracts/proposal/contract.py:194
    // if error != typ.Error(""):
    bytec_0 // 0x0000
    !=
    bnz decommission_after_inlined_smart_contracts.proposal.contract.Proposal.decommission_check_authorization@21
    // smart_contracts/proposal/contract.py:198
    // self.cool_down_start_ts.value == 0
    intc_0 // 0
    bytec 8 // 0x636f6f6c5f646f776e5f73746172745f7473
    app_global_get_ex
    assert // check self.cool_down_start_ts exists
    // smart_contracts/proposal/contract.py:198-200
    // self.cool_down_start_ts.value == 0
    // or Global.latest_timestamp
    // < self.cool_down_start_ts.value + cooldown_duration
    bz decommission_if_body@19
    // smart_contracts/proposal/contract.py:199
    // or Global.latest_timestamp
    global LatestTimestamp
    // smart_contracts/proposal/contract.py:200
    // < self.cool_down_start_ts.value + cooldown_duration
    intc_0 // 0
    bytec 8 // 0x636f6f6c5f646f776e5f73746172745f7473
    app_global_get_ex
    assert // check self.cool_down_start_ts exists
    frame_dig 1
    +
    // smart_contracts/proposal/contract.py:199-200
    // or Global.latest_timestamp
    // < self.cool_down_start_ts.value + cooldown_duration
    <
    // smart_contracts/proposal/contract.py:198-200
    // self.cool_down_start_ts.value == 0
    // or Global.latest_timestamp
    // < self.cool_down_start_ts.value + cooldown_duration
    bz decommission_after_if_else@20

decommission_if_body@19:
    // smart_contracts/proposal/contract.py:202
    // return typ.Error(err.ARC_65_PREFIX + err.TOO_EARLY)
    pushbytes 0x000d4552523a546f6f206561726c79
    frame_bury 0
    // smart_contracts/proposal/contract.py:925
    // error = self.decommission_check_authorization()
    b decommission_after_inlined_smart_contracts.proposal.contract.Proposal.decommission_check_authorization@21

decommission_after_if_else@20:
    // smart_contracts/proposal/contract.py:204
    // return typ.Error("")
    bytec_0 // 0x0000
    frame_bury 0
    // smart_contracts/proposal/contract.py:925
    // error = self.decommission_check_authorization()
    b decommission_after_inlined_smart_contracts.proposal.contract.Proposal.decommission_check_authorization@21


// smart_contracts.proposal.contract.Proposal.delete() -> bytes:
delete:
    // smart_contracts/proposal/contract.py:952-953
    // @arc4.abimethod(allow_actions=("DeleteApplication",))
    // def delete(self) -> typ.Error:
    proto 0 1
    intc_0 // 0
    // smart_contracts/proposal/contract.py:208
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:209
    // if self.status.value != enm.STATUS_DECOMMISSIONED:
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 70 // 70
    !=
    bz delete_after_if_else@5
    // smart_contracts/proposal/contract.py:210
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 22 // 0x00194552523a57726f6e672050726f706f73616c20537461747573
    frame_bury 0

delete_after_inlined_smart_contracts.proposal.contract.Proposal.delete_check_authorization@6:
    // smart_contracts/proposal/contract.py:963
    // if error != typ.Error(""):
    frame_dig 0
    bytec_0 // 0x0000
    !=
    bz delete_after_if_else@2
    // smart_contracts/proposal/contract.py:964
    // return error
    frame_dig 0
    swap
    retsub

delete_after_if_else@2:
    // smart_contracts/proposal/contract.py:966
    // return typ.Error("")
    bytec_0 // 0x0000
    swap
    retsub

delete_after_if_else@5:
    // smart_contracts/proposal/contract.py:212
    // return typ.Error("")
    bytec_0 // 0x0000
    frame_bury 0
    // smart_contracts/proposal/contract.py:962
    // error = self.delete_check_authorization()
    b delete_after_inlined_smart_contracts.proposal.contract.Proposal.delete_check_authorization@6


// smart_contracts.proposal.contract.Proposal.get_state() -> bytes:
get_state:
    // smart_contracts/proposal/contract.py:977
    // proposer=arc4.Address(self.proposer.value),
    intc_0 // 0
    bytec_3 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:978
    // registry_app_id=arc4.UInt64(self.registry_app_id.value),
    intc_0 // 0
    bytec 6 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    itob
    // smart_contracts/proposal/contract.py:979
    // title=arc4.String(self.title.value),
    intc_0 // 0
    bytec 23 // 0x7469746c65
    app_global_get_ex
    assert // check self.title exists
    dup
    len
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/proposal/contract.py:980
    // submission_ts=arc4.UInt64(self.submission_ts.value),
    intc_0 // 0
    bytec 18 // 0x7375626d697373696f6e5f74696d657374616d70
    app_global_get_ex
    assert // check self.submission_ts exists
    itob
    // smart_contracts/proposal/contract.py:981
    // finalization_ts=arc4.UInt64(self.finalization_ts.value),
    intc_0 // 0
    bytec 24 // 0x66696e616c697a6174696f6e5f74696d657374616d70
    app_global_get_ex
    assert // check self.finalization_ts exists
    itob
    // smart_contracts/proposal/contract.py:982
    // vote_open_ts=arc4.UInt64(self.vote_open_ts.value),
    intc_0 // 0
    bytec 19 // 0x766f74655f6f70656e696e675f74696d657374616d70
    app_global_get_ex
    assert // check self.vote_open_ts exists
    itob
    // smart_contracts/proposal/contract.py:983
    // status=arc4.UInt64(self.status.value),
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    itob
    // smart_contracts/proposal/contract.py:984
    // funding_category=arc4.UInt64(self.funding_category.value),
    intc_0 // 0
    bytec 4 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    assert // check self.funding_category exists
    itob
    // smart_contracts/proposal/contract.py:985
    // focus=arc4.UInt8(self.focus.value),
    intc_0 // 0
    bytec 25 // 0x666f637573
    app_global_get_ex
    assert // check self.focus exists
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/proposal/contract.py:986
    // funding_type=arc4.UInt64(self.funding_type.value),
    intc_0 // 0
    bytec 26 // 0x66756e64696e675f74797065
    app_global_get_ex
    assert // check self.funding_type exists
    itob
    // smart_contracts/proposal/contract.py:987
    // requested_amount=arc4.UInt64(self.requested_amount.value),
    intc_0 // 0
    bytec 27 // 0x7265717565737465645f616d6f756e74
    app_global_get_ex
    assert // check self.requested_amount exists
    itob
    // smart_contracts/proposal/contract.py:988
    // locked_amount=arc4.UInt64(self.locked_amount.value),
    intc_0 // 0
    bytec 15 // 0x6c6f636b65645f616d6f756e74
    app_global_get_ex
    assert // check self.locked_amount exists
    itob
    // smart_contracts/proposal/contract.py:989
    // committee_id=self.committee_id.value.copy(),
    intc_0 // 0
    bytec 20 // 0x636f6d6d69747465655f6964
    app_global_get_ex
    assert // check self.committee_id exists
    // smart_contracts/proposal/contract.py:990
    // committee_members=arc4.UInt64(self.committee_members.value),
    intc_0 // 0
    bytec 7 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    itob
    // smart_contracts/proposal/contract.py:991
    // committee_votes=arc4.UInt64(self.committee_votes.value),
    intc_0 // 0
    bytec 10 // 0x636f6d6d69747465655f766f746573
    app_global_get_ex
    assert // check self.committee_votes exists
    itob
    // smart_contracts/proposal/contract.py:992
    // voted_members=arc4.UInt64(self.voted_members.value),
    intc_0 // 0
    bytec 11 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    itob
    // smart_contracts/proposal/contract.py:993
    // approvals=arc4.UInt64(self.approvals.value),
    intc_0 // 0
    bytec 12 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    itob
    // smart_contracts/proposal/contract.py:994
    // rejections=arc4.UInt64(self.rejections.value),
    intc_0 // 0
    bytec 13 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    itob
    // smart_contracts/proposal/contract.py:995
    // nulls=arc4.UInt64(self.nulls.value),
    intc_0 // 0
    bytec 16 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    itob
    // smart_contracts/proposal/contract.py:996
    // cool_down_start_ts=arc4.UInt64(self.cool_down_start_ts.value),
    intc_0 // 0
    bytec 8 // 0x636f6f6c5f646f776e5f73746172745f7473
    app_global_get_ex
    assert // check self.cool_down_start_ts exists
    itob
    // smart_contracts/proposal/contract.py:976-997
    // return typ.ProposalTypedGlobalState(
    //     proposer=arc4.Address(self.proposer.value),
    //     registry_app_id=arc4.UInt64(self.registry_app_id.value),
    //     title=arc4.String(self.title.value),
    //     submission_ts=arc4.UInt64(self.submission_ts.value),
    //     finalization_ts=arc4.UInt64(self.finalization_ts.value),
    //     vote_open_ts=arc4.UInt64(self.vote_open_ts.value),
    //     status=arc4.UInt64(self.status.value),
    //     funding_category=arc4.UInt64(self.funding_category.value),
    //     focus=arc4.UInt8(self.focus.value),
    //     funding_type=arc4.UInt64(self.funding_type.value),
    //     requested_amount=arc4.UInt64(self.requested_amount.value),
    //     locked_amount=arc4.UInt64(self.locked_amount.value),
    //     committee_id=self.committee_id.value.copy(),
    //     committee_members=arc4.UInt64(self.committee_members.value),
    //     committee_votes=arc4.UInt64(self.committee_votes.value),
    //     voted_members=arc4.UInt64(self.voted_members.value),
    //     approvals=arc4.UInt64(self.approvals.value),
    //     rejections=arc4.UInt64(self.rejections.value),
    //     nulls=arc4.UInt64(self.nulls.value),
    //     cool_down_start_ts=arc4.UInt64(self.cool_down_start_ts.value),
    // )
    uncover 19
    uncover 19
    concat
    pushbytes 0x00c3
    concat
    uncover 17
    concat
    uncover 16
    concat
    uncover 15
    concat
    uncover 14
    concat
    uncover 13
    concat
    uncover 12
    concat
    uncover 11
    concat
    uncover 10
    concat
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    swap
    concat
    retsub
