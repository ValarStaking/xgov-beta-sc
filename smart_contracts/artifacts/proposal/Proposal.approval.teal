#pragma version 10

smart_contracts.proposal.contract.Proposal.approval_program:
    intcblock 0 1 10 20
    bytecblock 0x0000 0x737461747573 0x63617465676f7279 0x 0x70726f706f736572 0x6c6f636b65645f616d6f756e74 0x636f6d6d69747465655f6d656d62657273 0x72656769737472795f6170705f6964 0x636f6d6d69747465655f766f746573 0x766f7465645f6d656d62657273 0x617070726f76616c73 0x72656a656374696f6e73 0x7469746c65 0x636964 0x7375626d697373696f6e5f74696d657374616d70 0x6e756c6c73 "voters_count" "assigned_votes" "V" 0x766f74655f6f70656e696e675f74696d657374616d70 0x66756e64696e675f74797065 0x7265717565737465645f616d6f756e74 0x636f6d6d69747465655f6964 0x00 0x66696e616c697a6174696f6e5f74696d657374616d70 0x636f6d6d69747465655f7075626c6973686572
    txn ApplicationID
    bnz main_after_if_else@2
    callsub __init__

main_after_if_else@2:
    callsub __puya_arc4_router__
    return


// smart_contracts.proposal.contract.Proposal.__init__() -> void:
__init__:
    // smart_contracts/proposal/contract.py:39
    // def __init__(self) -> None:
    proto 0 0
    // smart_contracts/proposal/contract.py:42
    // Txn.global_num_byte_slice == prop_cfg.GLOBAL_BYTES
    txn GlobalNumByteSlice
    pushint 5 // 5
    ==
    // smart_contracts/proposal/contract.py:40-43
    // # Preconditions
    // assert (
    //     Txn.global_num_byte_slice == prop_cfg.GLOBAL_BYTES
    // ), err.WRONG_GLOBAL_BYTES
    assert // Wrong Global Bytes allocation
    // smart_contracts/proposal/contract.py:44
    // assert Txn.global_num_uint == prop_cfg.GLOBAL_UINTS, err.WRONG_GLOBAL_UINTS
    txn GlobalNumUint
    intc_3 // 20
    ==
    assert // Wrong Global UInts allocation
    // smart_contracts/proposal/contract.py:45
    // assert Txn.local_num_byte_slice == prop_cfg.LOCAL_BYTES, err.WRONG_LOCAL_BYTES
    txn LocalNumByteSlice
    !
    assert // Wrong Local Bytes allocation
    // smart_contracts/proposal/contract.py:46
    // assert Txn.local_num_uint == prop_cfg.LOCAL_UINTS, err.WRONG_LOCAL_UINTS
    txn LocalNumUint
    !
    assert // Wrong Local UInts allocation
    // smart_contracts/proposal/contract.py:50
    // key=prop_cfg.GS_KEY_PROPOSER,
    bytec 4 // 0x70726f706f736572
    // smart_contracts/proposal/contract.py:49
    // arc4.Address(),
    global ZeroAddress
    // smart_contracts/proposal/contract.py:48-51
    // self.proposer = GlobalState(
    //     arc4.Address(),
    //     key=prop_cfg.GS_KEY_PROPOSER,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:54
    // key=prop_cfg.GS_KEY_REGISTRY_APP_ID,
    bytec 7 // 0x72656769737472795f6170705f6964
    // smart_contracts/proposal/contract.py:53
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:52-55
    // self.registry_app_id = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_REGISTRY_APP_ID,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:58
    // key=prop_cfg.GS_KEY_TITLE,
    bytec 12 // 0x7469746c65
    // smart_contracts/proposal/contract.py:57
    // String(),
    bytec_3 // ""
    // smart_contracts/proposal/contract.py:56-59
    // self.title = GlobalState(
    //     String(),
    //     key=prop_cfg.GS_KEY_TITLE,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:62
    // key=prop_cfg.GS_KEY_CID,
    bytec 13 // 0x636964
    // smart_contracts/proposal/contract.py:61
    // typ.Cid.from_bytes(b""),
    bytec_3 // 0x
    // smart_contracts/proposal/contract.py:60-63
    // self.cid = GlobalState(
    //     typ.Cid.from_bytes(b""),
    //     key=prop_cfg.GS_KEY_CID,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:66
    // key=prop_cfg.GS_KEY_SUBMISSION_TS,
    bytec 14 // 0x7375626d697373696f6e5f74696d657374616d70
    // smart_contracts/proposal/contract.py:65
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:64-67
    // self.submission_ts = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_SUBMISSION_TS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:70
    // key=prop_cfg.GS_KEY_FINALIZATION_TS,
    bytec 24 // 0x66696e616c697a6174696f6e5f74696d657374616d70
    // smart_contracts/proposal/contract.py:69
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:68-71
    // self.finalization_ts = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_FINALIZATION_TS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:74
    // key=prop_cfg.GS_KEY_VOTE_OPEN_TS,
    bytec 19 // 0x766f74655f6f70656e696e675f74696d657374616d70
    // smart_contracts/proposal/contract.py:73
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:72-75
    // self.vote_open_ts = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_VOTE_OPEN_TS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:78
    // key=prop_cfg.GS_KEY_STATUS,
    bytec_1 // 0x737461747573
    // smart_contracts/proposal/contract.py:77
    // UInt64(enm.STATUS_EMPTY),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:76-79
    // self.status = GlobalState(
    //     UInt64(enm.STATUS_EMPTY),
    //     key=prop_cfg.GS_KEY_STATUS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:82
    // key=prop_cfg.GS_KEY_CATEGORY,
    bytec_2 // 0x63617465676f7279
    // smart_contracts/proposal/contract.py:81
    // UInt64(enm.CATEGORY_NULL),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:80-83
    // self.category = GlobalState(
    //     UInt64(enm.CATEGORY_NULL),
    //     key=prop_cfg.GS_KEY_CATEGORY,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:86
    // key=prop_cfg.GS_KEY_FUNDING_TYPE,
    bytec 20 // 0x66756e64696e675f74797065
    // smart_contracts/proposal/contract.py:85
    // UInt64(enm.FUNDING_NULL),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:84-87
    // self.funding_type = GlobalState(
    //     UInt64(enm.FUNDING_NULL),
    //     key=prop_cfg.GS_KEY_FUNDING_TYPE,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:90
    // key=prop_cfg.GS_KEY_REQUESTED_AMOUNT,
    bytec 21 // 0x7265717565737465645f616d6f756e74
    // smart_contracts/proposal/contract.py:89
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:88-91
    // self.requested_amount = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_REQUESTED_AMOUNT,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:94
    // key=prop_cfg.GS_KEY_LOCKED_AMOUNT,
    bytec 5 // 0x6c6f636b65645f616d6f756e74
    // smart_contracts/proposal/contract.py:93
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:92-95
    // self.locked_amount = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_LOCKED_AMOUNT,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:98
    // key=prop_cfg.GS_KEY_COMMITTEE_ID,
    bytec 22 // 0x636f6d6d69747465655f6964
    // smart_contracts/proposal/contract.py:97
    // typ.CommitteeId.from_bytes(b""),
    bytec_3 // 0x
    // smart_contracts/proposal/contract.py:96-99
    // self.committee_id = GlobalState(
    //     typ.CommitteeId.from_bytes(b""),
    //     key=prop_cfg.GS_KEY_COMMITTEE_ID,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:102
    // key=prop_cfg.GS_KEY_COMMITTEE_MEMBERS,
    bytec 6 // 0x636f6d6d69747465655f6d656d62657273
    // smart_contracts/proposal/contract.py:101
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:100-103
    // self.committee_members = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_COMMITTEE_MEMBERS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:106
    // key=prop_cfg.GS_KEY_COMMITTEE_VOTES,
    bytec 8 // 0x636f6d6d69747465655f766f746573
    // smart_contracts/proposal/contract.py:105
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:104-107
    // self.committee_votes = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_COMMITTEE_VOTES,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:110
    // key=prop_cfg.GS_KEY_VOTED_MEMBERS,
    bytec 9 // 0x766f7465645f6d656d62657273
    // smart_contracts/proposal/contract.py:109
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:108-111
    // self.voted_members = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_VOTED_MEMBERS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:114
    // key=prop_cfg.GS_KEY_APPROVALS,
    bytec 10 // 0x617070726f76616c73
    // smart_contracts/proposal/contract.py:113
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:112-115
    // self.approvals = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_APPROVALS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:118
    // key=prop_cfg.GS_KEY_REJECTIONS,
    bytec 11 // 0x72656a656374696f6e73
    // smart_contracts/proposal/contract.py:117
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:116-119
    // self.rejections = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_REJECTIONS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:122
    // key=prop_cfg.GS_KEY_NULLS,
    bytec 15 // 0x6e756c6c73
    // smart_contracts/proposal/contract.py:121
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:120-123
    // self.nulls = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_NULLS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:126
    // key=prop_cfg.GS_KEY_MILESTONE_APPROVED,
    pushbytes 0x6d696c6573746f6e655f617070726f766564
    // smart_contracts/proposal/contract.py:125
    // False,  # noqa: FBT003
    intc_0 // 0
    // smart_contracts/proposal/contract.py:124-127
    // self.milestone_approved = GlobalState(
    //     False,  # noqa: FBT003
    //     key=prop_cfg.GS_KEY_MILESTONE_APPROVED,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:132
    // self.voters_count = UInt64(0)
    bytec 16 // "voters_count"
    intc_0 // 0
    app_global_put
    // smart_contracts/proposal/contract.py:133
    // self.assigned_votes = UInt64(0)
    bytec 17 // "assigned_votes"
    intc_0 // 0
    app_global_put
    retsub


// smart_contracts.proposal.contract.Proposal.__puya_arc4_router__() -> uint64:
__puya_arc4_router__:
    // smart_contracts/proposal/contract.py:30-38
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    proto 0 1
    txn NumAppArgs
    bz __puya_arc4_router___after_if_else@13
    pushbytess 0xcc694eaa 0x6ecbb813 0x43f37dfa 0x5fcdfdee 0x23d8b7ce 0x74e6557e 0x1841a0d2 0x734dbecc // method "create(address)void", method "submit(pay,string,byte[59],uint64,uint64)void", method "update(string,byte[59])void", method "drop()void", method "finalize()void", method "assign_voter(address,uint64)void", method "vote(address,uint64,uint64)string", method "scrutiny()void"
    txna ApplicationArgs 0
    match __puya_arc4_router___create_route@2 __puya_arc4_router___submit_route@3 __puya_arc4_router___update_route@4 __puya_arc4_router___drop_route@5 __puya_arc4_router___finalize_route@6 __puya_arc4_router___assign_voter_route@7 __puya_arc4_router___vote_route@8 __puya_arc4_router___scrutiny_route@9
    intc_0 // 0
    retsub

__puya_arc4_router___create_route@2:
    // smart_contracts/proposal/contract.py:444
    // @arc4.abimethod(create="require")
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/proposal/contract.py:30-38
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/proposal/contract.py:444
    // @arc4.abimethod(create="require")
    callsub create
    intc_1 // 1
    retsub

__puya_arc4_router___submit_route@3:
    // smart_contracts/proposal/contract.py:458
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:30-38
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    // smart_contracts/proposal/contract.py:458
    // @arc4.abimethod()
    callsub submit
    intc_1 // 1
    retsub

__puya_arc4_router___update_route@4:
    // smart_contracts/proposal/contract.py:504
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:30-38
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    // smart_contracts/proposal/contract.py:504
    // @arc4.abimethod()
    callsub update
    intc_1 // 1
    retsub

__puya_arc4_router___drop_route@5:
    // smart_contracts/proposal/contract.py:526
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub drop
    intc_1 // 1
    retsub

__puya_arc4_router___finalize_route@6:
    // smart_contracts/proposal/contract.py:553
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub finalize
    intc_1 // 1
    retsub

__puya_arc4_router___assign_voter_route@7:
    // smart_contracts/proposal/contract.py:594
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:30-38
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/proposal/contract.py:594
    // @arc4.abimethod()
    callsub assign_voter
    intc_1 // 1
    retsub

__puya_arc4_router___vote_route@8:
    // smart_contracts/proposal/contract.py:630
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:30-38
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/proposal/contract.py:630
    // @arc4.abimethod()
    callsub vote
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    retsub

__puya_arc4_router___scrutiny_route@9:
    // smart_contracts/proposal/contract.py:675
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub scrutiny
    intc_1 // 1
    retsub

__puya_arc4_router___after_if_else@13:
    // smart_contracts/proposal/contract.py:30-38
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    intc_0 // 0
    retsub


// smart_contracts.proposal.contract.Proposal.create(proposer: bytes) -> void:
create:
    // smart_contracts/proposal/contract.py:444-445
    // @arc4.abimethod(create="require")
    // def create(self, proposer: arc4.Address) -> None:
    proto 1 0
    // smart_contracts/proposal/contract.py:452
    // Global.caller_application_id != 0
    global CallerApplicationID
    // smart_contracts/proposal/contract.py:451-453
    // assert (
    //     Global.caller_application_id != 0
    // ), err.UNAUTHORIZED  # Only callable by another contract
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:455
    // self.proposer.value = proposer
    bytec 4 // 0x70726f706f736572
    frame_dig -1
    app_global_put
    // smart_contracts/proposal/contract.py:456
    // self.registry_app_id.value = Global.caller_application_id
    bytec 7 // 0x72656769737472795f6170705f6964
    global CallerApplicationID
    app_global_put
    retsub


// smart_contracts.proposal.contract.Proposal.submit(payment: uint64, title: bytes, cid: bytes, funding_type: uint64, requested_amount: uint64) -> void:
submit:
    // smart_contracts/proposal/contract.py:458-466
    // @arc4.abimethod()
    // def submit(
    //     self,
    //     payment: gtxn.PaymentTransaction,
    //     title: String,
    //     cid: typ.Cid,
    //     funding_type: UInt64,
    //     requested_amount: UInt64,
    // ) -> None:
    proto 5 0
    // smart_contracts/proposal/contract.py:490
    // self.submit_check_authorization()
    callsub submit_check_authorization
    // smart_contracts/proposal/contract.py:492
    // self.submit_input_validation(title, cid, funding_type, requested_amount)
    frame_dig -4
    frame_dig -3
    frame_dig -2
    frame_dig -1
    callsub submit_input_validation
    frame_bury -3
    // smart_contracts/proposal/contract.py:493
    // self.submit_payment_validation(payment, requested_amount)
    frame_dig -5
    frame_dig -1
    callsub submit_payment_validation
    // smart_contracts/proposal/contract.py:495
    // self.title.value = title
    bytec 12 // 0x7469746c65
    frame_dig -4
    app_global_put
    // smart_contracts/proposal/contract.py:496
    // self.cid.value = cid.copy()
    bytec 13 // 0x636964
    frame_dig -3
    app_global_put
    // smart_contracts/proposal/contract.py:497
    // self.set_category(requested_amount)
    frame_dig -1
    callsub set_category
    // smart_contracts/proposal/contract.py:498
    // self.funding_type.value = funding_type
    bytec 20 // 0x66756e64696e675f74797065
    frame_dig -2
    app_global_put
    // smart_contracts/proposal/contract.py:499
    // self.requested_amount.value = requested_amount
    bytec 21 // 0x7265717565737465645f616d6f756e74
    frame_dig -1
    app_global_put
    // smart_contracts/proposal/contract.py:500
    // self.locked_amount.value = self.get_expected_locked_amount(requested_amount)
    frame_dig -1
    callsub get_expected_locked_amount
    bytec 5 // 0x6c6f636b65645f616d6f756e74
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:501
    // self.submission_ts.value = Global.latest_timestamp
    bytec 14 // 0x7375626d697373696f6e5f74696d657374616d70
    global LatestTimestamp
    app_global_put
    // smart_contracts/proposal/contract.py:502
    // self.status.value = UInt64(enm.STATUS_DRAFT)
    bytec_1 // 0x737461747573
    intc_2 // 10
    app_global_put
    retsub


// smart_contracts.proposal.contract.Proposal.submit_check_authorization() -> void:
submit_check_authorization:
    // smart_contracts/proposal/contract.py:320-321
    // @subroutine
    // def submit_check_authorization(self) -> None:
    proto 0 0
    // smart_contracts/proposal/contract.py:322
    // assert self.is_proposer(), err.UNAUTHORIZED
    callsub is_proposer
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:323
    // assert self.status.value == enm.STATUS_EMPTY, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    !
    assert // Wrong Proposal Status
    retsub


// smart_contracts.proposal.contract.Proposal.is_proposer() -> uint64:
is_proposer:
    // smart_contracts/proposal/contract.py:428-429
    // @subroutine
    // def is_proposer(self) -> bool:
    proto 0 1
    // smart_contracts/proposal/contract.py:430
    // return Txn.sender == self.proposer.value
    intc_0 // 0
    bytec 4 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    txn Sender
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.submit_input_validation(title: bytes, cid: bytes, funding_type: uint64, requested_amount: uint64) -> bytes:
submit_input_validation:
    // smart_contracts/proposal/contract.py:325-332
    // @subroutine
    // def submit_input_validation(
    //     self,
    //     title: String,
    //     cid: typ.Cid,
    //     funding_type: UInt64,
    //     requested_amount: UInt64,
    // ) -> None:
    proto 4 1
    // smart_contracts/proposal/contract.py:334
    // self.updateable_input_validation(title, cid)
    frame_dig -4
    frame_dig -3
    callsub updateable_input_validation
    frame_bury -3
    // smart_contracts/proposal/contract.py:337
    // funding_type == enm.FUNDING_PROACTIVE
    frame_dig -2
    intc_2 // 10
    ==
    // smart_contracts/proposal/contract.py:337-338
    // funding_type == enm.FUNDING_PROACTIVE
    // or funding_type == enm.FUNDING_RETROACTIVE
    bnz submit_input_validation_bool_true@4
    // smart_contracts/proposal/contract.py:338
    // or funding_type == enm.FUNDING_RETROACTIVE
    frame_dig -2
    intc_3 // 20
    ==
    // smart_contracts/proposal/contract.py:337-338
    // funding_type == enm.FUNDING_PROACTIVE
    // or funding_type == enm.FUNDING_RETROACTIVE
    bz submit_input_validation_bool_false@5

submit_input_validation_bool_true@4:
    intc_1 // 1
    b submit_input_validation_bool_merge@6

submit_input_validation_bool_false@5:
    intc_0 // 0

submit_input_validation_bool_merge@6:
    // smart_contracts/proposal/contract.py:336-339
    // assert (
    //     funding_type == enm.FUNDING_PROACTIVE
    //     or funding_type == enm.FUNDING_RETROACTIVE
    // ), err.WRONG_FUNDING_TYPE
    assert // Wrong Funding Type
    // smart_contracts/proposal/contract.py:342
    // Bytes(reg_cfg.GS_KEY_MIN_REQUESTED_AMOUNT)
    pushbytes 0x6d696e5f7265717565737465645f616d6f756e74
    // smart_contracts/proposal/contract.py:341-343
    // min_requested_amount, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MIN_REQUESTED_AMOUNT)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:344
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:347
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_LARGE)
    pushbytes 0x6d61785f7265717565737465645f616d6f756e745f6c61726765
    // smart_contracts/proposal/contract.py:346-348
    // max_requested_amount_large, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_LARGE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:349
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:351
    // assert requested_amount >= min_requested_amount, err.WRONG_MIN_REQUESTED_AMOUNT
    frame_dig -1
    uncover 2
    >=
    assert // Requested amount is less than the minimum requested amount
    // smart_contracts/proposal/contract.py:353
    // requested_amount <= max_requested_amount_large
    frame_dig -1
    >=
    // smart_contracts/proposal/contract.py:352-354
    // assert (
    //     requested_amount <= max_requested_amount_large
    // ), err.WRONG_MAX_REQUESTED_AMOUNT
    assert // Requested amount is more than the maximum requested amount
    frame_dig -3
    retsub


// smart_contracts.proposal.contract.Proposal.updateable_input_validation(title: bytes, cid: bytes) -> bytes:
updateable_input_validation:
    // smart_contracts/proposal/contract.py:307-308
    // @subroutine
    // def updateable_input_validation(self, title: String, cid: typ.Cid) -> None:
    proto 2 1
    // smart_contracts/proposal/contract.py:309
    // assert title.bytes.length <= const.TITLE_MAX_BYTES, err.WRONG_TITLE_LENGTH
    frame_dig -2
    len
    pushint 123 // 123
    <=
    assert // Wrong Title length
    // smart_contracts/proposal/contract.py:310
    // assert title != "", err.WRONG_TITLE_LENGTH
    frame_dig -2
    bytec_3 // ""
    !=
    assert // Wrong Title length
    frame_dig -1
    retsub


// smart_contracts.proposal.contract.Proposal.get_uint_from_registry_config(global_state_key: bytes) -> uint64, bytes:
get_uint_from_registry_config:
    // smart_contracts/proposal/contract.py:404-407
    // @subroutine
    // def get_uint_from_registry_config(
    //     self, global_state_key: Bytes
    // ) -> tuple[UInt64, typ.Error]:
    proto 1 2
    // smart_contracts/proposal/contract.py:409
    // self.registry_app_id.value, global_state_key
    intc_0 // 0
    bytec 7 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:408-410
    // value, exists = AppGlobal.get_ex_uint64(
    //     self.registry_app_id.value, global_state_key
    // )
    frame_dig -1
    app_global_get_ex
    // smart_contracts/proposal/contract.py:411
    // error = typ.Error("")
    bytec_0 // 0x0000
    swap
    // smart_contracts/proposal/contract.py:412
    // if not exists:
    bnz get_uint_from_registry_config_after_if_else@2
    // smart_contracts/proposal/contract.py:413
    // error = typ.Error("ERR:" + err.MISSING_CONFIG)
    pushbytes 0x00124552523a4d697373696e6720436f6e666967
    frame_bury 1

get_uint_from_registry_config_after_if_else@2:
    // smart_contracts/proposal/contract.py:414
    // return value, error
    frame_dig 0
    frame_dig 1
    uncover 3
    uncover 3
    retsub


// smart_contracts.proposal.contract.Proposal.submit_payment_validation(payment: uint64, requested_amount: uint64) -> void:
submit_payment_validation:
    // smart_contracts/proposal/contract.py:373-376
    // @subroutine
    // def submit_payment_validation(
    //     self, payment: gtxn.PaymentTransaction, requested_amount: UInt64
    // ) -> None:
    proto 2 0
    // smart_contracts/proposal/contract.py:377
    // expected_lock_amount = self.get_expected_locked_amount(requested_amount)
    frame_dig -1
    callsub get_expected_locked_amount
    // smart_contracts/proposal/contract.py:379
    // assert payment.sender == self.proposer.value, err.WRONG_SENDER
    intc_0 // 0
    bytec 4 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    frame_dig -2
    gtxns Sender
    ==
    assert // Wrong Sender
    // smart_contracts/proposal/contract.py:381
    // payment.receiver == Global.current_application_address
    frame_dig -2
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/proposal/contract.py:380-382
    // assert (
    //     payment.receiver == Global.current_application_address
    // ), err.WRONG_RECEIVER
    assert // Wrong Receiver
    // smart_contracts/proposal/contract.py:383
    // assert payment.amount == expected_lock_amount, err.WRONG_LOCKED_AMOUNT
    frame_dig -2
    gtxns Amount
    ==
    assert // Locked amount is incorrect
    retsub


// smart_contracts.proposal.contract.Proposal.get_expected_locked_amount(requested_amount: uint64) -> uint64:
get_expected_locked_amount:
    // smart_contracts/proposal/contract.py:362-363
    // @subroutine
    // def get_expected_locked_amount(self, requested_amount: UInt64) -> UInt64:
    proto 1 1
    // smart_contracts/proposal/contract.py:365
    // Bytes(reg_cfg.GS_KEY_PROPOSAL_COMMITMENT_BPS)
    pushbytes 0x70726f706f73616c5f636f6d6d69746d656e745f627073
    // smart_contracts/proposal/contract.py:364-366
    // proposal_commitment_bps, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PROPOSAL_COMMITMENT_BPS)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:367
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:368-371
    // return self.relative_to_absolute_amount(
    //     requested_amount,
    //     proposal_commitment_bps,
    // )
    frame_dig -1
    swap
    callsub relative_to_absolute_amount
    retsub


// smart_contracts.proposal.contract.Proposal.relative_to_absolute_amount(amount: uint64, fraction_in_bps: uint64) -> uint64:
relative_to_absolute_amount:
    // smart_contracts/proposal/contract.py:356-359
    // @subroutine
    // def relative_to_absolute_amount(
    //     self, amount: UInt64, fraction_in_bps: UInt64
    // ) -> UInt64:
    proto 2 1
    // smart_contracts/proposal/contract.py:360
    // return amount * fraction_in_bps // const.BPS
    frame_dig -2
    frame_dig -1
    *
    pushint 10000 // 10000
    /
    retsub


// smart_contracts.proposal.contract.Proposal.set_category(requested_amount: uint64) -> void:
set_category:
    // smart_contracts/proposal/contract.py:385-386
    // @subroutine
    // def set_category(self, requested_amount: UInt64) -> None:
    proto 1 0
    // smart_contracts/proposal/contract.py:388
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_SMALL)
    pushbytes 0x6d61785f7265717565737465645f616d6f756e745f736d616c6c
    // smart_contracts/proposal/contract.py:387-389
    // max_requested_amount_small, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_SMALL)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:390
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:393
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_MEDIUM)
    pushbytes 0x6d61785f7265717565737465645f616d6f756e745f6d656469756d
    // smart_contracts/proposal/contract.py:392-394
    // max_requested_amount_medium, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    swap
    cover 2
    // smart_contracts/proposal/contract.py:395
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:397
    // if requested_amount <= max_requested_amount_small:
    frame_dig -1
    >=
    bz set_category_else_body@2
    // smart_contracts/proposal/contract.py:398
    // self.category.value = UInt64(enm.CATEGORY_SMALL)
    bytec_2 // 0x63617465676f7279
    intc_2 // 10
    app_global_put
    b set_category_after_if_else@6

set_category_else_body@2:
    // smart_contracts/proposal/contract.py:399
    // elif requested_amount <= max_requested_amount_medium:
    frame_dig -1
    frame_dig 0
    <=
    bz set_category_else_body@4
    // smart_contracts/proposal/contract.py:400
    // self.category.value = UInt64(enm.CATEGORY_MEDIUM)
    bytec_2 // 0x63617465676f7279
    intc_3 // 20
    app_global_put
    b set_category_after_if_else@6

set_category_else_body@4:
    // smart_contracts/proposal/contract.py:402
    // self.category.value = UInt64(enm.CATEGORY_LARGE)
    bytec_2 // 0x63617465676f7279
    pushint 33 // 33
    app_global_put

set_category_after_if_else@6:
    retsub


// smart_contracts.proposal.contract.Proposal.update(title: bytes, cid: bytes) -> void:
update:
    // smart_contracts/proposal/contract.py:504-505
    // @arc4.abimethod()
    // def update(self, title: String, cid: typ.Cid) -> None:
    proto 2 0
    // smart_contracts/proposal/contract.py:519
    // self.update_check_authorization()
    callsub update_check_authorization
    // smart_contracts/proposal/contract.py:521
    // self.updateable_input_validation(title, cid)
    frame_dig -2
    frame_dig -1
    callsub updateable_input_validation
    frame_bury -1
    // smart_contracts/proposal/contract.py:523
    // self.title.value = title
    bytec 12 // 0x7469746c65
    frame_dig -2
    app_global_put
    // smart_contracts/proposal/contract.py:524
    // self.cid.value = cid.copy()
    bytec 13 // 0x636964
    frame_dig -1
    app_global_put
    retsub


// smart_contracts.proposal.contract.Proposal.update_check_authorization() -> void:
update_check_authorization:
    // smart_contracts/proposal/contract.py:315-316
    // @subroutine
    // def update_check_authorization(self) -> None:
    proto 0 0
    // smart_contracts/proposal/contract.py:317
    // assert self.is_proposer(), err.UNAUTHORIZED
    callsub is_proposer
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:318
    // assert self.status.value == enm.STATUS_DRAFT, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_2 // 10
    ==
    assert // Wrong Proposal Status
    retsub


// smart_contracts.proposal.contract.Proposal.drop() -> void:
drop:
    // smart_contracts/proposal/contract.py:526-527
    // @arc4.abimethod()
    // def drop(self) -> None:
    proto 0 0
    // smart_contracts/proposal/contract.py:535
    // self.drop_check_authorization()
    callsub drop_check_authorization
    // smart_contracts/proposal/contract.py:537-541
    // itxn.Payment(
    //     receiver=self.proposer.value.native,
    //     amount=self.locked_amount.value,
    //     fee=UInt64(0),  # enforces the proposer to pay the fee
    // ).submit()
    itxn_begin
    // smart_contracts/proposal/contract.py:538
    // receiver=self.proposer.value.native,
    intc_0 // 0
    bytec 4 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:539
    // amount=self.locked_amount.value,
    intc_0 // 0
    bytec 5 // 0x6c6f636b65645f616d6f756e74
    app_global_get_ex
    assert // check self.locked_amount exists
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/proposal/contract.py:537
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/proposal/contract.py:540
    // fee=UInt64(0),  # enforces the proposer to pay the fee
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/proposal/contract.py:537-541
    // itxn.Payment(
    //     receiver=self.proposer.value.native,
    //     amount=self.locked_amount.value,
    //     fee=UInt64(0),  # enforces the proposer to pay the fee
    // ).submit()
    itxn_submit
    // smart_contracts/proposal/contract.py:543-544
    // #  Clear the proposal data TODO: check if this can be in a struct and clear the struct
    // self.title.value = String()
    bytec 12 // 0x7469746c65
    bytec_3 // ""
    app_global_put
    // smart_contracts/proposal/contract.py:545
    // self.cid.value = typ.Cid.from_bytes(b"")
    bytec 13 // 0x636964
    bytec_3 // 0x
    app_global_put
    // smart_contracts/proposal/contract.py:546
    // self.category.value = UInt64(enm.CATEGORY_NULL)
    bytec_2 // 0x63617465676f7279
    intc_0 // 0
    app_global_put
    // smart_contracts/proposal/contract.py:547
    // self.funding_type.value = UInt64(enm.FUNDING_NULL)
    bytec 20 // 0x66756e64696e675f74797065
    intc_0 // 0
    app_global_put
    // smart_contracts/proposal/contract.py:548
    // self.requested_amount.value = UInt64(0)
    bytec 21 // 0x7265717565737465645f616d6f756e74
    intc_0 // 0
    app_global_put
    // smart_contracts/proposal/contract.py:549
    // self.locked_amount.value = UInt64(0)
    bytec 5 // 0x6c6f636b65645f616d6f756e74
    intc_0 // 0
    app_global_put
    // smart_contracts/proposal/contract.py:550
    // self.submission_ts.value = UInt64(0)
    bytec 14 // 0x7375626d697373696f6e5f74696d657374616d70
    intc_0 // 0
    app_global_put
    // smart_contracts/proposal/contract.py:551
    // self.status.value = UInt64(enm.STATUS_EMPTY)
    bytec_1 // 0x737461747573
    intc_0 // 0
    app_global_put
    retsub


// smart_contracts.proposal.contract.Proposal.drop_check_authorization() -> void:
drop_check_authorization:
    // smart_contracts/proposal/contract.py:302-303
    // @subroutine
    // def drop_check_authorization(self) -> None:
    proto 0 0
    // smart_contracts/proposal/contract.py:304
    // assert self.is_proposer(), err.UNAUTHORIZED
    callsub is_proposer
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:305
    // assert self.status.value == enm.STATUS_DRAFT, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_2 // 10
    ==
    assert // Wrong Proposal Status
    retsub


// smart_contracts.proposal.contract.Proposal.finalize() -> void:
finalize:
    // smart_contracts/proposal/contract.py:553-554
    // @arc4.abimethod()
    // def finalize(self) -> None:
    proto 0 0
    // smart_contracts/proposal/contract.py:567
    // self.finalize_check_authorization()
    callsub finalize_check_authorization
    // smart_contracts/proposal/contract.py:569
    // self.verify_and_set_committee()
    callsub verify_and_set_committee
    // smart_contracts/proposal/contract.py:571
    // self.status.value = UInt64(enm.STATUS_FINAL)
    bytec_1 // 0x737461747573
    intc_3 // 20
    app_global_put
    // smart_contracts/proposal/contract.py:572
    // self.finalization_ts.value = Global.latest_timestamp
    bytec 24 // 0x66696e616c697a6174696f6e5f74696d657374616d70
    global LatestTimestamp
    app_global_put
    // smart_contracts/proposal/contract.py:575
    // Bytes(reg_cfg.GS_KEY_PROPOSAL_FEE)
    pushbytes 0x70726f706f73616c5f666565
    // smart_contracts/proposal/contract.py:574-576
    // proposal_fee, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PROPOSAL_FEE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:577
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:580
    // Bytes(reg_cfg.GS_KEY_PROPOSAL_PUBLISHING_BPS)
    pushbytes 0x70726f706f73616c5f7075626c697368696e675f627073
    // smart_contracts/proposal/contract.py:579-581
    // publishing_fee_bps, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PROPOSAL_PUBLISHING_BPS)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:582
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:584-592
    // itxn.Payment(
    //     receiver=Account(
    //         self.get_bytes_from_registry_config(
    //             Bytes(reg_cfg.GS_KEY_COMMITTEE_PUBLISHER)
    //         )
    //     ),
    //     amount=self.relative_to_absolute_amount(proposal_fee, publishing_fee_bps),
    //     fee=UInt64(0),  # enforces the proposer to pay the fee
    // ).submit()
    itxn_begin
    // smart_contracts/proposal/contract.py:587
    // Bytes(reg_cfg.GS_KEY_COMMITTEE_PUBLISHER)
    bytec 25 // 0x636f6d6d69747465655f7075626c6973686572
    // smart_contracts/proposal/contract.py:586-588
    // self.get_bytes_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COMMITTEE_PUBLISHER)
    // )
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:585-589
    // receiver=Account(
    //     self.get_bytes_from_registry_config(
    //         Bytes(reg_cfg.GS_KEY_COMMITTEE_PUBLISHER)
    //     )
    // ),
    dup
    len
    pushint 32 // 32
    ==
    assert // Address length is 32 bytes
    // smart_contracts/proposal/contract.py:590
    // amount=self.relative_to_absolute_amount(proposal_fee, publishing_fee_bps),
    cover 2
    callsub relative_to_absolute_amount
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/proposal/contract.py:584
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/proposal/contract.py:591
    // fee=UInt64(0),  # enforces the proposer to pay the fee
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/proposal/contract.py:584-592
    // itxn.Payment(
    //     receiver=Account(
    //         self.get_bytes_from_registry_config(
    //             Bytes(reg_cfg.GS_KEY_COMMITTEE_PUBLISHER)
    //         )
    //     ),
    //     amount=self.relative_to_absolute_amount(proposal_fee, publishing_fee_bps),
    //     fee=UInt64(0),  # enforces the proposer to pay the fee
    // ).submit()
    itxn_submit
    retsub


// smart_contracts.proposal.contract.Proposal.finalize_check_authorization() -> void:
finalize_check_authorization:
    // smart_contracts/proposal/contract.py:291-292
    // @subroutine
    // def finalize_check_authorization(self) -> None:
    proto 0 0
    // smart_contracts/proposal/contract.py:294
    // assert self.is_proposer(), err.UNAUTHORIZED
    callsub is_proposer
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:295
    // assert self.status.value == enm.STATUS_DRAFT, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_2 // 10
    ==
    assert // Wrong Proposal Status
    // smart_contracts/proposal/contract.py:297
    // discussion_duration = Global.latest_timestamp - self.submission_ts.value
    global LatestTimestamp
    intc_0 // 0
    bytec 14 // 0x7375626d697373696f6e5f74696d657374616d70
    app_global_get_ex
    assert // check self.submission_ts exists
    -
    // smart_contracts/proposal/contract.py:298
    // minimum_discussion_duration = self.get_discussion_duration(self.category.value)
    intc_0 // 0
    bytec_2 // 0x63617465676f7279
    app_global_get_ex
    assert // check self.category exists
    callsub get_discussion_duration
    // smart_contracts/proposal/contract.py:300
    // assert discussion_duration >= minimum_discussion_duration, err.TOO_EARLY
    >=
    assert // Too early
    retsub


// smart_contracts.proposal.contract.Proposal.get_discussion_duration(category: uint64) -> uint64:
get_discussion_duration:
    // smart_contracts/proposal/contract.py:201-202
    // @subroutine
    // def get_discussion_duration(self, category: UInt64) -> UInt64:
    proto 1 1
    intc_0 // 0
    // smart_contracts/proposal/contract.py:203
    // if category == enm.CATEGORY_SMALL:
    frame_dig -1
    intc_2 // 10
    ==
    bz get_discussion_duration_else_body@2
    // smart_contracts/proposal/contract.py:205
    // Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_SMALL)
    pushbytes 0x64697363757373696f6e5f6475726174696f6e5f736d616c6c
    // smart_contracts/proposal/contract.py:204-206
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_SMALL)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b get_discussion_duration_after_if_else@6

get_discussion_duration_else_body@2:
    // smart_contracts/proposal/contract.py:207
    // elif category == enm.CATEGORY_MEDIUM:
    frame_dig -1
    intc_3 // 20
    ==
    bz get_discussion_duration_else_body@4
    // smart_contracts/proposal/contract.py:209
    // Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_MEDIUM)
    pushbytes 0x64697363757373696f6e5f6475726174696f6e5f6d656469756d
    // smart_contracts/proposal/contract.py:208-210
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b get_discussion_duration_after_if_else@6

get_discussion_duration_else_body@4:
    // smart_contracts/proposal/contract.py:213
    // Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_LARGE)
    pushbytes 0x64697363757373696f6e5f6475726174696f6e5f6c61726765
    // smart_contracts/proposal/contract.py:212-214
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_LARGE)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0

get_discussion_duration_after_if_else@6:
    // smart_contracts/proposal/contract.py:215
    // assert error == typ.Error(""), err.MISSING_CONFIG
    frame_dig 0
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:216
    // return value
    swap
    retsub


// smart_contracts.proposal.contract.Proposal.verify_and_set_committee() -> void:
verify_and_set_committee:
    // smart_contracts/proposal/contract.py:267-268
    // @subroutine
    // def verify_and_set_committee(self) -> None:
    proto 0 0
    // smart_contracts/proposal/contract.py:271
    // self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_COMMITTEE_ID))
    bytec 22 // 0x636f6d6d69747465655f6964
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:273
    // assert committee_id != typ.CommitteeId.from_bytes(b""), err.EMPTY_COMMITTEE_ID
    dup
    bytec_3 // 0x
    !=
    assert // Empty Committee ID
    // smart_contracts/proposal/contract.py:276
    // Bytes(reg_cfg.GS_KEY_COMMITTEE_MEMBERS)
    bytec 6 // 0x636f6d6d69747465655f6d656d62657273
    // smart_contracts/proposal/contract.py:275-277
    // committee_members, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COMMITTEE_MEMBERS)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:278
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:279
    // assert committee_members > UInt64(0), err.WRONG_COMMITTEE_MEMBERS
    dup
    assert // Wrong Committee Members
    // smart_contracts/proposal/contract.py:282
    // Bytes(reg_cfg.GS_KEY_COMMITTEE_VOTES)
    bytec 8 // 0x636f6d6d69747465655f766f746573
    // smart_contracts/proposal/contract.py:281-283
    // committee_votes, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COMMITTEE_VOTES)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:284
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:285
    // assert committee_votes > UInt64(0), err.WRONG_COMMITTEE_VOTES
    dup
    assert // Wrong Committee Votes
    // smart_contracts/proposal/contract.py:287
    // self.committee_id.value = committee_id.copy()
    bytec 22 // 0x636f6d6d69747465655f6964
    uncover 3
    app_global_put
    // smart_contracts/proposal/contract.py:288
    // self.committee_members.value = committee_members
    bytec 6 // 0x636f6d6d69747465655f6d656d62657273
    uncover 2
    app_global_put
    // smart_contracts/proposal/contract.py:289
    // self.committee_votes.value = committee_votes
    bytec 8 // 0x636f6d6d69747465655f766f746573
    swap
    app_global_put
    retsub


// smart_contracts.proposal.contract.Proposal.get_bytes_from_registry_config(global_state_key: bytes) -> bytes:
get_bytes_from_registry_config:
    // smart_contracts/proposal/contract.py:416-417
    // @subroutine
    // def get_bytes_from_registry_config(self, global_state_key: Bytes) -> Bytes:
    proto 1 1
    // smart_contracts/proposal/contract.py:419
    // self.registry_app_id.value, global_state_key
    intc_0 // 0
    bytec 7 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:418-420
    // value, exists = AppGlobal.get_ex_bytes(
    //     self.registry_app_id.value, global_state_key
    // )
    frame_dig -1
    app_global_get_ex
    // smart_contracts/proposal/contract.py:421
    // assert exists, err.MISSING_CONFIG
    assert // Missing Config
    // smart_contracts/proposal/contract.py:422
    // return value
    retsub


// smart_contracts.proposal.contract.Proposal.assign_voter(voter: bytes, voting_power: uint64) -> void:
assign_voter:
    // smart_contracts/proposal/contract.py:594-595
    // @arc4.abimethod()
    // def assign_voter(self, voter: arc4.Address, voting_power: UInt64) -> None:
    proto 2 0
    // smart_contracts/proposal/contract.py:611
    // self.assign_voter_check_authorization()
    callsub assign_voter_check_authorization
    // smart_contracts/proposal/contract.py:613
    // self.assign_voter_input_validation(voter, voting_power)
    frame_dig -2
    frame_dig -1
    callsub assign_voter_input_validation
    // smart_contracts/proposal/contract.py:616
    // votes=arc4.UInt64(voting_power),
    frame_dig -1
    itob
    // smart_contracts/proposal/contract.py:617
    // voted=arc4.Bool(False),  # noqa: FBT003
    bytec 23 // 0x00
    // smart_contracts/proposal/contract.py:615-618
    // self.voters[voter.native] = typ.VoterBox(
    //     votes=arc4.UInt64(voting_power),
    //     voted=arc4.Bool(False),  # noqa: FBT003
    // )
    concat
    // smart_contracts/proposal/contract.py:615
    // self.voters[voter.native] = typ.VoterBox(
    bytec 18 // "V"
    frame_dig -2
    concat
    // smart_contracts/proposal/contract.py:615-618
    // self.voters[voter.native] = typ.VoterBox(
    //     votes=arc4.UInt64(voting_power),
    //     voted=arc4.Bool(False),  # noqa: FBT003
    // )
    swap
    box_put
    // smart_contracts/proposal/contract.py:620
    // self.voters_count += UInt64(1)
    intc_0 // 0
    bytec 16 // "voters_count"
    app_global_get_ex
    assert // check self.voters_count exists
    intc_1 // 1
    +
    bytec 16 // "voters_count"
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:621
    // self.assigned_votes += voting_power
    intc_0 // 0
    bytec 17 // "assigned_votes"
    app_global_get_ex
    assert // check self.assigned_votes exists
    frame_dig -1
    +
    bytec 17 // "assigned_votes"
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:623
    // if self.voters_count == self.committee_members.value:
    intc_0 // 0
    bytec 16 // "voters_count"
    app_global_get_ex
    assert // check self.voters_count exists
    intc_0 // 0
    bytec 6 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    ==
    bz assign_voter_after_if_else@2
    // smart_contracts/proposal/contract.py:625
    // self.assigned_votes == self.committee_votes.value
    intc_0 // 0
    bytec 17 // "assigned_votes"
    app_global_get_ex
    assert // check self.assigned_votes exists
    intc_0 // 0
    bytec 8 // 0x636f6d6d69747465655f766f746573
    app_global_get_ex
    assert // check self.committee_votes exists
    ==
    // smart_contracts/proposal/contract.py:624-626
    // assert (
    //     self.assigned_votes == self.committee_votes.value
    // ), err.VOTING_POWER_MISMATCH
    assert // Voting Power Mismatch
    // smart_contracts/proposal/contract.py:627
    // self.status.value = UInt64(enm.STATUS_VOTING)
    bytec_1 // 0x737461747573
    pushint 25 // 25
    app_global_put
    // smart_contracts/proposal/contract.py:628
    // self.vote_open_ts.value = Global.latest_timestamp
    bytec 19 // 0x766f74655f6f70656e696e675f74696d657374616d70
    global LatestTimestamp
    app_global_put

assign_voter_after_if_else@2:
    retsub


// smart_contracts.proposal.contract.Proposal.assign_voter_check_authorization() -> void:
assign_voter_check_authorization:
    // smart_contracts/proposal/contract.py:189-190
    // @subroutine
    // def assign_voter_check_authorization(self) -> None:
    proto 0 0
    // smart_contracts/proposal/contract.py:191
    // assert self.is_committee_publisher(), err.UNAUTHORIZED
    callsub is_committee_publisher
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:192
    // assert self.status.value == enm.STATUS_FINAL, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_3 // 20
    ==
    assert // Wrong Proposal Status
    retsub


// smart_contracts.proposal.contract.Proposal.is_committee_publisher() -> uint64:
is_committee_publisher:
    // smart_contracts/proposal/contract.py:432-433
    // @subroutine
    // def is_committee_publisher(self) -> bool:
    proto 0 1
    // smart_contracts/proposal/contract.py:434
    // return Txn.sender == Account(
    txn Sender
    // smart_contracts/proposal/contract.py:436
    // Bytes(reg_cfg.GS_KEY_COMMITTEE_PUBLISHER)
    bytec 25 // 0x636f6d6d69747465655f7075626c6973686572
    // smart_contracts/proposal/contract.py:435-437
    // self.get_bytes_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COMMITTEE_PUBLISHER)
    // )
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:434-438
    // return Txn.sender == Account(
    //     self.get_bytes_from_registry_config(
    //         Bytes(reg_cfg.GS_KEY_COMMITTEE_PUBLISHER)
    //     )
    // )
    dup
    len
    pushint 32 // 32
    ==
    assert // Address length is 32 bytes
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.assign_voter_input_validation(voter: bytes, voting_power: uint64) -> void:
assign_voter_input_validation:
    // smart_contracts/proposal/contract.py:194-197
    // @subroutine
    // def assign_voter_input_validation(
    //     self, voter: arc4.Address, voting_power: UInt64
    // ) -> None:
    proto 2 0
    // smart_contracts/proposal/contract.py:198
    // assert voter.native not in self.voters, err.VOTER_ALREADY_ASSIGNED
    bytec 18 // "V"
    frame_dig -2
    concat
    box_len
    bury 1
    !
    assert // Voter Already Assigned
    // smart_contracts/proposal/contract.py:199
    // assert voting_power > 0, err.INVALID_VOTING_POWER
    frame_dig -1
    assert // Invalid Voting Power
    retsub


// smart_contracts.proposal.contract.Proposal.vote(voter: bytes, approvals: bytes, rejections: bytes) -> bytes:
vote:
    // smart_contracts/proposal/contract.py:630-633
    // @arc4.abimethod()
    // def vote(
    //     self, voter: arc4.Address, approvals: arc4.UInt64, rejections: arc4.UInt64
    // ) -> typ.Error:
    proto 3 1
    // smart_contracts/proposal/contract.py:651
    // error = self.vote_check_authorization()
    callsub vote_check_authorization
    dup
    // smart_contracts/proposal/contract.py:652
    // if error != typ.Error(""):
    bytec_0 // 0x0000
    !=
    bz vote_after_if_else@2
    // smart_contracts/proposal/contract.py:653
    // return error
    frame_dig 0
    swap
    retsub

vote_after_if_else@2:
    // smart_contracts/proposal/contract.py:655
    // error = self.vote_input_validation(voter, approvals, rejections)
    frame_dig -3
    frame_dig -2
    frame_dig -1
    callsub vote_input_validation
    dup
    frame_bury 0
    // smart_contracts/proposal/contract.py:656
    // if error != typ.Error(""):
    bytec_0 // 0x0000
    !=
    bz vote_after_if_else@4
    // smart_contracts/proposal/contract.py:657
    // return error
    frame_dig 0
    swap
    retsub

vote_after_if_else@4:
    // smart_contracts/proposal/contract.py:659
    // voter_box = self.voters[voter.native].copy()
    bytec 18 // "V"
    frame_dig -3
    concat
    dup
    box_get
    assert // check self.voters entry exists
    // smart_contracts/proposal/contract.py:661
    // votes=voter_box.votes,
    extract 0 8 // on error: Index access is out of bounds
    // smart_contracts/proposal/contract.py:660-663
    // self.voters[voter.native] = typ.VoterBox(
    //     votes=voter_box.votes,
    //     voted=arc4.Bool(True),  # noqa: FBT003
    // )
    dup
    // smart_contracts/proposal/contract.py:662
    // voted=arc4.Bool(True),  # noqa: FBT003
    pushbytes 0x80
    // smart_contracts/proposal/contract.py:660-663
    // self.voters[voter.native] = typ.VoterBox(
    //     votes=voter_box.votes,
    //     voted=arc4.Bool(True),  # noqa: FBT003
    // )
    concat
    uncover 2
    swap
    box_put
    // smart_contracts/proposal/contract.py:665
    // self.voted_members.value += UInt64(1)
    intc_0 // 0
    bytec 9 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    intc_1 // 1
    +
    bytec 9 // 0x766f7465645f6d656d62657273
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:667
    // nulls = voter_box.votes.native - approvals.native - rejections.native
    btoi
    frame_dig -2
    btoi
    swap
    dig 1
    -
    frame_dig -1
    btoi
    swap
    dig 1
    -
    // smart_contracts/proposal/contract.py:669
    // self.approvals.value += approvals.native
    intc_0 // 0
    bytec 10 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    uncover 3
    +
    bytec 10 // 0x617070726f76616c73
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:670
    // self.rejections.value += rejections.native
    intc_0 // 0
    bytec 11 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    uncover 2
    +
    bytec 11 // 0x72656a656374696f6e73
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:671
    // self.nulls.value += nulls
    intc_0 // 0
    bytec 15 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    +
    bytec 15 // 0x6e756c6c73
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:673
    // return typ.Error("")
    bytec_0 // 0x0000
    swap
    retsub


// smart_contracts.proposal.contract.Proposal.vote_check_authorization() -> bytes:
vote_check_authorization:
    // smart_contracts/proposal/contract.py:144-145
    // @subroutine
    // def vote_check_authorization(self) -> typ.Error:
    proto 0 1
    intc_0 // 0
    bytec_3 // ""
    // smart_contracts/proposal/contract.py:146
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:148
    // if self.status.value != enm.STATUS_VOTING:
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 25 // 25
    !=
    bz vote_check_authorization_after_if_else@2
    // smart_contracts/proposal/contract.py:149
    // return typ.Error("ERR:" + err.WRONG_PROPOSAL_STATUS)
    pushbytes 0x00194552523a57726f6e672050726f706f73616c20537461747573
    frame_bury 0
    retsub

vote_check_authorization_after_if_else@2:
    // smart_contracts/proposal/contract.py:151
    // is_voting_open, error = self.is_voting_open()
    callsub is_voting_open
    dup
    cover 2
    frame_bury 0
    frame_bury 1
    // smart_contracts/proposal/contract.py:152
    // if error != typ.Error(""):
    bytec_0 // 0x0000
    !=
    bz vote_check_authorization_after_if_else@4
    // smart_contracts/proposal/contract.py:153
    // return error
    retsub

vote_check_authorization_after_if_else@4:
    // smart_contracts/proposal/contract.py:155
    // if not is_voting_open:
    frame_dig 1
    bnz vote_check_authorization_after_if_else@6
    // smart_contracts/proposal/contract.py:156
    // return typ.Error("ERR:" + err.VOTING_PERIOD_EXPIRED)
    pushbytes 0x00194552523a566f74696e6720506572696f642045787069726564
    frame_bury 0
    retsub

vote_check_authorization_after_if_else@6:
    // smart_contracts/proposal/contract.py:158
    // return typ.Error("")
    bytec_0 // 0x0000
    frame_bury 0
    retsub


// smart_contracts.proposal.contract.Proposal.is_registry_call() -> uint64:
is_registry_call:
    // smart_contracts/proposal/contract.py:440-441
    // @subroutine
    // def is_registry_call(self) -> bool:
    proto 0 1
    // smart_contracts/proposal/contract.py:442
    // return Global.caller_application_id == self.registry_app_id.value
    global CallerApplicationID
    intc_0 // 0
    bytec 7 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.is_voting_open() -> uint64, bytes:
is_voting_open:
    // smart_contracts/proposal/contract.py:135-136
    // @subroutine
    // def is_voting_open(self) -> tuple[bool, typ.Error]:
    proto 0 2
    // smart_contracts/proposal/contract.py:137
    // voting_duration = Global.latest_timestamp - self.vote_open_ts.value
    global LatestTimestamp
    intc_0 // 0
    bytec 19 // 0x766f74655f6f70656e696e675f74696d657374616d70
    app_global_get_ex
    assert // check self.vote_open_ts exists
    -
    // smart_contracts/proposal/contract.py:138
    // maximum_voting_duration, error = self.get_voting_duration(self.category.value)
    intc_0 // 0
    bytec_2 // 0x63617465676f7279
    app_global_get_ex
    assert // check self.category exists
    callsub get_voting_duration
    dup
    uncover 2
    swap
    // smart_contracts/proposal/contract.py:139
    // if error != typ.Error(""):
    bytec_0 // 0x0000
    !=
    bz is_voting_open_after_if_else@2
    // smart_contracts/proposal/contract.py:140
    // return False, error
    intc_0 // 0
    frame_bury 0
    retsub

is_voting_open_after_if_else@2:
    // smart_contracts/proposal/contract.py:142
    // return voting_duration <= maximum_voting_duration, typ.Error("")
    frame_dig 0
    frame_dig 2
    <=
    bytec_0 // 0x0000
    frame_bury 1
    frame_bury 0
    retsub


// smart_contracts.proposal.contract.Proposal.get_voting_duration(category: uint64) -> uint64, bytes:
get_voting_duration:
    // smart_contracts/proposal/contract.py:218-219
    // @subroutine
    // def get_voting_duration(self, category: UInt64) -> tuple[UInt64, typ.Error]:
    proto 1 2
    // smart_contracts/proposal/contract.py:220
    // if category == enm.CATEGORY_SMALL:
    frame_dig -1
    intc_2 // 10
    ==
    bz get_voting_duration_else_body@2
    // smart_contracts/proposal/contract.py:222
    // Bytes(reg_cfg.GS_KEY_VOTING_DURATION_SMALL)
    pushbytes 0x766f74696e675f6475726174696f6e5f736d616c6c
    // smart_contracts/proposal/contract.py:221-223
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_VOTING_DURATION_SMALL)
    // )
    callsub get_uint_from_registry_config
    retsub

get_voting_duration_else_body@2:
    // smart_contracts/proposal/contract.py:224
    // elif category == enm.CATEGORY_MEDIUM:
    frame_dig -1
    intc_3 // 20
    ==
    bz get_voting_duration_else_body@4
    // smart_contracts/proposal/contract.py:226
    // Bytes(reg_cfg.GS_KEY_VOTING_DURATION_MEDIUM)
    pushbytes 0x766f74696e675f6475726174696f6e5f6d656469756d
    // smart_contracts/proposal/contract.py:225-227
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_VOTING_DURATION_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    retsub

get_voting_duration_else_body@4:
    // smart_contracts/proposal/contract.py:230
    // Bytes(reg_cfg.GS_KEY_VOTING_DURATION_LARGE)
    pushbytes 0x766f74696e675f6475726174696f6e5f6c61726765
    // smart_contracts/proposal/contract.py:229-231
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_VOTING_DURATION_LARGE)
    // )
    callsub get_uint_from_registry_config
    retsub


// smart_contracts.proposal.contract.Proposal.vote_input_validation(voter: bytes, approvals: bytes, rejections: bytes) -> bytes:
vote_input_validation:
    // smart_contracts/proposal/contract.py:160-163
    // @subroutine
    // def vote_input_validation(
    //     self, voter: arc4.Address, approvals: arc4.UInt64, rejections: arc4.UInt64
    // ) -> typ.Error:
    proto 3 1
    intc_0 // 0
    // smart_contracts/proposal/contract.py:164
    // if voter.native not in self.voters:
    bytec 18 // "V"
    frame_dig -3
    concat
    dup
    box_len
    bury 1
    bnz vote_input_validation_after_if_else@2
    // smart_contracts/proposal/contract.py:165
    // return typ.Error("ERR:" + err.VOTER_NOT_FOUND)
    pushbytes 0x00134552523a566f746572206e6f7420666f756e64
    frame_bury 0
    retsub

vote_input_validation_after_if_else@2:
    // smart_contracts/proposal/contract.py:167
    // voter_box = self.voters[voter.native].copy()
    frame_dig 1
    box_get
    swap
    dup
    cover 2
    frame_bury 0
    assert // check self.voters entry exists
    // smart_contracts/proposal/contract.py:168
    // if voter_box.voted:
    pushint 64 // 64
    getbit
    bytec 23 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 23 // 0x00
    !=
    bz vote_input_validation_after_if_else@4
    // smart_contracts/proposal/contract.py:169
    // return typ.Error("ERR:" + err.VOTER_ALREADY_VOTED)
    pushbytes 0x00174552523a566f74657220616c726561647920766f746564
    frame_bury 0
    retsub

vote_input_validation_after_if_else@4:
    // smart_contracts/proposal/contract.py:171
    // if approvals.native + rejections.native > voter_box.votes:
    frame_dig 0
    extract 0 8 // on error: Index access is out of bounds
    frame_dig -2
    btoi
    frame_dig -1
    btoi
    +
    itob
    b<
    bz vote_input_validation_after_if_else@6
    // smart_contracts/proposal/contract.py:172
    // return typ.Error("ERR:" + err.VOTES_EXCEEDED)
    pushbytes 0x00124552523a566f746573206578636565646564
    frame_bury 0
    retsub

vote_input_validation_after_if_else@6:
    // smart_contracts/proposal/contract.py:174
    // return typ.Error("")
    bytec_0 // 0x0000
    frame_bury 0
    retsub


// smart_contracts.proposal.contract.Proposal.scrutiny() -> void:
scrutiny:
    // smart_contracts/proposal/contract.py:675-676
    // @arc4.abimethod()
    // def scrutiny(self) -> None:
    proto 0 0
    // smart_contracts/proposal/contract.py:685
    // self.scrutiny_check_authorization()
    callsub scrutiny_check_authorization
    // smart_contracts/proposal/contract.py:687-689
    // # A category dependent quorum of all xGov Voting Committee (1 xGov, 1 vote) is reached.
    // # Null votes affect this quorum.
    // quorum_bps = self.get_quorum(self.category.value)
    intc_0 // 0
    bytec_2 // 0x63617465676f7279
    app_global_get_ex
    assert // check self.category exists
    callsub get_quorum
    // smart_contracts/proposal/contract.py:691
    // self.committee_members.value, quorum_bps
    intc_0 // 0
    bytec 6 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    // smart_contracts/proposal/contract.py:690-692
    // minimum_voters_required = self.relative_to_absolute_amount(
    //     self.committee_members.value, quorum_bps
    // )
    swap
    callsub relative_to_absolute_amount
    // smart_contracts/proposal/contract.py:694-696
    // # A category dependent weighted quorum of all xGov Voting Committee voting power (1 vote) is reached.
    // # Null votes affect this quorum.
    // weighted_quorum_bps = self.get_weighted_quorum(self.category.value)
    intc_0 // 0
    bytec_2 // 0x63617465676f7279
    app_global_get_ex
    assert // check self.category exists
    callsub get_weighted_quorum
    // smart_contracts/proposal/contract.py:697
    // total_votes = self.approvals.value + self.rejections.value + self.nulls.value
    intc_0 // 0
    bytec 10 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    intc_0 // 0
    bytec 11 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    +
    intc_0 // 0
    bytec 15 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    +
    cover 2
    // smart_contracts/proposal/contract.py:699
    // self.committee_votes.value, weighted_quorum_bps
    intc_0 // 0
    bytec 8 // 0x636f6d6d69747465655f766f746573
    app_global_get_ex
    assert // check self.committee_votes exists
    // smart_contracts/proposal/contract.py:698-700
    // minimum_votes_required = self.relative_to_absolute_amount(
    //     self.committee_votes.value, weighted_quorum_bps
    // )
    swap
    callsub relative_to_absolute_amount
    swap
    // smart_contracts/proposal/contract.py:703
    // self.voted_members.value >= minimum_voters_required
    intc_0 // 0
    bytec 9 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    <=
    // smart_contracts/proposal/contract.py:703-707
    // self.voted_members.value >= minimum_voters_required
    // and total_votes >= minimum_votes_required
    // # The relative majority of Approved over Rejected votes is reached.
    // # Null votes do not affect the relative majority.
    // and self.approvals.value > self.rejections.value
    bz scrutiny_else_body@4
    // smart_contracts/proposal/contract.py:704
    // and total_votes >= minimum_votes_required
    frame_dig 0
    frame_dig 1
    >=
    // smart_contracts/proposal/contract.py:703-707
    // self.voted_members.value >= minimum_voters_required
    // and total_votes >= minimum_votes_required
    // # The relative majority of Approved over Rejected votes is reached.
    // # Null votes do not affect the relative majority.
    // and self.approvals.value > self.rejections.value
    bz scrutiny_else_body@4
    // smart_contracts/proposal/contract.py:705-707
    // # The relative majority of Approved over Rejected votes is reached.
    // # Null votes do not affect the relative majority.
    // and self.approvals.value > self.rejections.value
    intc_0 // 0
    bytec 10 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    intc_0 // 0
    bytec 11 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    >
    // smart_contracts/proposal/contract.py:703-707
    // self.voted_members.value >= minimum_voters_required
    // and total_votes >= minimum_votes_required
    // # The relative majority of Approved over Rejected votes is reached.
    // # Null votes do not affect the relative majority.
    // and self.approvals.value > self.rejections.value
    bz scrutiny_else_body@4
    // smart_contracts/proposal/contract.py:709
    // self.status.value = UInt64(enm.STATUS_APPROVED)
    bytec_1 // 0x737461747573
    pushint 30 // 30
    app_global_put
    b scrutiny_after_if_else@6

scrutiny_else_body@4:
    // smart_contracts/proposal/contract.py:711
    // self.status.value = UInt64(enm.STATUS_REJECTED)
    bytec_1 // 0x737461747573
    pushint 40 // 40
    app_global_put
    // smart_contracts/proposal/contract.py:712-716
    // itxn.Payment(
    //     receiver=self.proposer.value.native,
    //     amount=self.locked_amount.value,
    //     fee=UInt64(0),  # enforces the sender to pay the fee
    // ).submit()
    itxn_begin
    // smart_contracts/proposal/contract.py:713
    // receiver=self.proposer.value.native,
    intc_0 // 0
    bytec 4 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:714
    // amount=self.locked_amount.value,
    intc_0 // 0
    bytec 5 // 0x6c6f636b65645f616d6f756e74
    app_global_get_ex
    assert // check self.locked_amount exists
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/proposal/contract.py:712
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/proposal/contract.py:715
    // fee=UInt64(0),  # enforces the sender to pay the fee
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/proposal/contract.py:712-716
    // itxn.Payment(
    //     receiver=self.proposer.value.native,
    //     amount=self.locked_amount.value,
    //     fee=UInt64(0),  # enforces the sender to pay the fee
    // ).submit()
    itxn_submit
    // smart_contracts/proposal/contract.py:717
    // self.locked_amount.value = UInt64(0)
    bytec 5 // 0x6c6f636b65645f616d6f756e74
    intc_0 // 0
    app_global_put

scrutiny_after_if_else@6:
    retsub


// smart_contracts.proposal.contract.Proposal.scrutiny_check_authorization() -> void:
scrutiny_check_authorization:
    // smart_contracts/proposal/contract.py:176-177
    // @subroutine
    // def scrutiny_check_authorization(self) -> None:
    proto 0 0
    // smart_contracts/proposal/contract.py:178
    // assert self.status.value == enm.STATUS_VOTING, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 25 // 25
    ==
    assert // Wrong Proposal Status
    // smart_contracts/proposal/contract.py:180
    // is_voting_open, error = self.is_voting_open()
    callsub is_voting_open
    // smart_contracts/proposal/contract.py:181
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:184
    // not is_voting_open  # voting period has ended
    bz scrutiny_check_authorization_bool_true@2
    // smart_contracts/proposal/contract.py:185
    // or self.voted_members.value
    intc_0 // 0
    bytec 9 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    // smart_contracts/proposal/contract.py:186
    // == self.committee_members.value  # all committee members have voted
    intc_0 // 0
    bytec 6 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    // smart_contracts/proposal/contract.py:185-186
    // or self.voted_members.value
    // == self.committee_members.value  # all committee members have voted
    ==
    // smart_contracts/proposal/contract.py:184-186
    // not is_voting_open  # voting period has ended
    // or self.voted_members.value
    // == self.committee_members.value  # all committee members have voted
    bz scrutiny_check_authorization_bool_false@3

scrutiny_check_authorization_bool_true@2:
    intc_1 // 1
    b scrutiny_check_authorization_bool_merge@4

scrutiny_check_authorization_bool_false@3:
    intc_0 // 0

scrutiny_check_authorization_bool_merge@4:
    // smart_contracts/proposal/contract.py:183-187
    // assert (
    //     not is_voting_open  # voting period has ended
    //     or self.voted_members.value
    //     == self.committee_members.value  # all committee members have voted
    // ), err.VOTING_ONGOING
    assert // Voting Ongoing
    retsub


// smart_contracts.proposal.contract.Proposal.get_quorum(category: uint64) -> uint64:
get_quorum:
    // smart_contracts/proposal/contract.py:233-234
    // @subroutine
    // def get_quorum(self, category: UInt64) -> UInt64:
    proto 1 1
    intc_0 // 0
    // smart_contracts/proposal/contract.py:235
    // if category == enm.CATEGORY_SMALL:
    frame_dig -1
    intc_2 // 10
    ==
    bz get_quorum_else_body@2
    // smart_contracts/proposal/contract.py:237
    // Bytes(reg_cfg.GS_KEY_QUORUM_SMALL)
    pushbytes 0x71756f72756d5f736d616c6c
    // smart_contracts/proposal/contract.py:236-238
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_QUORUM_SMALL)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b get_quorum_after_if_else@6

get_quorum_else_body@2:
    // smart_contracts/proposal/contract.py:239
    // elif category == enm.CATEGORY_MEDIUM:
    frame_dig -1
    intc_3 // 20
    ==
    bz get_quorum_else_body@4
    // smart_contracts/proposal/contract.py:241
    // Bytes(reg_cfg.GS_KEY_QUORUM_MEDIUM)
    pushbytes 0x71756f72756d5f6d656469756d
    // smart_contracts/proposal/contract.py:240-242
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_QUORUM_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b get_quorum_after_if_else@6

get_quorum_else_body@4:
    // smart_contracts/proposal/contract.py:245
    // Bytes(reg_cfg.GS_KEY_QUORUM_LARGE)
    pushbytes 0x71756f72756d5f6c61726765
    // smart_contracts/proposal/contract.py:244-246
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_QUORUM_LARGE)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0

get_quorum_after_if_else@6:
    // smart_contracts/proposal/contract.py:247
    // assert error == typ.Error(""), err.MISSING_CONFIG
    frame_dig 0
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:248
    // return value
    swap
    retsub


// smart_contracts.proposal.contract.Proposal.get_weighted_quorum(category: uint64) -> uint64:
get_weighted_quorum:
    // smart_contracts/proposal/contract.py:250-251
    // @subroutine
    // def get_weighted_quorum(self, category: UInt64) -> UInt64:
    proto 1 1
    intc_0 // 0
    // smart_contracts/proposal/contract.py:252
    // if category == enm.CATEGORY_SMALL:
    frame_dig -1
    intc_2 // 10
    ==
    bz get_weighted_quorum_else_body@2
    // smart_contracts/proposal/contract.py:254
    // Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_SMALL)
    pushbytes 0x77656967687465645f71756f72756d5f736d616c6c
    // smart_contracts/proposal/contract.py:253-255
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_SMALL)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b get_weighted_quorum_after_if_else@6

get_weighted_quorum_else_body@2:
    // smart_contracts/proposal/contract.py:256
    // elif category == enm.CATEGORY_MEDIUM:
    frame_dig -1
    intc_3 // 20
    ==
    bz get_weighted_quorum_else_body@4
    // smart_contracts/proposal/contract.py:258
    // Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_MEDIUM)
    pushbytes 0x77656967687465645f71756f72756d5f6d656469756d
    // smart_contracts/proposal/contract.py:257-259
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b get_weighted_quorum_after_if_else@6

get_weighted_quorum_else_body@4:
    // smart_contracts/proposal/contract.py:262
    // Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_LARGE)
    pushbytes 0x77656967687465645f71756f72756d5f6c61726765
    // smart_contracts/proposal/contract.py:261-263
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_LARGE)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0

get_weighted_quorum_after_if_else@6:
    // smart_contracts/proposal/contract.py:264
    // assert error == typ.Error(""), err.MISSING_CONFIG
    frame_dig 0
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:265
    // return value
    swap
    retsub
