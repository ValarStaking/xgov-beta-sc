#pragma version 10
#pragma typetrack false

// smart_contracts.proposal.contract.Proposal.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1 10 20 10000
    bytecblock 0x0000 0x737461747573 0x 0x66696e616c697a6564 0x70726f706f736572 0x72656769737472795f6170705f6964 0x66756e64696e675f63617465676f7279 "M" 0x636f6d6d69747465655f6d656d62657273 "voters_count" 0x636f6d6d69747465655f766f746573 0x766f7465645f6d656d62657273 0x617070726f76616c73 0x72656a656374696f6e73 "assigned_votes" 0x6c6f636b65645f616d6f756e74 0x6e756c6c73 0x151f7c75 0x00 0x6f70656e5f74696d657374616d70 0x766f74655f6f70656e696e675f74696d657374616d70 0x636f6d6d69747465655f6964 0x00264552523a57726f6e672050726f706f73616c20537461747573206f722066696e616c697a6564 0x7469746c65 0x7375626d697373696f6e5f74696d657374616d70 0x666f637573 0x66756e64696e675f74797065 0x7265717565737465645f616d6f756e74 "metadata_uploaded" "V" 0x78676f765f6461656d6f6e
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/proposal/contract.py:46
    // Txn.global_num_byte_slice == prop_cfg.GLOBAL_BYTES
    txn GlobalNumByteSlice
    pushint 3 // 3
    ==
    // smart_contracts/proposal/contract.py:44-47
    // # Preconditions
    // assert (
    //     Txn.global_num_byte_slice == prop_cfg.GLOBAL_BYTES
    // ), err.WRONG_GLOBAL_BYTES
    assert // Wrong Global Bytes allocation
    // smart_contracts/proposal/contract.py:48
    // assert Txn.global_num_uint == prop_cfg.GLOBAL_UINTS, err.WRONG_GLOBAL_UINTS
    txn GlobalNumUint
    intc_3 // 20
    ==
    assert // Wrong Global UInts allocation
    // smart_contracts/proposal/contract.py:49
    // assert Txn.local_num_byte_slice == prop_cfg.LOCAL_BYTES, err.WRONG_LOCAL_BYTES
    txn LocalNumByteSlice
    !
    assert // Wrong Local Bytes allocation
    // smart_contracts/proposal/contract.py:50
    // assert Txn.local_num_uint == prop_cfg.LOCAL_UINTS, err.WRONG_LOCAL_UINTS
    txn LocalNumUint
    !
    assert // Wrong Local UInts allocation
    // smart_contracts/proposal/contract.py:55
    // key=prop_cfg.GS_KEY_PROPOSER,
    bytec 4 // 0x70726f706f736572
    // smart_contracts/proposal/contract.py:54
    // Account(),
    global ZeroAddress
    // smart_contracts/proposal/contract.py:52-56
    // # Global Variables
    // self.proposer = GlobalState(
    //     Account(),
    //     key=prop_cfg.GS_KEY_PROPOSER,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:59
    // key=prop_cfg.GS_KEY_REGISTRY_APP_ID,
    bytec 5 // 0x72656769737472795f6170705f6964
    // smart_contracts/proposal/contract.py:58
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:57-60
    // self.registry_app_id = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_REGISTRY_APP_ID,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:63
    // key=prop_cfg.GS_KEY_TITLE,
    bytec 23 // 0x7469746c65
    // smart_contracts/proposal/contract.py:62
    // String(),
    bytec_2 // ""
    // smart_contracts/proposal/contract.py:61-64
    // self.title = GlobalState(
    //     String(),
    //     key=prop_cfg.GS_KEY_TITLE,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:67
    // key=prop_cfg.GS_KEY_OPEN_TS,
    bytec 19 // 0x6f70656e5f74696d657374616d70
    // smart_contracts/proposal/contract.py:66
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:65-68
    // self.open_ts = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_OPEN_TS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:71
    // key=prop_cfg.GS_KEY_SUBMISSION_TS,
    bytec 24 // 0x7375626d697373696f6e5f74696d657374616d70
    // smart_contracts/proposal/contract.py:70
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:69-72
    // self.submission_ts = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_SUBMISSION_TS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:75
    // key=prop_cfg.GS_KEY_VOTE_OPEN_TS,
    bytec 20 // 0x766f74655f6f70656e696e675f74696d657374616d70
    // smart_contracts/proposal/contract.py:74
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:73-76
    // self.vote_open_ts = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_VOTE_OPEN_TS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:79
    // key=prop_cfg.GS_KEY_STATUS,
    bytec_1 // 0x737461747573
    // smart_contracts/proposal/contract.py:78
    // UInt64(enm.STATUS_EMPTY),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:77-80
    // self.status = GlobalState(
    //     UInt64(enm.STATUS_EMPTY),
    //     key=prop_cfg.GS_KEY_STATUS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:83
    // key=prop_cfg.GS_KEY_FINALIZED,
    bytec_3 // 0x66696e616c697a6564
    // smart_contracts/proposal/contract.py:82
    // False,  # noqa: FBT003
    intc_0 // 0
    // smart_contracts/proposal/contract.py:81-84
    // self.finalized = GlobalState(
    //     False,  # noqa: FBT003
    //     key=prop_cfg.GS_KEY_FINALIZED,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:87
    // key=prop_cfg.GS_KEY_FUNDING_CATEGORY,
    bytec 6 // 0x66756e64696e675f63617465676f7279
    // smart_contracts/proposal/contract.py:86
    // UInt64(enm.FUNDING_CATEGORY_NULL),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:85-88
    // self.funding_category = GlobalState(
    //     UInt64(enm.FUNDING_CATEGORY_NULL),
    //     key=prop_cfg.GS_KEY_FUNDING_CATEGORY,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:91
    // key=prop_cfg.GS_KEY_FOCUS,
    bytec 25 // 0x666f637573
    // smart_contracts/proposal/contract.py:90
    // UInt64(enm.FOCUS_NULL),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:89-92
    // self.focus = GlobalState(
    //     UInt64(enm.FOCUS_NULL),
    //     key=prop_cfg.GS_KEY_FOCUS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:95
    // key=prop_cfg.GS_KEY_FUNDING_TYPE,
    bytec 26 // 0x66756e64696e675f74797065
    // smart_contracts/proposal/contract.py:94
    // UInt64(enm.FUNDING_NULL),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:93-96
    // self.funding_type = GlobalState(
    //     UInt64(enm.FUNDING_NULL),
    //     key=prop_cfg.GS_KEY_FUNDING_TYPE,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:99
    // key=prop_cfg.GS_KEY_REQUESTED_AMOUNT,
    bytec 27 // 0x7265717565737465645f616d6f756e74
    // smart_contracts/proposal/contract.py:98
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:97-100
    // self.requested_amount = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_REQUESTED_AMOUNT,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:103
    // key=prop_cfg.GS_KEY_LOCKED_AMOUNT,
    bytec 15 // 0x6c6f636b65645f616d6f756e74
    // smart_contracts/proposal/contract.py:102
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:101-104
    // self.locked_amount = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_LOCKED_AMOUNT,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:107
    // key=prop_cfg.GS_KEY_COMMITTEE_ID,
    bytec 21 // 0x636f6d6d69747465655f6964
    // smart_contracts/proposal/contract.py:106
    // typ.Bytes32.from_bytes(b""),
    bytec_2 // 0x
    // smart_contracts/proposal/contract.py:105-108
    // self.committee_id = GlobalState(
    //     typ.Bytes32.from_bytes(b""),
    //     key=prop_cfg.GS_KEY_COMMITTEE_ID,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:111
    // key=prop_cfg.GS_KEY_COMMITTEE_MEMBERS,
    bytec 8 // 0x636f6d6d69747465655f6d656d62657273
    // smart_contracts/proposal/contract.py:110
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:109-112
    // self.committee_members = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_COMMITTEE_MEMBERS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:115
    // key=prop_cfg.GS_KEY_COMMITTEE_VOTES,
    bytec 10 // 0x636f6d6d69747465655f766f746573
    // smart_contracts/proposal/contract.py:114
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:113-116
    // self.committee_votes = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_COMMITTEE_VOTES,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:119
    // key=prop_cfg.GS_KEY_VOTED_MEMBERS,
    bytec 11 // 0x766f7465645f6d656d62657273
    // smart_contracts/proposal/contract.py:118
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:117-120
    // self.voted_members = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_VOTED_MEMBERS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:123
    // key=prop_cfg.GS_KEY_APPROVALS,
    bytec 12 // 0x617070726f76616c73
    // smart_contracts/proposal/contract.py:122
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:121-124
    // self.approvals = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_APPROVALS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:127
    // key=prop_cfg.GS_KEY_REJECTIONS,
    bytec 13 // 0x72656a656374696f6e73
    // smart_contracts/proposal/contract.py:126
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:125-128
    // self.rejections = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_REJECTIONS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:131
    // key=prop_cfg.GS_KEY_NULLS,
    bytec 16 // 0x6e756c6c73
    // smart_contracts/proposal/contract.py:130
    // UInt64(),
    intc_0 // 0
    // smart_contracts/proposal/contract.py:129-132
    // self.nulls = GlobalState(
    //     UInt64(),
    //     key=prop_cfg.GS_KEY_NULLS,
    // )
    app_global_put
    // smart_contracts/proposal/contract.py:133
    // self.voters_count = UInt64(0)
    bytec 9 // "voters_count"
    intc_0 // 0
    app_global_put
    // smart_contracts/proposal/contract.py:134
    // self.assigned_votes = UInt64(0)
    bytec 14 // "assigned_votes"
    intc_0 // 0
    app_global_put
    // smart_contracts/proposal/contract.py:135
    // self.metadata_uploaded = False
    bytec 28 // "metadata_uploaded"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txn NumAppArgs
    bz main_after_if_else@20
    pushbytess 0xcc694eaa 0xedaeb9ca 0x7143994f 0x7371321a 0x34e613ca 0x0d9ab0d7 0x1841a0d2 0x734dbecc 0x212d9f07 0x8a5e4c80 0x2ac19b05 0x802069b4 0x24378d3c 0xa8c6f80a 0xdbd83dd9 // method "create(address)void", method "open(pay,string,uint64,uint64,uint8)void", method "upload_metadata(byte[],bool)void", method "drop()string", method "submit()void", method "assign_voters((address,uint64)[])void", method "vote(address,uint64,uint64)string", method "scrutiny()void", method "review(bool)void", method "fund()string", method "unassign_voters(address[])void", method "finalize()string", method "delete()void", method "get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)", method "op_up()void"
    txna ApplicationArgs 0
    match main_create_route@5 main_open_route@6 main_upload_metadata_route@7 main_drop_route@8 main_submit_route@9 main_assign_voters_route@10 main_vote_route@11 main_scrutiny_route@12 main_review_route@13 main_fund_route@14 main_unassign_voters_route@15 main_finalize_route@16 main_delete_route@17 main_get_state_route@18 main_op_up_route@19

main_after_if_else@20:
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    intc_0 // 0
    return

main_op_up_route@19:
    // smart_contracts/proposal/contract.py:1029
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_1 // 1
    return

main_get_state_route@18:
    // smart_contracts/proposal/contract.py:998
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_state
    bytec 17 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_delete_route@17:
    // smart_contracts/proposal/contract.py:977
    // @arc4.abimethod(allow_actions=("DeleteApplication",))
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    assert // OnCompletion is not DeleteApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub delete
    intc_1 // 1
    return

main_finalize_route@16:
    // smart_contracts/proposal/contract.py:941
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub finalize
    bytec 17 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_unassign_voters_route@15:
    // smart_contracts/proposal/contract.py:910
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/proposal/contract.py:910
    // @arc4.abimethod()
    callsub unassign_voters
    intc_1 // 1
    return

main_fund_route@14:
    // smart_contracts/proposal/contract.py:888
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub fund
    bytec 17 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_review_route@13:
    // smart_contracts/proposal/contract.py:861
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    intc_0 // 0
    getbit
    // smart_contracts/proposal/contract.py:861
    // @arc4.abimethod()
    callsub review
    intc_1 // 1
    return

main_scrutiny_route@12:
    // smart_contracts/proposal/contract.py:817
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub scrutiny
    intc_1 // 1
    return

main_vote_route@11:
    // smart_contracts/proposal/contract.py:769
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/proposal/contract.py:769
    // @arc4.abimethod()
    callsub vote
    bytec 17 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_assign_voters_route@10:
    // smart_contracts/proposal/contract.py:727
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/proposal/contract.py:727
    // @arc4.abimethod()
    callsub assign_voters
    intc_1 // 1
    return

main_submit_route@9:
    // smart_contracts/proposal/contract.py:675
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub submit
    intc_1 // 1
    return

main_drop_route@8:
    // smart_contracts/proposal/contract.py:652
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub drop
    bytec 17 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_upload_metadata_route@7:
    // smart_contracts/proposal/contract.py:618
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/proposal/contract.py:618
    // @arc4.abimethod()
    callsub upload_metadata
    intc_1 // 1
    return

main_open_route@6:
    // smart_contracts/proposal/contract.py:565
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/proposal/contract.py:565
    // @arc4.abimethod()
    callsub open
    intc_1 // 1
    return

main_create_route@5:
    // smart_contracts/proposal/contract.py:542
    // @arc4.abimethod(create="require")
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/proposal/contract.py:34-42
    // class Proposal(
    //     ARC4Contract,
    //     state_totals=StateTotals(
    //         global_bytes=prop_cfg.GLOBAL_BYTES,
    //         global_uints=prop_cfg.GLOBAL_UINTS,
    //         local_bytes=prop_cfg.LOCAL_BYTES,
    //         local_uints=prop_cfg.LOCAL_UINTS,
    //     ),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/proposal/contract.py:542
    // @arc4.abimethod(create="require")
    callsub create
    intc_1 // 1
    return


// smart_contracts.proposal.contract.Proposal.is_voting_open() -> uint64, bytes:
is_voting_open:
    // smart_contracts/proposal/contract.py:145-146
    // @subroutine
    // def is_voting_open(self) -> tuple[bool, typ.Error]:
    proto 0 2
    intc_0 // 0
    bytec_2 // ""
    // smart_contracts/proposal/contract.py:147
    // voting_duration = Global.latest_timestamp - self.vote_open_ts.value
    global LatestTimestamp
    intc_0 // 0
    bytec 20 // 0x766f74655f6f70656e696e675f74696d657374616d70
    app_global_get_ex
    assert // check self.vote_open_ts exists
    -
    // smart_contracts/proposal/contract.py:149
    // self.funding_category.value
    intc_0 // 0
    bytec 6 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:276
    // if category == enm.FUNDING_CATEGORY_SMALL:
    intc_2 // 10
    ==
    bz is_voting_open_else_body@5
    // smart_contracts/proposal/contract.py:278
    // Bytes(reg_cfg.GS_KEY_VOTING_DURATION_SMALL)
    pushbytes 0x766f74696e675f6475726174696f6e5f736d616c6c
    // smart_contracts/proposal/contract.py:277-279
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_VOTING_DURATION_SMALL)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    frame_bury 1

is_voting_open_after_inlined_smart_contracts.proposal.contract.Proposal.get_voting_duration@8:
    // smart_contracts/proposal/contract.py:151
    // if error != typ.Error(""):
    frame_dig 0
    bytec_0 // 0x0000
    !=
    bz is_voting_open_after_if_else@2
    // smart_contracts/proposal/contract.py:152
    // return False, error
    intc_0 // 0
    frame_dig 0
    frame_bury 1
    frame_bury 0
    retsub

is_voting_open_after_if_else@2:
    // smart_contracts/proposal/contract.py:154
    // return voting_duration <= maximum_voting_duration, typ.Error("")
    frame_dig 2
    frame_dig 1
    <=
    bytec_0 // 0x0000
    frame_bury 1
    frame_bury 0
    retsub

is_voting_open_else_body@5:
    // smart_contracts/proposal/contract.py:280
    // elif category == enm.FUNDING_CATEGORY_MEDIUM:
    frame_dig 3
    intc_3 // 20
    ==
    bz is_voting_open_else_body@7
    // smart_contracts/proposal/contract.py:282
    // Bytes(reg_cfg.GS_KEY_VOTING_DURATION_MEDIUM)
    pushbytes 0x766f74696e675f6475726174696f6e5f6d656469756d
    // smart_contracts/proposal/contract.py:281-283
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_VOTING_DURATION_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    frame_bury 1
    // smart_contracts/proposal/contract.py:148-150
    // maximum_voting_duration, error = self.get_voting_duration(
    //     self.funding_category.value
    // )
    b is_voting_open_after_inlined_smart_contracts.proposal.contract.Proposal.get_voting_duration@8

is_voting_open_else_body@7:
    // smart_contracts/proposal/contract.py:286
    // Bytes(reg_cfg.GS_KEY_VOTING_DURATION_LARGE)
    pushbytes 0x766f74696e675f6475726174696f6e5f6c61726765
    // smart_contracts/proposal/contract.py:285-287
    // return self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_VOTING_DURATION_LARGE)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    frame_bury 1
    // smart_contracts/proposal/contract.py:148-150
    // maximum_voting_duration, error = self.get_voting_duration(
    //     self.funding_category.value
    // )
    b is_voting_open_after_inlined_smart_contracts.proposal.contract.Proposal.get_voting_duration@8


// smart_contracts.proposal.contract.Proposal.assert_draft_and_proposer() -> void:
assert_draft_and_proposer:
    // smart_contracts/proposal/contract.py:349
    // assert self.is_proposer(), err.UNAUTHORIZED
    callsub is_proposer
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:351
    // self.status.value == enm.STATUS_DRAFT and not self.finalized.value
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_2 // 10
    ==
    bz assert_draft_and_proposer_bool_false@3
    intc_0 // 0
    bytec_3 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    bnz assert_draft_and_proposer_bool_false@3
    intc_1 // 1

assert_draft_and_proposer_bool_merge@4:
    // smart_contracts/proposal/contract.py:350-352
    // assert (
    //     self.status.value == enm.STATUS_DRAFT and not self.finalized.value
    // ), err.WRONG_PROPOSAL_STATUS
    assert // Wrong Proposal Status or finalized
    retsub

assert_draft_and_proposer_bool_false@3:
    intc_0 // 0
    b assert_draft_and_proposer_bool_merge@4


// smart_contracts.proposal.contract.Proposal.get_expected_locked_amount(requested_amount: uint64) -> uint64:
get_expected_locked_amount:
    // smart_contracts/proposal/contract.py:425-426
    // @subroutine
    // def get_expected_locked_amount(self, requested_amount: UInt64) -> UInt64:
    proto 1 1
    // smart_contracts/proposal/contract.py:428
    // Bytes(reg_cfg.GS_KEY_PROPOSAL_COMMITMENT_BPS)
    pushbytes 0x70726f706f73616c5f636f6d6d69746d656e745f627073
    // smart_contracts/proposal/contract.py:427-429
    // proposal_commitment_bps, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PROPOSAL_COMMITMENT_BPS)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:430
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:423
    // return amount * fraction_in_bps // const.BPS
    frame_dig -1
    *
    intc 4 // 10000
    /
    // smart_contracts/proposal/contract.py:431-434
    // return self.relative_to_absolute_amount(
    //     requested_amount,
    //     proposal_commitment_bps,
    // )
    retsub


// smart_contracts.proposal.contract.Proposal.get_uint_from_registry_config(global_state_key: bytes) -> uint64, bytes:
get_uint_from_registry_config:
    // smart_contracts/proposal/contract.py:467-470
    // @subroutine
    // def get_uint_from_registry_config(
    //     self, global_state_key: Bytes
    // ) -> tuple[UInt64, typ.Error]:
    proto 1 2
    // smart_contracts/proposal/contract.py:472
    // self.registry_app_id.value, global_state_key
    intc_0 // 0
    bytec 5 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:471-473
    // value, exists = AppGlobal.get_ex_uint64(
    //     self.registry_app_id.value, global_state_key
    // )
    frame_dig -1
    app_global_get_ex
    // smart_contracts/proposal/contract.py:474
    // error = typ.Error("")
    bytec_0 // 0x0000
    swap
    // smart_contracts/proposal/contract.py:475
    // if not exists:
    bnz get_uint_from_registry_config_after_if_else@2
    // smart_contracts/proposal/contract.py:476
    // error = typ.Error(err.ARC_65_PREFIX + err.MISSING_CONFIG)
    pushbytes 0x00124552523a4d697373696e6720436f6e666967
    frame_bury 1

get_uint_from_registry_config_after_if_else@2:
    // smart_contracts/proposal/contract.py:477
    // return value, error
    frame_dig 0
    frame_dig 1
    uncover 3
    uncover 3
    retsub


// smart_contracts.proposal.contract.Proposal.get_bytes_from_registry_config(global_state_key: bytes) -> bytes:
get_bytes_from_registry_config:
    // smart_contracts/proposal/contract.py:479-480
    // @subroutine
    // def get_bytes_from_registry_config(self, global_state_key: Bytes) -> Bytes:
    proto 1 1
    // smart_contracts/proposal/contract.py:482
    // self.registry_app_id.value, global_state_key
    intc_0 // 0
    bytec 5 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:481-483
    // value, exists = AppGlobal.get_ex_bytes(
    //     self.registry_app_id.value, global_state_key
    // )
    frame_dig -1
    app_global_get_ex
    // smart_contracts/proposal/contract.py:484
    // assert exists, err.MISSING_CONFIG
    assert // Missing Config
    // smart_contracts/proposal/contract.py:485
    // return value
    retsub


// smart_contracts.proposal.contract.Proposal.check_registry_not_paused() -> void:
check_registry_not_paused:
    // smart_contracts/proposal/contract.py:490
    // Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    pushbytes 0x7061757365645f7265676973747279
    // smart_contracts/proposal/contract.py:489-491
    // registry_paused, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_PAUSED_REGISTRY)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:493
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:494
    // assert not registry_paused, err.PAUSED_REGISTRY
    !
    assert // Registry's non-admin methods are paused
    retsub


// smart_contracts.proposal.contract.Proposal.is_proposer() -> uint64:
is_proposer:
    // smart_contracts/proposal/contract.py:502
    // return Txn.sender == self.proposer.value
    txn Sender
    intc_0 // 0
    bytec 4 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.is_xgov_daemon() -> uint64:
is_xgov_daemon:
    // smart_contracts/proposal/contract.py:512
    // return Txn.sender == Account(
    txn Sender
    // smart_contracts/proposal/contract.py:513
    // self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_DAEMON))
    bytec 30 // 0x78676f765f6461656d6f6e
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:512-514
    // return Txn.sender == Account(
    //     self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_DAEMON))
    // )
    dup
    len
    pushint 32 // 32
    ==
    assert // Address length is 32 bytes
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.is_registry_call() -> uint64:
is_registry_call:
    // smart_contracts/proposal/contract.py:518
    // return Global.caller_application_id == self.registry_app_id.value
    global CallerApplicationID
    intc_0 // 0
    bytec 5 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    ==
    retsub


// smart_contracts.proposal.contract.Proposal.pay(receiver: bytes, amount: uint64) -> void:
pay:
    // smart_contracts/proposal/contract.py:520-521
    // @subroutine
    // def pay(self, receiver: Account, amount: UInt64) -> None:
    proto 2 0
    // smart_contracts/proposal/contract.py:522-526
    // itxn.Payment(
    //     receiver=receiver,
    //     amount=amount,
    //     fee=UInt64(0),  # enforces the sender to pay the fee
    // ).submit()
    itxn_begin
    frame_dig -1
    itxn_field Amount
    frame_dig -2
    itxn_field Receiver
    // smart_contracts/proposal/contract.py:522
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/proposal/contract.py:525
    // fee=UInt64(0),  # enforces the sender to pay the fee
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/proposal/contract.py:522-526
    // itxn.Payment(
    //     receiver=receiver,
    //     amount=amount,
    //     fee=UInt64(0),  # enforces the sender to pay the fee
    // ).submit()
    itxn_submit
    retsub


// smart_contracts.proposal.contract.Proposal.transfer_locked_amount(receiver: bytes) -> void:
transfer_locked_amount:
    // smart_contracts/proposal/contract.py:528-529
    // @subroutine
    // def transfer_locked_amount(self, receiver: Account) -> None:
    proto 1 0
    // smart_contracts/proposal/contract.py:530
    // self.pay(receiver, self.locked_amount.value)
    intc_0 // 0
    bytec 15 // 0x6c6f636b65645f616d6f756e74
    app_global_get_ex
    assert // check self.locked_amount exists
    frame_dig -1
    swap
    callsub pay
    // smart_contracts/proposal/contract.py:531
    // self.locked_amount.value = UInt64(0)
    bytec 15 // 0x6c6f636b65645f616d6f756e74
    intc_0 // 0
    app_global_put
    retsub


// smart_contracts.proposal.contract.Proposal.assert_same_app_and_method(group_index: uint64) -> void:
assert_same_app_and_method:
    // smart_contracts/proposal/contract.py:533-534
    // @subroutine
    // def assert_same_app_and_method(self, group_index: UInt64) -> None:
    proto 1 0
    // smart_contracts/proposal/contract.py:536
    // GTxn.application_id(group_index) == Global.current_application_id
    frame_dig -1
    gtxns ApplicationID
    global CurrentApplicationID
    ==
    // smart_contracts/proposal/contract.py:535-537
    // assert (
    //     GTxn.application_id(group_index) == Global.current_application_id
    // ), err.WRONG_APP_ID
    assert // Wrong App ID
    // smart_contracts/proposal/contract.py:538
    // assert GTxn.application_args(group_index, 0) == Txn.application_args(
    frame_dig -1
    gtxnsa ApplicationArgs 0
    // smart_contracts/proposal/contract.py:538-540
    // assert GTxn.application_args(group_index, 0) == Txn.application_args(
    //     0
    // ), err.WRONG_METHOD_CALL
    txna ApplicationArgs 0
    ==
    assert // Wrong Method Call
    retsub


// smart_contracts.proposal.contract.Proposal.create(proposer: bytes) -> void:
create:
    // smart_contracts/proposal/contract.py:542-543
    // @arc4.abimethod(create="require")
    // def create(self, proposer: arc4.Address) -> None:
    proto 1 0
    // smart_contracts/proposal/contract.py:557
    // Global.caller_application_id != 0
    global CallerApplicationID
    // smart_contracts/proposal/contract.py:556-558
    // assert (
    //     Global.caller_application_id != 0
    // ), err.UNAUTHORIZED  # Only callable by another contract
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:560
    // self.proposer.value = proposer.native
    bytec 4 // 0x70726f706f736572
    frame_dig -1
    app_global_put
    // smart_contracts/proposal/contract.py:561
    // self.registry_app_id.value = Global.caller_application_id
    bytec 5 // 0x72656769737472795f6170705f6964
    global CallerApplicationID
    app_global_put
    // smart_contracts/proposal/contract.py:327
    // self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_COMMITTEE_ID))
    bytec 21 // 0x636f6d6d69747465655f6964
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:329
    // assert committee_id != typ.Bytes32.from_bytes(b""), err.EMPTY_COMMITTEE_ID
    dup
    bytec_2 // 0x
    !=
    assert // Empty Committee ID
    // smart_contracts/proposal/contract.py:332
    // Bytes(reg_cfg.GS_KEY_COMMITTEE_MEMBERS)
    bytec 8 // 0x636f6d6d69747465655f6d656d62657273
    // smart_contracts/proposal/contract.py:331-333
    // committee_members, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COMMITTEE_MEMBERS)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:334
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:335
    // assert committee_members > UInt64(0), err.WRONG_COMMITTEE_MEMBERS
    dup
    assert // Wrong Committee Members
    // smart_contracts/proposal/contract.py:338
    // Bytes(reg_cfg.GS_KEY_COMMITTEE_VOTES)
    bytec 10 // 0x636f6d6d69747465655f766f746573
    // smart_contracts/proposal/contract.py:337-339
    // committee_votes, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_COMMITTEE_VOTES)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:340
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:341
    // assert committee_votes > UInt64(0), err.WRONG_COMMITTEE_VOTES
    dup
    assert // Wrong Committee Votes
    // smart_contracts/proposal/contract.py:343
    // self.committee_id.value = committee_id.copy()
    bytec 21 // 0x636f6d6d69747465655f6964
    uncover 3
    app_global_put
    // smart_contracts/proposal/contract.py:344
    // self.committee_members.value = committee_members
    bytec 8 // 0x636f6d6d69747465655f6d656d62657273
    uncover 2
    app_global_put
    // smart_contracts/proposal/contract.py:345
    // self.committee_votes.value = committee_votes
    bytec 10 // 0x636f6d6d69747465655f766f746573
    swap
    app_global_put
    retsub


// smart_contracts.proposal.contract.Proposal.open(payment: uint64, title: bytes, funding_type: bytes, requested_amount: bytes, focus: bytes) -> void:
open:
    // smart_contracts/proposal/contract.py:565-573
    // @arc4.abimethod()
    // def open(
    //     self,
    //     payment: gtxn.PaymentTransaction,
    //     title: arc4.String,
    //     funding_type: arc4.UInt64,
    //     requested_amount: arc4.UInt64,
    //     focus: arc4.UInt8,
    // ) -> None:
    proto 5 0
    bytec_2 // ""
    dupn 2
    // smart_contracts/proposal/contract.py:598
    // self.check_registry_not_paused()
    callsub check_registry_not_paused
    // smart_contracts/proposal/contract.py:383
    // assert self.is_proposer(), err.UNAUTHORIZED
    callsub is_proposer
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:385
    // self.status.value == enm.STATUS_EMPTY and not self.finalized.value
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    bnz open_bool_false@4
    intc_0 // 0
    bytec_3 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    bnz open_bool_false@4
    intc_1 // 1

open_bool_merge@5:
    // smart_contracts/proposal/contract.py:384-386
    // assert (
    //     self.status.value == enm.STATUS_EMPTY and not self.finalized.value
    // ), err.WRONG_PROPOSAL_STATUS
    assert // Wrong Proposal Status or finalized
    // smart_contracts/proposal/contract.py:603
    // title.native, funding_type.native, requested_amount.native
    frame_dig -4
    extract 2 0
    frame_bury -4
    frame_dig -3
    btoi
    dup
    frame_bury 0
    frame_dig -2
    btoi
    frame_bury 2
    // smart_contracts/proposal/contract.py:396
    // assert title.bytes.length <= const.TITLE_MAX_BYTES, err.WRONG_TITLE_LENGTH
    frame_dig -4
    len
    pushint 123 // 123
    <=
    assert // Wrong Title length
    // smart_contracts/proposal/contract.py:397
    // assert title != "", err.WRONG_TITLE_LENGTH
    frame_dig -4
    bytec_2 // ""
    !=
    assert // Wrong Title length
    // smart_contracts/proposal/contract.py:400
    // funding_type == enm.FUNDING_PROACTIVE
    intc_2 // 10
    ==
    // smart_contracts/proposal/contract.py:400-401
    // funding_type == enm.FUNDING_PROACTIVE
    // or funding_type == enm.FUNDING_RETROACTIVE
    bnz open_bool_true@9
    // smart_contracts/proposal/contract.py:401
    // or funding_type == enm.FUNDING_RETROACTIVE
    frame_dig 0
    intc_3 // 20
    ==
    // smart_contracts/proposal/contract.py:400-401
    // funding_type == enm.FUNDING_PROACTIVE
    // or funding_type == enm.FUNDING_RETROACTIVE
    bz open_bool_false@10

open_bool_true@9:
    intc_1 // 1

open_bool_merge@11:
    // smart_contracts/proposal/contract.py:399-402
    // assert (
    //     funding_type == enm.FUNDING_PROACTIVE
    //     or funding_type == enm.FUNDING_RETROACTIVE
    // ), err.WRONG_FUNDING_TYPE
    assert // Wrong Funding Type
    // smart_contracts/proposal/contract.py:405
    // Bytes(reg_cfg.GS_KEY_MIN_REQUESTED_AMOUNT)
    pushbytes 0x6d696e5f7265717565737465645f616d6f756e74
    // smart_contracts/proposal/contract.py:404-406
    // min_requested_amount, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MIN_REQUESTED_AMOUNT)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:407
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:410
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_LARGE)
    pushbytes 0x6d61785f7265717565737465645f616d6f756e745f6c61726765
    // smart_contracts/proposal/contract.py:409-411
    // max_requested_amount_large, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_LARGE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:412
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:414
    // assert requested_amount >= min_requested_amount, err.WRONG_MIN_REQUESTED_AMOUNT
    frame_dig 2
    dup
    uncover 3
    >=
    assert // Requested amount is less than the minimum requested amount
    // smart_contracts/proposal/contract.py:416
    // requested_amount <= max_requested_amount_large
    dup
    uncover 2
    <=
    // smart_contracts/proposal/contract.py:415-417
    // assert (
    //     requested_amount <= max_requested_amount_large
    // ), err.WRONG_MAX_REQUESTED_AMOUNT
    assert // Requested amount is more than the maximum requested amount
    // smart_contracts/proposal/contract.py:440
    // expected_lock_amount = self.get_expected_locked_amount(requested_amount)
    dup
    callsub get_expected_locked_amount
    // smart_contracts/proposal/contract.py:442
    // assert payment.sender == self.proposer.value, err.WRONG_SENDER
    frame_dig -5
    gtxns Sender
    intc_0 // 0
    bytec 4 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    ==
    assert // Wrong Sender
    // smart_contracts/proposal/contract.py:444
    // payment.receiver == Global.current_application_address
    frame_dig -5
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/proposal/contract.py:443-445
    // assert (
    //     payment.receiver == Global.current_application_address
    // ), err.WRONG_RECEIVER
    assert // Wrong Receiver
    // smart_contracts/proposal/contract.py:446
    // assert payment.amount == expected_lock_amount, err.WRONG_LOCKED_AMOUNT
    frame_dig -5
    gtxns Amount
    ==
    assert // Locked amount is incorrect
    // smart_contracts/proposal/contract.py:607
    // self.title.value = title.native
    bytec 23 // 0x7469746c65
    frame_dig -4
    app_global_put
    // smart_contracts/proposal/contract.py:451
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_SMALL)
    pushbytes 0x6d61785f7265717565737465645f616d6f756e745f736d616c6c
    // smart_contracts/proposal/contract.py:450-452
    // max_requested_amount_small, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_SMALL)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:453
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:456
    // Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_MEDIUM)
    pushbytes 0x6d61785f7265717565737465645f616d6f756e745f6d656469756d
    // smart_contracts/proposal/contract.py:455-457
    // max_requested_amount_medium, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_MAX_REQUESTED_AMOUNT_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    swap
    frame_bury 1
    // smart_contracts/proposal/contract.py:458
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:460
    // if requested_amount <= max_requested_amount_small:
    <=
    bz open_else_body@17
    // smart_contracts/proposal/contract.py:461
    // self.funding_category.value = UInt64(enm.FUNDING_CATEGORY_SMALL)
    bytec 6 // 0x66756e64696e675f63617465676f7279
    intc_2 // 10
    app_global_put

open_after_if_else@20:
    // smart_contracts/proposal/contract.py:609
    // self.funding_type.value = funding_type.native
    bytec 26 // 0x66756e64696e675f74797065
    frame_dig 0
    app_global_put
    // smart_contracts/proposal/contract.py:610
    // self.requested_amount.value = requested_amount.native
    bytec 27 // 0x7265717565737465645f616d6f756e74
    frame_dig 2
    dup
    cover 2
    app_global_put
    // smart_contracts/proposal/contract.py:611
    // self.focus.value = focus.native
    frame_dig -1
    btoi
    bytec 25 // 0x666f637573
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:612-614
    // self.locked_amount.value = self.get_expected_locked_amount(
    //     requested_amount.native
    // )
    callsub get_expected_locked_amount
    // smart_contracts/proposal/contract.py:612
    // self.locked_amount.value = self.get_expected_locked_amount(
    bytec 15 // 0x6c6f636b65645f616d6f756e74
    // smart_contracts/proposal/contract.py:612-614
    // self.locked_amount.value = self.get_expected_locked_amount(
    //     requested_amount.native
    // )
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:615
    // self.open_ts.value = Global.latest_timestamp
    bytec 19 // 0x6f70656e5f74696d657374616d70
    global LatestTimestamp
    app_global_put
    // smart_contracts/proposal/contract.py:616
    // self.status.value = UInt64(enm.STATUS_DRAFT)
    bytec_1 // 0x737461747573
    intc_2 // 10
    app_global_put
    retsub

open_else_body@17:
    // smart_contracts/proposal/contract.py:462
    // elif requested_amount <= max_requested_amount_medium:
    frame_dig 2
    frame_dig 1
    <=
    bz open_else_body@19
    // smart_contracts/proposal/contract.py:463
    // self.funding_category.value = UInt64(enm.FUNDING_CATEGORY_MEDIUM)
    bytec 6 // 0x66756e64696e675f63617465676f7279
    intc_3 // 20
    app_global_put
    b open_after_if_else@20

open_else_body@19:
    // smart_contracts/proposal/contract.py:465
    // self.funding_category.value = UInt64(enm.FUNDING_CATEGORY_LARGE)
    bytec 6 // 0x66756e64696e675f63617465676f7279
    pushint 33 // 33
    app_global_put
    b open_after_if_else@20

open_bool_false@10:
    intc_0 // 0
    b open_bool_merge@11

open_bool_false@4:
    intc_0 // 0
    b open_bool_merge@5


// smart_contracts.proposal.contract.Proposal.upload_metadata(payload: bytes, is_first_in_group: bytes) -> void:
upload_metadata:
    // smart_contracts/proposal/contract.py:618-621
    // @arc4.abimethod()
    // def upload_metadata(
    //     self, payload: arc4.DynamicBytes, is_first_in_group: arc4.Bool
    // ) -> None:
    proto 2 0
    // smart_contracts/proposal/contract.py:635
    // self.check_registry_not_paused()
    callsub check_registry_not_paused
    // smart_contracts/proposal/contract.py:375
    // self.assert_draft_and_proposer()
    callsub assert_draft_and_proposer
    // smart_contracts/proposal/contract.py:379
    // assert payload.length > 0, err.EMPTY_PAYLOAD
    frame_dig -2
    intc_0 // 0
    extract_uint16
    dup
    assert // Empty payload
    // smart_contracts/proposal/contract.py:640
    // self.metadata_uploaded = True
    bytec 28 // "metadata_uploaded"
    intc_1 // 1
    app_global_put
    // smart_contracts/proposal/contract.py:642
    // if is_first_in_group:
    frame_dig -1
    bytec 18 // 0x00
    !=
    bz upload_metadata_else_body@2
    // smart_contracts/proposal/contract.py:643-644
    // # clear and write the metadata to the box
    // self.metadata.delete()
    bytec 7 // "M"
    box_del
    pop
    // smart_contracts/proposal/contract.py:645
    // self.metadata.put(payload.native)
    frame_dig -2
    extract 2 0
    bytec 7 // "M"
    swap
    box_put
    retsub

upload_metadata_else_body@2:
    // smart_contracts/proposal/contract.py:647-648
    // # append the metadata to the box
    // old_size = self.metadata.length
    bytec 7 // "M"
    box_len
    assert // check self.metadata exists
    // smart_contracts/proposal/contract.py:649
    // self.metadata.resize(self.metadata.length + payload.length)
    bytec 7 // "M"
    box_len
    assert // check self.metadata exists
    frame_dig 0
    +
    bytec 7 // "M"
    swap
    box_resize
    // smart_contracts/proposal/contract.py:650
    // self.metadata.replace(old_size, payload.native)
    frame_dig -2
    extract 2 0
    bytec 7 // "M"
    cover 2
    box_replace
    retsub


// smart_contracts.proposal.contract.Proposal.drop() -> bytes:
drop:
    // smart_contracts/proposal/contract.py:652-653
    // @arc4.abimethod()
    // def drop(self) -> typ.Error:
    proto 0 1
    intc_0 // 0
    // smart_contracts/proposal/contract.py:368
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:369
    // if self.status.value != enm.STATUS_DRAFT or self.finalized.value:
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_2 // 10
    !=
    bnz drop_if_body@5
    intc_0 // 0
    bytec_3 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    bz drop_after_if_else@6

drop_if_body@5:
    // smart_contracts/proposal/contract.py:370
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 22 // 0x00264552523a57726f6e672050726f706f73616c20537461747573206f722066696e616c697a6564
    frame_bury 0

drop_after_inlined_smart_contracts.proposal.contract.Proposal.drop_check_authorization@7:
    // smart_contracts/proposal/contract.py:663
    // if error != typ.Error(""):
    frame_dig 0
    bytec_0 // 0x0000
    !=
    bz drop_after_if_else@2
    // smart_contracts/proposal/contract.py:664
    // return error
    frame_dig 0
    swap
    retsub

drop_after_if_else@2:
    // smart_contracts/proposal/contract.py:667
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec 4 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:666-668
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount
    // smart_contracts/proposal/contract.py:670
    // self.metadata.delete()
    bytec 7 // "M"
    box_del
    pop
    // smart_contracts/proposal/contract.py:671
    // self.finalized.value = True
    bytec_3 // 0x66696e616c697a6564
    intc_1 // 1
    app_global_put
    // smart_contracts/proposal/contract.py:673
    // return typ.Error("")
    bytec_0 // 0x0000
    swap
    retsub

drop_after_if_else@6:
    // smart_contracts/proposal/contract.py:371
    // return typ.Error("")
    bytec_0 // 0x0000
    frame_bury 0
    // smart_contracts/proposal/contract.py:662
    // error = self.drop_check_authorization()
    b drop_after_inlined_smart_contracts.proposal.contract.Proposal.drop_check_authorization@7


// smart_contracts.proposal.contract.Proposal.submit() -> void:
submit:
    // smart_contracts/proposal/contract.py:675-676
    // @arc4.abimethod()
    // def submit(self) -> None:
    proto 0 0
    intc_0 // 0
    // smart_contracts/proposal/contract.py:687
    // self.check_registry_not_paused()
    callsub check_registry_not_paused
    // smart_contracts/proposal/contract.py:357
    // self.assert_draft_and_proposer()
    callsub assert_draft_and_proposer
    // smart_contracts/proposal/contract.py:359
    // discussion_duration = Global.latest_timestamp - self.open_ts.value
    global LatestTimestamp
    intc_0 // 0
    bytec 19 // 0x6f70656e5f74696d657374616d70
    app_global_get_ex
    assert // check self.open_ts exists
    -
    // smart_contracts/proposal/contract.py:361
    // self.funding_category.value
    intc_0 // 0
    bytec 6 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:259
    // if category == enm.FUNDING_CATEGORY_SMALL:
    intc_2 // 10
    ==
    bz submit_else_body@3
    // smart_contracts/proposal/contract.py:261
    // Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_SMALL)
    pushbytes 0x64697363757373696f6e5f6475726174696f6e5f736d616c6c
    // smart_contracts/proposal/contract.py:260-262
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_SMALL)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0

submit_after_if_else@7:
    // smart_contracts/proposal/contract.py:271
    // assert error == typ.Error(""), err.MISSING_CONFIG
    frame_dig 0
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:364
    // assert discussion_duration >= minimum_discussion_duration, err.TOO_EARLY
    frame_dig 1
    <=
    assert // Too early
    // smart_contracts/proposal/contract.py:691
    // self.status.value = UInt64(enm.STATUS_SUBMITTED)
    bytec_1 // 0x737461747573
    intc_3 // 20
    app_global_put
    // smart_contracts/proposal/contract.py:692
    // self.submission_ts.value = Global.latest_timestamp
    bytec 24 // 0x7375626d697373696f6e5f74696d657374616d70
    global LatestTimestamp
    app_global_put
    // smart_contracts/proposal/contract.py:695
    // Bytes(reg_cfg.GS_KEY_OPEN_PROPOSAL_FEE)
    pushbytes 0x6f70656e5f70726f706f73616c5f666565
    // smart_contracts/proposal/contract.py:694-696
    // open_proposal_fee, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_OPEN_PROPOSAL_FEE)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:697
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:699
    // assert self.metadata_uploaded, err.MISSING_METADATA
    intc_0 // 0
    bytec 28 // "metadata_uploaded"
    app_global_get_ex
    assert // check self.metadata_uploaded exists
    assert // Missing Metadata
    // smart_contracts/proposal/contract.py:702
    // Bytes(reg_cfg.GS_KEY_DAEMON_OPS_FUNDING_BPS)
    pushbytes 0x6461656d6f6e5f6f7065726174696f6e5f66756e64696e675f627073
    // smart_contracts/proposal/contract.py:701-703
    // daemon_ops_funding_bps, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DAEMON_OPS_FUNDING_BPS)
    // )
    callsub get_uint_from_registry_config
    // smart_contracts/proposal/contract.py:704
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:708
    // self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_DAEMON))
    bytec 30 // 0x78676f765f6461656d6f6e
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:707-709
    // receiver=Account(
    //     self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_DAEMON))
    // ),
    dup
    len
    pushint 32 // 32
    ==
    assert // Address length is 32 bytes
    // smart_contracts/proposal/contract.py:423
    // return amount * fraction_in_bps // const.BPS
    cover 2
    *
    intc 4 // 10000
    /
    // smart_contracts/proposal/contract.py:706-713
    // self.pay(
    //     receiver=Account(
    //         self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_DAEMON))
    //     ),
    //     amount=self.relative_to_absolute_amount(
    //         open_proposal_fee, daemon_ops_funding_bps
    //     ),
    // )
    callsub pay
    retsub

submit_else_body@3:
    // smart_contracts/proposal/contract.py:263
    // elif category == enm.FUNDING_CATEGORY_MEDIUM:
    frame_dig 2
    intc_3 // 20
    ==
    bz submit_else_body@5
    // smart_contracts/proposal/contract.py:265
    // Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_MEDIUM)
    pushbytes 0x64697363757373696f6e5f6475726174696f6e5f6d656469756d
    // smart_contracts/proposal/contract.py:264-266
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b submit_after_if_else@7

submit_else_body@5:
    // smart_contracts/proposal/contract.py:269
    // Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_LARGE)
    pushbytes 0x64697363757373696f6e5f6475726174696f6e5f6c61726765
    // smart_contracts/proposal/contract.py:268-270
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_DISCUSSION_DURATION_LARGE)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b submit_after_if_else@7


// smart_contracts.proposal.contract.Proposal.assign_voters(voters: bytes) -> void:
assign_voters:
    // smart_contracts/proposal/contract.py:727-731
    // @arc4.abimethod()
    // def assign_voters(
    //     self,
    //     voters: arc4.DynamicArray[CommitteeMember],
    // ) -> None:
    proto 1 0
    bytec_2 // ""
    dupn 2
    // smart_contracts/proposal/contract.py:247
    // assert self.is_xgov_daemon(), err.UNAUTHORIZED
    callsub is_xgov_daemon
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:248
    // assert self.status.value == enm.STATUS_SUBMITTED, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_3 // 20
    ==
    assert // Wrong Proposal Status or finalized
    // smart_contracts/proposal/contract.py:751
    // if Txn.group_index == 0:
    txn GroupIndex
    bnz assign_voters_else_body@6
    // smart_contracts/proposal/contract.py:752-753
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    global GroupSize
    frame_bury 1
    intc_1 // 1
    frame_bury 0

assign_voters_for_header@2:
    // smart_contracts/proposal/contract.py:752-753
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    frame_dig 0
    frame_dig 1
    <
    bz assign_voters_after_if_else@7
    // smart_contracts/proposal/contract.py:754
    // self.assert_same_app_and_method(i)
    frame_dig 0
    dup
    callsub assert_same_app_and_method
    // smart_contracts/proposal/contract.py:752-753
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    intc_1 // 1
    +
    frame_bury 0
    b assign_voters_for_header@2

assign_voters_after_if_else@7:
    // smart_contracts/proposal/contract.py:759
    // for i in urange(voters.length):
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_bury 2
    intc_0 // 0
    frame_bury 0

assign_voters_for_header@8:
    // smart_contracts/proposal/contract.py:759
    // for i in urange(voters.length):
    frame_dig 0
    frame_dig 2
    <
    bz assign_voters_after_for@11
    // smart_contracts/proposal/contract.py:760
    // self._assign_voter(voters[i].address.native, voters[i].voting_power.native)
    frame_dig -1
    extract 2 0
    frame_dig 0
    dup
    cover 2
    pushint 40 // 40
    *
    pushint 40 // 40
    extract3 // on error: Index access is out of bounds
    dup
    extract 0 32 // on error: Index access is out of bounds
    swap
    pushint 32 // 32
    extract_uint64
    // smart_contracts/proposal/contract.py:254
    // assert voter not in self.voters, err.VOTER_ALREADY_ASSIGNED
    bytec 29 // "V"
    uncover 2
    concat
    dup
    box_len
    bury 1
    !
    assert // Voter Already Assigned
    // smart_contracts/proposal/contract.py:255
    // assert voting_power > 0, err.INVALID_VOTING_POWER
    dig 1
    assert // Invalid Voting Power
    // smart_contracts/proposal/contract.py:720
    // votes=arc4.UInt64(voting_power),
    dig 1
    itob
    // smart_contracts/proposal/contract.py:721
    // voted=arc4.Bool(False),  # noqa: FBT003
    bytec 18 // 0x00
    // smart_contracts/proposal/contract.py:719-722
    // self.voters[voter] = typ.VoterBox(
    //     votes=arc4.UInt64(voting_power),
    //     voted=arc4.Bool(False),  # noqa: FBT003
    // )
    concat
    box_put
    // smart_contracts/proposal/contract.py:724
    // self.voters_count += 1
    intc_0 // 0
    bytec 9 // "voters_count"
    app_global_get_ex
    assert // check self.voters_count exists
    intc_1 // 1
    +
    bytec 9 // "voters_count"
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:725
    // self.assigned_votes += voting_power
    intc_0 // 0
    bytec 14 // "assigned_votes"
    app_global_get_ex
    assert // check self.assigned_votes exists
    +
    bytec 14 // "assigned_votes"
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:759
    // for i in urange(voters.length):
    intc_1 // 1
    +
    frame_bury 0
    b assign_voters_for_header@8

assign_voters_after_for@11:
    // smart_contracts/proposal/contract.py:762
    // if self.voters_count == self.committee_members.value:
    intc_0 // 0
    bytec 9 // "voters_count"
    app_global_get_ex
    assert // check self.voters_count exists
    intc_0 // 0
    bytec 8 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    ==
    bz assign_voters_after_if_else@13
    // smart_contracts/proposal/contract.py:764
    // self.assigned_votes == self.committee_votes.value
    intc_0 // 0
    bytec 14 // "assigned_votes"
    app_global_get_ex
    assert // check self.assigned_votes exists
    intc_0 // 0
    bytec 10 // 0x636f6d6d69747465655f766f746573
    app_global_get_ex
    assert // check self.committee_votes exists
    ==
    // smart_contracts/proposal/contract.py:763-765
    // assert (
    //     self.assigned_votes == self.committee_votes.value
    // ), err.VOTING_POWER_MISMATCH
    assert // Voting Power Mismatch
    // smart_contracts/proposal/contract.py:766
    // self.status.value = UInt64(enm.STATUS_VOTING)
    bytec_1 // 0x737461747573
    pushint 25 // 25
    app_global_put
    // smart_contracts/proposal/contract.py:767
    // self.vote_open_ts.value = Global.latest_timestamp
    bytec 20 // 0x766f74655f6f70656e696e675f74696d657374616d70
    global LatestTimestamp
    app_global_put

assign_voters_after_if_else@13:
    retsub

assign_voters_else_body@6:
    // smart_contracts/proposal/contract.py:756-757
    // # Check that the first transaction in the group calls the same app and method
    // self.assert_same_app_and_method(UInt64(0))
    intc_0 // 0
    callsub assert_same_app_and_method
    b assign_voters_after_if_else@7


// smart_contracts.proposal.contract.Proposal.vote(voter: bytes, approvals: bytes, rejections: bytes) -> bytes:
vote:
    // smart_contracts/proposal/contract.py:769-772
    // @arc4.abimethod()
    // def vote(
    //     self, voter: arc4.Address, approvals: arc4.UInt64, rejections: arc4.UInt64
    // ) -> typ.Error:
    proto 3 1
    intc_0 // 0
    dupn 2
    bytec_2 // ""
    dupn 2
    // smart_contracts/proposal/contract.py:202
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:204
    // if self.status.value != enm.STATUS_VOTING:
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 25 // 25
    !=
    bz vote_after_if_else@15
    // smart_contracts/proposal/contract.py:205
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 22 // 0x00264552523a57726f6e672050726f706f73616c20537461747573206f722066696e616c697a6564
    frame_bury 1

vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_check_authorization@20:
    // smart_contracts/proposal/contract.py:792
    // if error != typ.Error(""):
    frame_dig 1
    bytec_0 // 0x0000
    !=
    bz vote_after_if_else@2
    // smart_contracts/proposal/contract.py:793
    // return error
    frame_dig 1
    frame_bury 0
    retsub

vote_after_if_else@2:
    // smart_contracts/proposal/contract.py:796
    // voter.native, approvals.native, rejections.native
    frame_dig -2
    btoi
    frame_bury 3
    frame_dig -1
    btoi
    frame_bury 5
    // smart_contracts/proposal/contract.py:220
    // if voter not in self.voters:
    bytec 29 // "V"
    frame_dig -3
    concat
    dup
    frame_bury 0
    box_len
    bury 1
    bnz vote_after_if_else@7
    // smart_contracts/proposal/contract.py:221
    // return typ.Error(err.ARC_65_PREFIX + err.VOTER_NOT_FOUND)
    pushbytes 0x00134552523a566f746572206e6f7420666f756e64
    frame_bury 1

vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_input_validation@12:
    // smart_contracts/proposal/contract.py:798
    // if error != typ.Error(""):
    frame_dig 1
    bytec_0 // 0x0000
    !=
    bz vote_after_if_else@4
    // smart_contracts/proposal/contract.py:799
    // return error
    frame_dig 1
    frame_bury 0
    retsub

vote_after_if_else@4:
    // smart_contracts/proposal/contract.py:801
    // voter_box = self.voters[voter.native].copy()
    frame_dig 0
    dup
    box_get
    assert // check self.voters entry exists
    // smart_contracts/proposal/contract.py:803
    // votes=voter_box.votes,
    dup
    extract 0 8 // on error: Index access is out of bounds
    // smart_contracts/proposal/contract.py:804
    // voted=arc4.Bool(True),  # noqa: FBT003
    pushbytes 0x80
    // smart_contracts/proposal/contract.py:802-805
    // self.voters[voter.native] = typ.VoterBox(
    //     votes=voter_box.votes,
    //     voted=arc4.Bool(True),  # noqa: FBT003
    // )
    concat
    uncover 2
    swap
    box_put
    // smart_contracts/proposal/contract.py:807
    // self.voted_members.value += 1
    intc_0 // 0
    bytec 11 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    intc_1 // 1
    +
    bytec 11 // 0x766f7465645f6d656d62657273
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:809
    // nulls = voter_box.votes.native - approvals.native - rejections.native
    intc_0 // 0
    extract_uint64
    frame_dig 3
    dup
    cover 2
    -
    frame_dig 5
    dup
    cover 3
    -
    // smart_contracts/proposal/contract.py:811
    // self.approvals.value += approvals.native
    intc_0 // 0
    bytec 12 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    uncover 2
    +
    bytec 12 // 0x617070726f76616c73
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:812
    // self.rejections.value += rejections.native
    intc_0 // 0
    bytec 13 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    uncover 2
    +
    bytec 13 // 0x72656a656374696f6e73
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:813
    // self.nulls.value += nulls
    intc_0 // 0
    bytec 16 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    +
    bytec 16 // 0x6e756c6c73
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:815
    // return typ.Error("")
    bytec_0 // 0x0000
    frame_bury 0
    retsub

vote_after_if_else@7:
    // smart_contracts/proposal/contract.py:223
    // voter_box = self.voters[voter].copy()
    frame_dig 0
    box_get
    swap
    dup
    cover 2
    frame_bury 2
    assert // check self.voters entry exists
    // smart_contracts/proposal/contract.py:224
    // if voter_box.voted:
    pushint 64 // 64
    getbit
    bytec 18 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 18 // 0x00
    !=
    bz vote_after_if_else@9
    // smart_contracts/proposal/contract.py:225
    // return typ.Error(err.ARC_65_PREFIX + err.VOTER_ALREADY_VOTED)
    pushbytes 0x00174552523a566f74657220616c726561647920766f746564
    frame_bury 1
    // smart_contracts/proposal/contract.py:795-797
    // error = self.vote_input_validation(
    //     voter.native, approvals.native, rejections.native
    // )
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_input_validation@12

vote_after_if_else@9:
    // smart_contracts/proposal/contract.py:227
    // if approvals + rejections > voter_box.votes:
    frame_dig 2
    extract 0 8 // on error: Index access is out of bounds
    frame_dig 3
    frame_dig 5
    +
    itob
    b<
    bz vote_after_if_else@11
    // smart_contracts/proposal/contract.py:228
    // return typ.Error(err.ARC_65_PREFIX + err.VOTES_EXCEEDED)
    pushbytes 0x00124552523a566f746573206578636565646564
    frame_bury 1
    // smart_contracts/proposal/contract.py:795-797
    // error = self.vote_input_validation(
    //     voter.native, approvals.native, rejections.native
    // )
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_input_validation@12

vote_after_if_else@11:
    // smart_contracts/proposal/contract.py:230
    // return typ.Error("")
    bytec_0 // 0x0000
    frame_bury 1
    // smart_contracts/proposal/contract.py:795-797
    // error = self.vote_input_validation(
    //     voter.native, approvals.native, rejections.native
    // )
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_input_validation@12

vote_after_if_else@15:
    // smart_contracts/proposal/contract.py:207
    // is_voting_open, error = self.is_voting_open()
    callsub is_voting_open
    dup
    cover 2
    frame_bury 1
    frame_bury 4
    // smart_contracts/proposal/contract.py:208
    // if error != typ.Error(""):
    bytec_0 // 0x0000
    !=
    bnz vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_check_authorization@20
    // smart_contracts/proposal/contract.py:211
    // if not is_voting_open:
    frame_dig 4
    bnz vote_after_if_else@19
    // smart_contracts/proposal/contract.py:212
    // return typ.Error(err.ARC_65_PREFIX + err.VOTING_PERIOD_EXPIRED)
    pushbytes 0x00194552523a566f74696e6720506572696f642045787069726564
    frame_bury 1
    // smart_contracts/proposal/contract.py:791
    // error = self.vote_check_authorization()
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_check_authorization@20

vote_after_if_else@19:
    // smart_contracts/proposal/contract.py:214
    // return typ.Error("")
    bytec_0 // 0x0000
    frame_bury 1
    // smart_contracts/proposal/contract.py:791
    // error = self.vote_check_authorization()
    b vote_after_inlined_smart_contracts.proposal.contract.Proposal.vote_check_authorization@20


// smart_contracts.proposal.contract.Proposal.scrutiny() -> void:
scrutiny:
    // smart_contracts/proposal/contract.py:817-818
    // @arc4.abimethod()
    // def scrutiny(self) -> None:
    proto 0 0
    intc_0 // 0
    bytec_2 // ""
    dupn 3
    // smart_contracts/proposal/contract.py:828
    // self.check_registry_not_paused()
    callsub check_registry_not_paused
    // smart_contracts/proposal/contract.py:234
    // assert self.status.value == enm.STATUS_VOTING, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 25 // 25
    ==
    assert // Wrong Proposal Status or finalized
    // smart_contracts/proposal/contract.py:236
    // is_voting_open, error = self.is_voting_open()
    callsub is_voting_open
    // smart_contracts/proposal/contract.py:237
    // assert error == typ.Error(""), err.MISSING_CONFIG
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:240
    // not is_voting_open  # voting period has ended
    bz scrutiny_bool_true@8
    // smart_contracts/proposal/contract.py:241
    // or self.voted_members.value
    intc_0 // 0
    bytec 11 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    // smart_contracts/proposal/contract.py:242
    // == self.committee_members.value  # all committee members have voted
    intc_0 // 0
    bytec 8 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    // smart_contracts/proposal/contract.py:241-242
    // or self.voted_members.value
    // == self.committee_members.value  # all committee members have voted
    ==
    // smart_contracts/proposal/contract.py:240-242
    // not is_voting_open  # voting period has ended
    // or self.voted_members.value
    // == self.committee_members.value  # all committee members have voted
    bz scrutiny_bool_false@9

scrutiny_bool_true@8:
    intc_1 // 1

scrutiny_bool_merge@10:
    // smart_contracts/proposal/contract.py:239-243
    // assert (
    //     not is_voting_open  # voting period has ended
    //     or self.voted_members.value
    //     == self.committee_members.value  # all committee members have voted
    // ), err.VOTING_ONGOING
    assert // Voting Ongoing
    // smart_contracts/proposal/contract.py:832-834
    // # A category dependent quorum of all xGov Voting Committee (1 xGov, 1 vote) is reached.
    // # Null votes affect this quorum.
    // quorum_bps = self.get_quorum(self.funding_category.value)
    intc_0 // 0
    bytec 6 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    swap
    dup
    cover 2
    frame_bury 1
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:291
    // if category == enm.FUNDING_CATEGORY_SMALL:
    intc_2 // 10
    ==
    bz scrutiny_else_body@14
    // smart_contracts/proposal/contract.py:293
    // Bytes(reg_cfg.GS_KEY_QUORUM_SMALL)
    pushbytes 0x71756f72756d5f736d616c6c
    // smart_contracts/proposal/contract.py:292-294
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_QUORUM_SMALL)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0

scrutiny_after_if_else@18:
    // smart_contracts/proposal/contract.py:303
    // assert error == typ.Error(""), err.MISSING_CONFIG
    frame_dig 0
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:836
    // self.committee_members.value, quorum_bps
    intc_0 // 0
    bytec 8 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    // smart_contracts/proposal/contract.py:423
    // return amount * fraction_in_bps // const.BPS
    *
    intc 4 // 10000
    /
    frame_bury 2
    // smart_contracts/proposal/contract.py:839-841
    // # A category dependent weighted quorum of all xGov Voting Committee voting power (1 vote) is reached.
    // # Null votes affect this quorum.
    // weighted_quorum_bps = self.get_weighted_quorum(self.funding_category.value)
    intc_0 // 0
    bytec 6 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    swap
    dup
    cover 2
    frame_bury 1
    assert // check self.funding_category exists
    // smart_contracts/proposal/contract.py:308
    // if category == enm.FUNDING_CATEGORY_SMALL:
    intc_2 // 10
    ==
    bz scrutiny_else_body@22
    // smart_contracts/proposal/contract.py:310
    // Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_SMALL)
    pushbytes 0x77656967687465645f71756f72756d5f736d616c6c
    // smart_contracts/proposal/contract.py:309-311
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_SMALL)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0

scrutiny_after_if_else@26:
    // smart_contracts/proposal/contract.py:320
    // assert error == typ.Error(""), err.MISSING_CONFIG
    frame_dig 0
    bytec_0 // 0x0000
    ==
    assert // Missing Config
    // smart_contracts/proposal/contract.py:842
    // total_votes = self.approvals.value + self.rejections.value + self.nulls.value
    intc_0 // 0
    bytec 12 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    intc_0 // 0
    bytec 13 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    +
    intc_0 // 0
    bytec 16 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    +
    frame_bury 4
    // smart_contracts/proposal/contract.py:844
    // self.committee_votes.value, weighted_quorum_bps
    intc_0 // 0
    bytec 10 // 0x636f6d6d69747465655f766f746573
    app_global_get_ex
    assert // check self.committee_votes exists
    // smart_contracts/proposal/contract.py:423
    // return amount * fraction_in_bps // const.BPS
    *
    intc 4 // 10000
    /
    frame_bury 3
    // smart_contracts/proposal/contract.py:848
    // self.voted_members.value >= minimum_voters_required
    intc_0 // 0
    bytec 11 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    frame_dig 2
    >=
    // smart_contracts/proposal/contract.py:848-852
    // self.voted_members.value >= minimum_voters_required
    // and total_votes >= minimum_votes_required
    // # The relative majority of Approved over Rejected votes is reached.
    // # Null votes do not affect the relative majority.
    // and self.approvals.value > self.rejections.value
    bz scrutiny_else_body@4
    // smart_contracts/proposal/contract.py:849
    // and total_votes >= minimum_votes_required
    frame_dig 4
    frame_dig 3
    >=
    // smart_contracts/proposal/contract.py:848-852
    // self.voted_members.value >= minimum_voters_required
    // and total_votes >= minimum_votes_required
    // # The relative majority of Approved over Rejected votes is reached.
    // # Null votes do not affect the relative majority.
    // and self.approvals.value > self.rejections.value
    bz scrutiny_else_body@4
    // smart_contracts/proposal/contract.py:850-852
    // # The relative majority of Approved over Rejected votes is reached.
    // # Null votes do not affect the relative majority.
    // and self.approvals.value > self.rejections.value
    intc_0 // 0
    bytec 12 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    intc_0 // 0
    bytec 13 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    >
    // smart_contracts/proposal/contract.py:848-852
    // self.voted_members.value >= minimum_voters_required
    // and total_votes >= minimum_votes_required
    // # The relative majority of Approved over Rejected votes is reached.
    // # Null votes do not affect the relative majority.
    // and self.approvals.value > self.rejections.value
    bz scrutiny_else_body@4
    // smart_contracts/proposal/contract.py:854
    // self.status.value = UInt64(enm.STATUS_APPROVED)
    bytec_1 // 0x737461747573
    pushint 30 // 30
    app_global_put
    retsub

scrutiny_else_body@4:
    // smart_contracts/proposal/contract.py:856
    // self.status.value = UInt64(enm.STATUS_REJECTED)
    bytec_1 // 0x737461747573
    pushint 40 // 40
    app_global_put
    // smart_contracts/proposal/contract.py:858
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec 4 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:857-859
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount
    retsub

scrutiny_else_body@22:
    // smart_contracts/proposal/contract.py:312
    // elif category == enm.FUNDING_CATEGORY_MEDIUM:
    frame_dig 1
    intc_3 // 20
    ==
    bz scrutiny_else_body@24
    // smart_contracts/proposal/contract.py:314
    // Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_MEDIUM)
    pushbytes 0x77656967687465645f71756f72756d5f6d656469756d
    // smart_contracts/proposal/contract.py:313-315
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b scrutiny_after_if_else@26

scrutiny_else_body@24:
    // smart_contracts/proposal/contract.py:318
    // Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_LARGE)
    pushbytes 0x77656967687465645f71756f72756d5f6c61726765
    // smart_contracts/proposal/contract.py:317-319
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_WEIGHTED_QUORUM_LARGE)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b scrutiny_after_if_else@26

scrutiny_else_body@14:
    // smart_contracts/proposal/contract.py:295
    // elif category == enm.FUNDING_CATEGORY_MEDIUM:
    frame_dig 1
    intc_3 // 20
    ==
    bz scrutiny_else_body@16
    // smart_contracts/proposal/contract.py:297
    // Bytes(reg_cfg.GS_KEY_QUORUM_MEDIUM)
    pushbytes 0x71756f72756d5f6d656469756d
    // smart_contracts/proposal/contract.py:296-298
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_QUORUM_MEDIUM)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b scrutiny_after_if_else@18

scrutiny_else_body@16:
    // smart_contracts/proposal/contract.py:301
    // Bytes(reg_cfg.GS_KEY_QUORUM_LARGE)
    pushbytes 0x71756f72756d5f6c61726765
    // smart_contracts/proposal/contract.py:300-302
    // value, error = self.get_uint_from_registry_config(
    //     Bytes(reg_cfg.GS_KEY_QUORUM_LARGE)
    // )
    callsub get_uint_from_registry_config
    frame_bury 0
    b scrutiny_after_if_else@18

scrutiny_bool_false@9:
    intc_0 // 0
    b scrutiny_bool_merge@10


// smart_contracts.proposal.contract.Proposal.review(block: uint64) -> void:
review:
    // smart_contracts/proposal/contract.py:861-862
    // @arc4.abimethod()
    // def review(self, block: bool) -> None:  # noqa: FBT001
    proto 1 0
    // smart_contracts/proposal/contract.py:506
    // return Txn.sender == Account(
    txn Sender
    // smart_contracts/proposal/contract.py:507
    // self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_COUNCIL))
    pushbytes 0x78676f765f636f756e63696c
    callsub get_bytes_from_registry_config
    // smart_contracts/proposal/contract.py:506-508
    // return Txn.sender == Account(
    //     self.get_bytes_from_registry_config(Bytes(reg_cfg.GS_KEY_XGOV_COUNCIL))
    // )
    dup
    len
    pushint 32 // 32
    ==
    assert // Address length is 32 bytes
    ==
    // smart_contracts/proposal/contract.py:158
    // assert self.is_council(), err.UNAUTHORIZED
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:159
    // assert self.status.value == enm.STATUS_APPROVED, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 30 // 30
    ==
    assert // Wrong Proposal Status or finalized
    // smart_contracts/proposal/contract.py:876
    // if block:
    frame_dig -1
    bz review_else_body@2
    // smart_contracts/proposal/contract.py:877
    // self.status.value = UInt64(enm.STATUS_BLOCKED)
    bytec_1 // 0x737461747573
    pushint 60 // 60
    app_global_put
    // smart_contracts/proposal/contract.py:879-880
    // # slashing: send locked amount to the registry treasury
    // reg_app = Application(self.registry_app_id.value)
    intc_0 // 0
    bytec 5 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:882
    // receiver=reg_app.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/proposal/contract.py:881-883
    // self.transfer_locked_amount(
    //     receiver=reg_app.address,
    // )
    callsub transfer_locked_amount
    retsub

review_else_body@2:
    // smart_contracts/proposal/contract.py:886
    // self.status.value = UInt64(enm.STATUS_REVIEWED)
    bytec_1 // 0x737461747573
    pushint 45 // 45
    app_global_put
    retsub


// smart_contracts.proposal.contract.Proposal.fund() -> bytes:
fund:
    // smart_contracts/proposal/contract.py:888-889
    // @arc4.abimethod()
    // def fund(self) -> typ.Error:
    proto 0 1
    intc_0 // 0
    // smart_contracts/proposal/contract.py:163
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:164
    // if self.status.value != enm.STATUS_REVIEWED:
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 45 // 45
    !=
    bz fund_after_if_else@5
    // smart_contracts/proposal/contract.py:165
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 22 // 0x00264552523a57726f6e672050726f706f73616c20537461747573206f722066696e616c697a6564
    frame_bury 0

fund_after_inlined_smart_contracts.proposal.contract.Proposal.fund_check_authorization@6:
    // smart_contracts/proposal/contract.py:898
    // if error != typ.Error(""):
    frame_dig 0
    bytec_0 // 0x0000
    !=
    bz fund_after_if_else@2
    // smart_contracts/proposal/contract.py:899
    // return error
    frame_dig 0
    swap
    retsub

fund_after_if_else@2:
    // smart_contracts/proposal/contract.py:901
    // self.status.value = UInt64(enm.STATUS_FUNDED)
    bytec_1 // 0x737461747573
    pushint 50 // 50
    app_global_put
    // smart_contracts/proposal/contract.py:905
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec 4 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:903-906
    // # refund the locked amount to the proposer
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount
    // smart_contracts/proposal/contract.py:908
    // return typ.Error("")
    bytec_0 // 0x0000
    swap
    retsub

fund_after_if_else@5:
    // smart_contracts/proposal/contract.py:167
    // return typ.Error("")
    bytec_0 // 0x0000
    frame_bury 0
    // smart_contracts/proposal/contract.py:897
    // error = self.fund_check_authorization()
    b fund_after_inlined_smart_contracts.proposal.contract.Proposal.fund_check_authorization@6


// smart_contracts.proposal.contract.Proposal.unassign_voters(voters: bytes) -> void:
unassign_voters:
    // smart_contracts/proposal/contract.py:910-911
    // @arc4.abimethod()
    // def unassign_voters(self, voters: arc4.DynamicArray[arc4.Address]) -> None:
    proto 1 0
    intc_0 // 0
    bytec_2 // ""
    dupn 3
    // smart_contracts/proposal/contract.py:171
    // if self.status.value == enm.STATUS_SUBMITTED:
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_3 // 20
    ==
    bz unassign_voters_else_body@16
    // smart_contracts/proposal/contract.py:172
    // assert self.is_xgov_daemon(), err.UNAUTHORIZED
    callsub is_xgov_daemon
    assert // Unauthorized

unassign_voters_after_if_else@23:
    // smart_contracts/proposal/contract.py:926
    // if Txn.group_index == 0:
    txn GroupIndex
    bnz unassign_voters_else_body@6
    // smart_contracts/proposal/contract.py:927-928
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    global GroupSize
    frame_bury 4
    intc_1 // 1
    frame_bury 2

unassign_voters_for_header@2:
    // smart_contracts/proposal/contract.py:927-928
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    frame_dig 2
    frame_dig 4
    <
    bz unassign_voters_after_if_else@7
    // smart_contracts/proposal/contract.py:929
    // self.assert_same_app_and_method(i)
    frame_dig 2
    dup
    callsub assert_same_app_and_method
    // smart_contracts/proposal/contract.py:927-928
    // # Check that the entire group calls the same app and method
    // for i in urange(1, Global.group_size):
    intc_1 // 1
    +
    frame_bury 2
    b unassign_voters_for_header@2

unassign_voters_after_if_else@7:
    // smart_contracts/proposal/contract.py:934-935
    // # remove voters
    // for voter in voters:
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_bury 1
    intc_0 // 0
    frame_bury 3

unassign_voters_for_header@8:
    // smart_contracts/proposal/contract.py:934-935
    // # remove voters
    // for voter in voters:
    frame_dig 3
    frame_dig 1
    <
    bz unassign_voters_after_for@13
    frame_dig -1
    extract 2 0
    frame_dig 3
    pushint 32 // 32
    *
    pushint 32 // 32
    extract3 // on error: Index access is out of bounds
    // smart_contracts/proposal/contract.py:936
    // if voter.native in self.voters:
    bytec 29 // "V"
    swap
    concat
    dup
    frame_bury 0
    box_len
    bury 1
    bz unassign_voters_after_if_else@11
    // smart_contracts/proposal/contract.py:937
    // self.voters_count -= 1
    intc_0 // 0
    bytec 9 // "voters_count"
    app_global_get_ex
    assert // check self.voters_count exists
    intc_1 // 1
    -
    bytec 9 // "voters_count"
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:938
    // self.assigned_votes -= self.voters[voter.native].votes.native
    intc_0 // 0
    bytec 14 // "assigned_votes"
    app_global_get_ex
    assert // check self.assigned_votes exists
    frame_dig 0
    dup
    cover 2
    box_get
    assert // check self.voters entry exists
    intc_0 // 0
    extract_uint64
    -
    bytec 14 // "assigned_votes"
    swap
    app_global_put
    // smart_contracts/proposal/contract.py:939
    // del self.voters[voter.native]
    box_del
    pop

unassign_voters_after_if_else@11:
    frame_dig 3
    intc_1 // 1
    +
    frame_bury 3
    b unassign_voters_for_header@8

unassign_voters_after_for@13:
    retsub

unassign_voters_else_body@6:
    // smart_contracts/proposal/contract.py:931-932
    // # Check that the first transaction in the group calls the same app and method
    // self.assert_same_app_and_method(UInt64(0))
    intc_0 // 0
    callsub assert_same_app_and_method
    b unassign_voters_after_if_else@7

unassign_voters_else_body@16:
    // smart_contracts/proposal/contract.py:175
    // self.status.value == enm.STATUS_FUNDED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 50 // 50
    ==
    // smart_contracts/proposal/contract.py:175-177
    // self.status.value == enm.STATUS_FUNDED
    // or self.status.value == enm.STATUS_BLOCKED
    // or self.status.value == enm.STATUS_REJECTED
    bnz unassign_voters_and_contd@19
    // smart_contracts/proposal/contract.py:176
    // or self.status.value == enm.STATUS_BLOCKED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 60 // 60
    ==
    // smart_contracts/proposal/contract.py:175-177
    // self.status.value == enm.STATUS_FUNDED
    // or self.status.value == enm.STATUS_BLOCKED
    // or self.status.value == enm.STATUS_REJECTED
    bnz unassign_voters_and_contd@19
    // smart_contracts/proposal/contract.py:177
    // or self.status.value == enm.STATUS_REJECTED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 40 // 40
    ==
    // smart_contracts/proposal/contract.py:175-177
    // self.status.value == enm.STATUS_FUNDED
    // or self.status.value == enm.STATUS_BLOCKED
    // or self.status.value == enm.STATUS_REJECTED
    bz unassign_voters_bool_false@21

unassign_voters_and_contd@19:
    // smart_contracts/proposal/contract.py:178
    // ) and not self.finalized.value, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_3 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    bnz unassign_voters_bool_false@21
    intc_1 // 1

unassign_voters_bool_merge@22:
    // smart_contracts/proposal/contract.py:174-178
    // assert (
    //     self.status.value == enm.STATUS_FUNDED
    //     or self.status.value == enm.STATUS_BLOCKED
    //     or self.status.value == enm.STATUS_REJECTED
    // ) and not self.finalized.value, err.WRONG_PROPOSAL_STATUS
    assert // Wrong Proposal Status or finalized
    b unassign_voters_after_if_else@23

unassign_voters_bool_false@21:
    intc_0 // 0
    b unassign_voters_bool_merge@22


// smart_contracts.proposal.contract.Proposal.finalize() -> bytes:
finalize:
    // smart_contracts/proposal/contract.py:941-942
    // @arc4.abimethod()
    // def finalize(self) -> typ.Error:
    proto 0 1
    intc_0 // 0
    // smart_contracts/proposal/contract.py:182
    // assert self.is_registry_call(), err.UNAUTHORIZED
    callsub is_registry_call
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:184
    // if self.finalized.value or (
    intc_0 // 0
    bytec_3 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    // smart_contracts/proposal/contract.py:184-190
    // if self.finalized.value or (
    //     self.status.value != enm.STATUS_EMPTY
    //     and self.status.value != enm.STATUS_DRAFT
    //     and self.status.value != enm.STATUS_FUNDED
    //     and self.status.value != enm.STATUS_BLOCKED
    //     and self.status.value != enm.STATUS_REJECTED
    // ):
    bnz finalize_if_body@13
    // smart_contracts/proposal/contract.py:185
    // self.status.value != enm.STATUS_EMPTY
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    // smart_contracts/proposal/contract.py:185-189
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz finalize_after_if_else@14
    // smart_contracts/proposal/contract.py:186
    // and self.status.value != enm.STATUS_DRAFT
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_2 // 10
    !=
    // smart_contracts/proposal/contract.py:185-189
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz finalize_after_if_else@14
    // smart_contracts/proposal/contract.py:187
    // and self.status.value != enm.STATUS_FUNDED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 50 // 50
    !=
    // smart_contracts/proposal/contract.py:185-189
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz finalize_after_if_else@14
    // smart_contracts/proposal/contract.py:188
    // and self.status.value != enm.STATUS_BLOCKED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 60 // 60
    !=
    // smart_contracts/proposal/contract.py:185-189
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz finalize_after_if_else@14
    // smart_contracts/proposal/contract.py:189
    // and self.status.value != enm.STATUS_REJECTED
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    pushint 40 // 40
    !=
    // smart_contracts/proposal/contract.py:185-189
    // self.status.value != enm.STATUS_EMPTY
    // and self.status.value != enm.STATUS_DRAFT
    // and self.status.value != enm.STATUS_FUNDED
    // and self.status.value != enm.STATUS_BLOCKED
    // and self.status.value != enm.STATUS_REJECTED
    bz finalize_after_if_else@14

finalize_if_body@13:
    // smart_contracts/proposal/contract.py:191
    // return typ.Error(err.ARC_65_PREFIX + err.WRONG_PROPOSAL_STATUS)
    bytec 22 // 0x00264552523a57726f6e672050726f706f73616c20537461747573206f722066696e616c697a6564
    frame_bury 0

finalize_after_inlined_smart_contracts.proposal.contract.Proposal.finalize_check_authorization@15:
    // smart_contracts/proposal/contract.py:953
    // if error != typ.Error(""):
    frame_dig 0
    bytec_0 // 0x0000
    !=
    bz finalize_after_if_else@2
    // smart_contracts/proposal/contract.py:954
    // return error
    frame_dig 0
    swap
    retsub

finalize_after_if_else@2:
    // smart_contracts/proposal/contract.py:956-957
    // # check no assigned voters
    // if self.voters_count > UInt64(0):
    intc_0 // 0
    bytec 9 // "voters_count"
    app_global_get_ex
    assert // check self.voters_count exists
    bz finalize_after_if_else@4
    // smart_contracts/proposal/contract.py:958
    // return typ.Error(err.ARC_65_PREFIX + err.VOTERS_ASSIGNED)
    pushbytes 0x002e4552523a54686572652061726520766f746572732061737369676e656420746f20746869732070726f706f73616c
    swap
    retsub

finalize_after_if_else@4:
    // smart_contracts/proposal/contract.py:960-963
    // # refund the locked amount for DRAFT proposals
    // # for REJECTED proposals, the locked amount is already refunded in the scrutiny method
    // # for EMPTY, FUNDED, or BLOCKED proposals, the locked amount is not refundable
    // if self.status.value == enm.STATUS_DRAFT:
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    intc_2 // 10
    ==
    bz finalize_after_if_else@6
    // smart_contracts/proposal/contract.py:965
    // receiver=self.proposer.value,
    intc_0 // 0
    bytec 4 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:964-966
    // self.transfer_locked_amount(
    //     receiver=self.proposer.value,
    // )
    callsub transfer_locked_amount

finalize_after_if_else@6:
    // smart_contracts/proposal/contract.py:967
    // reg_app = Application(self.registry_app_id.value)
    intc_0 // 0
    bytec 5 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:969
    // receiver=reg_app.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/proposal/contract.py:970
    // amount=Global.current_application_address.balance
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/proposal/contract.py:971
    // - Global.current_application_address.min_balance,
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/proposal/contract.py:970-971
    // amount=Global.current_application_address.balance
    // - Global.current_application_address.min_balance,
    -
    // smart_contracts/proposal/contract.py:968-972
    // self.pay(
    //     receiver=reg_app.address,
    //     amount=Global.current_application_address.balance
    //     - Global.current_application_address.min_balance,
    // )
    callsub pay
    // smart_contracts/proposal/contract.py:973
    // self.finalized.value = True
    bytec_3 // 0x66696e616c697a6564
    intc_1 // 1
    app_global_put
    // smart_contracts/proposal/contract.py:975
    // return typ.Error("")
    bytec_0 // 0x0000
    swap
    retsub

finalize_after_if_else@14:
    // smart_contracts/proposal/contract.py:193
    // return typ.Error("")
    bytec_0 // 0x0000
    frame_bury 0
    // smart_contracts/proposal/contract.py:952
    // error = self.finalize_check_authorization()
    b finalize_after_inlined_smart_contracts.proposal.contract.Proposal.finalize_check_authorization@15


// smart_contracts.proposal.contract.Proposal.delete() -> void:
delete:
    // smart_contracts/proposal/contract.py:197
    // assert self.is_xgov_daemon(), err.UNAUTHORIZED
    callsub is_xgov_daemon
    assert // Unauthorized
    // smart_contracts/proposal/contract.py:198
    // assert self.finalized.value, err.WRONG_PROPOSAL_STATUS
    intc_0 // 0
    bytec_3 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    assert // Wrong Proposal Status or finalized
    // smart_contracts/proposal/contract.py:989-990
    // # delete metadata box if it exists
    // self.metadata.delete()
    bytec 7 // "M"
    box_del
    pop
    // smart_contracts/proposal/contract.py:992
    // reg_app = Application(self.registry_app_id.value)
    intc_0 // 0
    bytec 5 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    // smart_contracts/proposal/contract.py:994
    // receiver=reg_app.address,
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/proposal/contract.py:995
    // amount=Global.current_application_address.balance,
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/proposal/contract.py:993-996
    // self.pay(
    //     receiver=reg_app.address,
    //     amount=Global.current_application_address.balance,
    // )
    callsub pay
    retsub


// smart_contracts.proposal.contract.Proposal.get_state() -> bytes:
get_state:
    // smart_contracts/proposal/contract.py:1007
    // proposer=arc4.Address(self.proposer.value),
    intc_0 // 0
    bytec 4 // 0x70726f706f736572
    app_global_get_ex
    assert // check self.proposer exists
    // smart_contracts/proposal/contract.py:1008
    // registry_app_id=arc4.UInt64(self.registry_app_id.value),
    intc_0 // 0
    bytec 5 // 0x72656769737472795f6170705f6964
    app_global_get_ex
    assert // check self.registry_app_id exists
    itob
    // smart_contracts/proposal/contract.py:1009
    // title=arc4.String(self.title.value),
    intc_0 // 0
    bytec 23 // 0x7469746c65
    app_global_get_ex
    assert // check self.title exists
    dup
    len
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/proposal/contract.py:1010
    // open_ts=arc4.UInt64(self.open_ts.value),
    intc_0 // 0
    bytec 19 // 0x6f70656e5f74696d657374616d70
    app_global_get_ex
    assert // check self.open_ts exists
    itob
    // smart_contracts/proposal/contract.py:1011
    // submission_ts=arc4.UInt64(self.submission_ts.value),
    intc_0 // 0
    bytec 24 // 0x7375626d697373696f6e5f74696d657374616d70
    app_global_get_ex
    assert // check self.submission_ts exists
    itob
    // smart_contracts/proposal/contract.py:1012
    // vote_open_ts=arc4.UInt64(self.vote_open_ts.value),
    intc_0 // 0
    bytec 20 // 0x766f74655f6f70656e696e675f74696d657374616d70
    app_global_get_ex
    assert // check self.vote_open_ts exists
    itob
    // smart_contracts/proposal/contract.py:1013
    // status=arc4.UInt64(self.status.value),
    intc_0 // 0
    bytec_1 // 0x737461747573
    app_global_get_ex
    assert // check self.status exists
    itob
    // smart_contracts/proposal/contract.py:1014
    // finalized=arc4.Bool(self.finalized.value),
    intc_0 // 0
    bytec_3 // 0x66696e616c697a6564
    app_global_get_ex
    assert // check self.finalized exists
    bytec 18 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    // smart_contracts/proposal/contract.py:1015
    // funding_category=arc4.UInt64(self.funding_category.value),
    intc_0 // 0
    bytec 6 // 0x66756e64696e675f63617465676f7279
    app_global_get_ex
    assert // check self.funding_category exists
    itob
    // smart_contracts/proposal/contract.py:1016
    // focus=arc4.UInt8(self.focus.value),
    intc_0 // 0
    bytec 25 // 0x666f637573
    app_global_get_ex
    assert // check self.focus exists
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/proposal/contract.py:1017
    // funding_type=arc4.UInt64(self.funding_type.value),
    intc_0 // 0
    bytec 26 // 0x66756e64696e675f74797065
    app_global_get_ex
    assert // check self.funding_type exists
    itob
    // smart_contracts/proposal/contract.py:1018
    // requested_amount=arc4.UInt64(self.requested_amount.value),
    intc_0 // 0
    bytec 27 // 0x7265717565737465645f616d6f756e74
    app_global_get_ex
    assert // check self.requested_amount exists
    itob
    // smart_contracts/proposal/contract.py:1019
    // locked_amount=arc4.UInt64(self.locked_amount.value),
    intc_0 // 0
    bytec 15 // 0x6c6f636b65645f616d6f756e74
    app_global_get_ex
    assert // check self.locked_amount exists
    itob
    // smart_contracts/proposal/contract.py:1020
    // committee_id=self.committee_id.value.copy(),
    intc_0 // 0
    bytec 21 // 0x636f6d6d69747465655f6964
    app_global_get_ex
    assert // check self.committee_id exists
    // smart_contracts/proposal/contract.py:1021
    // committee_members=arc4.UInt64(self.committee_members.value),
    intc_0 // 0
    bytec 8 // 0x636f6d6d69747465655f6d656d62657273
    app_global_get_ex
    assert // check self.committee_members exists
    itob
    // smart_contracts/proposal/contract.py:1022
    // committee_votes=arc4.UInt64(self.committee_votes.value),
    intc_0 // 0
    bytec 10 // 0x636f6d6d69747465655f766f746573
    app_global_get_ex
    assert // check self.committee_votes exists
    itob
    // smart_contracts/proposal/contract.py:1023
    // voted_members=arc4.UInt64(self.voted_members.value),
    intc_0 // 0
    bytec 11 // 0x766f7465645f6d656d62657273
    app_global_get_ex
    assert // check self.voted_members exists
    itob
    // smart_contracts/proposal/contract.py:1024
    // approvals=arc4.UInt64(self.approvals.value),
    intc_0 // 0
    bytec 12 // 0x617070726f76616c73
    app_global_get_ex
    assert // check self.approvals exists
    itob
    // smart_contracts/proposal/contract.py:1025
    // rejections=arc4.UInt64(self.rejections.value),
    intc_0 // 0
    bytec 13 // 0x72656a656374696f6e73
    app_global_get_ex
    assert // check self.rejections exists
    itob
    // smart_contracts/proposal/contract.py:1026
    // nulls=arc4.UInt64(self.nulls.value),
    intc_0 // 0
    bytec 16 // 0x6e756c6c73
    app_global_get_ex
    assert // check self.nulls exists
    itob
    // smart_contracts/proposal/contract.py:1006-1027
    // return typ.ProposalTypedGlobalState(
    //     proposer=arc4.Address(self.proposer.value),
    //     registry_app_id=arc4.UInt64(self.registry_app_id.value),
    //     title=arc4.String(self.title.value),
    //     open_ts=arc4.UInt64(self.open_ts.value),
    //     submission_ts=arc4.UInt64(self.submission_ts.value),
    //     vote_open_ts=arc4.UInt64(self.vote_open_ts.value),
    //     status=arc4.UInt64(self.status.value),
    //     finalized=arc4.Bool(self.finalized.value),
    //     funding_category=arc4.UInt64(self.funding_category.value),
    //     focus=arc4.UInt8(self.focus.value),
    //     funding_type=arc4.UInt64(self.funding_type.value),
    //     requested_amount=arc4.UInt64(self.requested_amount.value),
    //     locked_amount=arc4.UInt64(self.locked_amount.value),
    //     committee_id=self.committee_id.value.copy(),
    //     committee_members=arc4.UInt64(self.committee_members.value),
    //     committee_votes=arc4.UInt64(self.committee_votes.value),
    //     voted_members=arc4.UInt64(self.voted_members.value),
    //     approvals=arc4.UInt64(self.approvals.value),
    //     rejections=arc4.UInt64(self.rejections.value),
    //     nulls=arc4.UInt64(self.nulls.value),
    // )
    uncover 19
    uncover 19
    concat
    pushbytes 0x00bc
    concat
    uncover 17
    concat
    uncover 16
    concat
    uncover 15
    concat
    uncover 14
    concat
    uncover 13
    concat
    uncover 12
    concat
    uncover 11
    concat
    uncover 10
    concat
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    swap
    concat
    retsub
