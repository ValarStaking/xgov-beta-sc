diff --git a/.github/workflows/xgov-beta-sc-cd.yml b/.github/workflows/xgov-beta-sc-cd.yml
index f6dbc9a..6649704 100644
--- a/.github/workflows/xgov-beta-sc-cd.yml
+++ b/.github/workflows/xgov-beta-sc-cd.yml
@@ -6,23 +6,27 @@ on:
       fresh-deploy:
         description: "Deploy fresh contract"
         required: false
-        default: "false"
+        default: false
         type: boolean
       xgov-reg-configure:
         description: "Configure xgov-reg contract"
         required: false
-        default: "false"
+        default: false
         type: boolean
       xgov-reg-set-roles:
         description: "Set roles in xgov-reg contract"
         required: false
-        default: "true"
+        default: true
         type: boolean
   workflow_call:
   push:
     branches:
       - main
 
+permissions:
+  id-token: write
+  contents: read
+
 jobs:
   validate:
     name: Validate xgov-beta-sc
@@ -138,7 +142,13 @@ jobs:
         env:
           # Deploy command to run
           XGOV_REG_DEPLOY_COMMAND: deploy
-          # This is the account that becomes the creator of the contract
+          # Vault configuration for transaction signing
+          VAULT_URL: ${{ secrets.VAULT_URL }}
+          VAULT_OIDC_ROLE: ${{ secrets.VAULT_ROLE_TESTNET }}
+          VAULT_OIDC_MOUNT_PATH: ${{ secrets.VAULT_OIDC_MOUNT_PATH || 'oidc' }}
+          VAULT_KEY_NAME: ${{ secrets.VAULT_KEY_NAME_TESTNET }}
+          VAULT_NAMESPACE: ${{ secrets.VAULT_NAMESPACE }}
+          # The deployer account
           DEPLOYER_MNEMONIC: ${{ secrets.DEPLOYER_MNEMONIC }}
           # The dispenser account is used to ensure the deployer account is funded
           DISPENSER_MNEMONIC: ${{ secrets.DISPENSER_MNEMONIC }}
diff --git a/.github/workflows/xgov-beta-sc-ci.yml b/.github/workflows/xgov-beta-sc-ci.yml
index 9ff1249..769d0f4 100644
--- a/.github/workflows/xgov-beta-sc-ci.yml
+++ b/.github/workflows/xgov-beta-sc-ci.yml
@@ -10,6 +10,9 @@ on:
     # * is a special character in YAML so you have to quote this string
     - cron: "0 0 1 * *" # Run once a month at midnight on the 1st of the month
 
+permissions:
+  id-token: write
+
 jobs:
   validate-xgov-beta-sc:
     runs-on: "ubuntu-latest"
diff --git a/.github/workflows/xgov-beta-sc-configure-registry.yml b/.github/workflows/xgov-beta-sc-configure-registry.yml
index 55b2339..1aa786d 100644
--- a/.github/workflows/xgov-beta-sc-configure-registry.yml
+++ b/.github/workflows/xgov-beta-sc-configure-registry.yml
@@ -28,6 +28,10 @@ on:
         default: "{}"
         type: string
 
+permissions:
+  id-token: write
+  contents: read
+
 jobs:
   configure-xgov-beta-sc-registry:
     runs-on: ubuntu-latest
@@ -67,7 +71,13 @@ jobs:
         env:
           # Deploy command to run
           XGOV_REG_DEPLOY_COMMAND: configure_xgov_registry
-          # This is the account that becomes the creator of the contract
+          # Vault configuration for transaction signing
+          VAULT_URL: ${{ secrets.VAULT_URL }}
+          VAULT_OIDC_ROLE: ${{ github.event.inputs.network == 'mainnet' && secrets.VAULT_ROLE_MAINNET || secrets.VAULT_ROLE_TESTNET }}
+          VAULT_OIDC_MOUNT_PATH: ${{ secrets.VAULT_MOUNT_PATH || 'oidc' }}
+          VAULT_KEY_NAME: ${{ github.event.inputs.network == 'mainnet' && secrets.VAULT_KEY_NAME_MAINNET || secrets.VAULT_KEY_NAME_TESTNET }}
+          VAULT_NAMESPACE: ${{ secrets.VAULT_NAMESPACE }}
+          # The deployer account
           DEPLOYER_MNEMONIC: ${{ secrets.DEPLOYER_MNEMONIC }}
           # The dispenser account is used to ensure the deployer account is funded
           DISPENSER_MNEMONIC: ${{ secrets.DISPENSER_MNEMONIC }}
diff --git a/.github/workflows/xgov-beta-sc-release.yml b/.github/workflows/xgov-beta-sc-release.yml
index e266dff..3481a32 100644
--- a/.github/workflows/xgov-beta-sc-release.yml
+++ b/.github/workflows/xgov-beta-sc-release.yml
@@ -6,6 +6,10 @@ on:
     branches:
       - main
 
+permissions:
+  id-token: write
+  contents: read
+
 jobs:
   create-stable-release:
     runs-on: ubuntu-latest
@@ -82,7 +86,13 @@ jobs:
         env:
           # Deploy command to run
           XGOV_REG_DEPLOY_COMMAND: deploy
-          # This is the account that becomes the creator of the contract
+          # Vault configuration for transaction signing
+          VAULT_URL: ${{ secrets.VAULT_URL }}
+          VAULT_OIDC_ROLE: ${{ secrets.VAULT_ROLE_MAINNET }}
+          VAULT_OIDC_MOUNT_PATH: ${{ secrets.VAULT_MOUNT_PATH || 'oidc' }}
+          VAULT_KEY_NAME: ${{ secrets.VAULT_KEY_NAME_MAINNET }}
+          VAULT_NAMESPACE: ${{ secrets.VAULT_NAMESPACE }}
+          # The deployer account
           DEPLOYER_MNEMONIC: ${{ secrets.DEPLOYER_MNEMONIC }}
           # The dispenser account is used to ensure the deployer account is funded
           DISPENSER_MNEMONIC: ${{ secrets.DISPENSER_MNEMONIC }}
diff --git a/.github/workflows/xgov-beta-sc-set-roles.yml b/.github/workflows/xgov-beta-sc-set-roles.yml
index a03c172..314613a 100644
--- a/.github/workflows/xgov-beta-sc-set-roles.yml
+++ b/.github/workflows/xgov-beta-sc-set-roles.yml
@@ -44,6 +44,10 @@ on:
         default: ""
         type: string
 
+permissions:
+  id-token: write
+  contents: read
+
 jobs:
   set-roles:
     runs-on: ubuntu-latest
@@ -60,7 +64,13 @@ jobs:
         env:
           # Deploy command to run
           XGOV_REG_DEPLOY_COMMAND: set_roles
-          # This is the account that becomes the creator of the contract
+          # Vault configuration for transaction signing
+          VAULT_URL: ${{ secrets.VAULT_URL }}
+          VAULT_OIDC_ROLE: ${{ github.event.inputs.network == 'mainnet' && secrets.VAULT_ROLE_MAINNET || secrets.VAULT_ROLE_TESTNET }}
+          VAULT_OIDC_MOUNT_PATH: ${{ secrets.VAULT_OIDC_MOUNT_PATH || 'oidc' }}
+          VAULT_KEY_NAME: ${{ github.event.inputs.network == 'mainnet' && secrets.VAULT_KEY_NAME_MAINNET || secrets.VAULT_KEY_NAME_TESTNET }}
+          VAULT_NAMESPACE: ${{ secrets.VAULT_NAMESPACE }}
+          # The deployer account
           DEPLOYER_MNEMONIC: ${{ secrets.DEPLOYER_MNEMONIC }}
           # The dispenser account is used to ensure the deployer account is funded
           DISPENSER_MNEMONIC: ${{ secrets.DISPENSER_MNEMONIC }}
@@ -72,4 +82,3 @@ jobs:
           XGOV_REG_SET_ROLES_KYC_PROVIDER: ${{ github.event.inputs.kyc_provider }}
           XGOV_REG_SET_ROLES_COMMITTEE_MANAGER: ${{ github.event.inputs.committee_manager }}
           XGOV_REG_SET_ROLES_XGOV_DAEMON: ${{ github.event.inputs.xgov_daemon }}
-
diff --git a/poetry.lock b/poetry.lock
index 1158df9..c77e924 100644
--- a/poetry.lock
+++ b/poetry.lock
@@ -440,7 +440,7 @@ version = "3.4.2"
 description = "The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet."
 optional = false
 python-versions = ">=3.7"
-groups = ["dev"]
+groups = ["main", "dev"]
 files = [
     {file = "charset_normalizer-3.4.2-cp310-cp310-macosx_10_9_universal2.whl", hash = "sha256:7c48ed483eb946e6c04ccbe02c6b4d1d48e51944b6db70f697e089c193404941"},
     {file = "charset_normalizer-3.4.2-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:b2d318c11350e10662026ad0eb71bb51c7812fc8590825304ae0bdd4ac283acd"},
@@ -558,7 +558,7 @@ description = "Cross-platform colored terminal text."
 optional = false
 python-versions = "!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*,!=3.5.*,!=3.6.*,>=2.7"
 groups = ["dev"]
-markers = "sys_platform == \"win32\" or platform_system == \"Windows\""
+markers = "platform_system == \"Windows\" or sys_platform == \"win32\""
 files = [
     {file = "colorama-0.4.6-py2.py3-none-any.whl", hash = "sha256:4f1d9991f5acc0ca119f9d443620b77f9d6b33703e51011c16baf57afb285fc6"},
     {file = "colorama-0.4.6.tar.gz", hash = "sha256:08695f5cb7ed6e0531a20572697297273c47b8cae5a63ffc6d6ed5c201be6e44"},
@@ -898,6 +898,24 @@ http2 = ["h2 (>=3,<5)"]
 socks = ["socksio (==1.*)"]
 zstd = ["zstandard (>=0.18.0)"]
 
+[[package]]
+name = "hvac"
+version = "2.3.0"
+description = "HashiCorp Vault API client"
+optional = false
+python-versions = "<4.0,>=3.8"
+groups = ["main"]
+files = [
+    {file = "hvac-2.3.0-py3-none-any.whl", hash = "sha256:a3afc5710760b6ee9b3571769df87a0333da45da05a5f9f963e1d3925a84be7d"},
+    {file = "hvac-2.3.0.tar.gz", hash = "sha256:1b85e3320e8642dd82f234db63253cda169a817589e823713dc5fca83119b1e2"},
+]
+
+[package.dependencies]
+requests = ">=2.27.1,<3.0.0"
+
+[package.extras]
+parser = ["pyhcl (>=0.4.4,<0.5.0)"]
+
 [[package]]
 name = "identify"
 version = "2.6.12"
@@ -1345,14 +1363,14 @@ files = [
 
 [[package]]
 name = "pip"
-version = "25.2"
+version = "25.1.1"
 description = "The PyPA recommended tool for installing Python packages."
 optional = false
 python-versions = ">=3.9"
 groups = ["dev"]
 files = [
-    {file = "pip-25.2-py3-none-any.whl", hash = "sha256:6d67a2b4e7f14d8b31b8b52648866fa717f45a1eb70e83002f4331d07e953717"},
-    {file = "pip-25.2.tar.gz", hash = "sha256:578283f006390f85bb6282dffb876454593d637f5d1be494b5202ce4877e71f2"},
+    {file = "pip-25.1.1-py3-none-any.whl", hash = "sha256:2913a38a2abf4ea6b64ab507bd9e967f3b53dc1ede74b01b0931e1ce548751af"},
+    {file = "pip-25.1.1.tar.gz", hash = "sha256:3de45d411d308d5054c2168185d8da7f9a2cd753dbac8acbfa88a8909ecd9077"},
 ]
 
 [[package]]
@@ -1912,7 +1930,7 @@ version = "2.32.4"
 description = "Python HTTP for Humans."
 optional = false
 python-versions = ">=3.8"
-groups = ["dev"]
+groups = ["main", "dev"]
 files = [
     {file = "requests-2.32.4-py3-none-any.whl", hash = "sha256:27babd3cda2a6d50b30443204ee89830707d396671944c998b5975b031ac2b2c"},
     {file = "requests-2.32.4.tar.gz", hash = "sha256:27d0316682c8a29834d3264820024b62a36942083d52caf2f14c0591336d3422"},
@@ -2039,6 +2057,36 @@ files = [
     {file = "toml-0.10.2.tar.gz", hash = "sha256:b3bda1d108d5dd99f4a20d24d9c348e91c4db7ab1b749200bded2f839ccbe68f"},
 ]
 
+[[package]]
+name = "types-hvac"
+version = "2.3.0.20250914"
+description = "Typing stubs for hvac"
+optional = false
+python-versions = ">=3.9"
+groups = ["main"]
+files = [
+    {file = "types_hvac-2.3.0.20250914-py3-none-any.whl", hash = "sha256:b5553d84abe95e0709a9b76fd87cfe06edf3b9959c528bc26ff7cf4dfd5e4e1a"},
+    {file = "types_hvac-2.3.0.20250914.tar.gz", hash = "sha256:ac7e72fa014c2b21d8856408dbc7ac16ffb0f4cf567b8c8cd61aa9848ec8f194"},
+]
+
+[package.dependencies]
+types-requests = "*"
+
+[[package]]
+name = "types-requests"
+version = "2.32.4.20250913"
+description = "Typing stubs for requests"
+optional = false
+python-versions = ">=3.9"
+groups = ["main"]
+files = [
+    {file = "types_requests-2.32.4.20250913-py3-none-any.whl", hash = "sha256:78c9c1fffebbe0fa487a418e0fa5252017e9c60d1a2da394077f1780f655d7e1"},
+    {file = "types_requests-2.32.4.20250913.tar.gz", hash = "sha256:abd6d4f9ce3a9383f269775a9835a4c24e5cd6b9f647d64f88aa4613c33def5d"},
+]
+
+[package.dependencies]
+urllib3 = ">=2"
+
 [[package]]
 name = "typing-extensions"
 version = "4.14.1"
@@ -2057,7 +2105,7 @@ version = "2.5.0"
 description = "HTTP library with thread-safe connection pooling, file post, and more."
 optional = false
 python-versions = ">=3.9"
-groups = ["dev"]
+groups = ["main", "dev"]
 files = [
     {file = "urllib3-2.5.0-py3-none-any.whl", hash = "sha256:e6b01673c0fa6a13e374b50871808eb3bf7046c4b125b216f6bf1cc604cff0dc"},
     {file = "urllib3-2.5.0.tar.gz", hash = "sha256:3fc47733c7e419d4bc3f6b3dc2b4f890bb743906a30d56ba4a5bfa4bbff92760"},
@@ -2212,4 +2260,4 @@ propcache = ">=0.2.1"
 [metadata]
 lock-version = "2.1"
 python-versions = "^3.12"
-content-hash = "066cf2d6d99079c54c33ffa36e1c6573931bd2a246fb00444c76b889fa549063"
+content-hash = "afe338c5c120adbeeb5d3ef4b3aa3fd0c02cf3fe5574182475fd9cdb7b232c18"
diff --git a/pyproject.toml b/pyproject.toml
index 5e18b4b..92df90d 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -15,6 +15,8 @@ algokit-utils = "^4.2.0"
 python-dotenv = "^1.1.1"
 algorand-python = "==2.9.0"
 poetry-core = "^2.1.3"
+types-hvac = "^2.3.0.20250809"
+hvac = "^2.3.0"
 
 [tool.poetry.group.dev.dependencies]
 algokit-client-generator = "^2.2.0"
diff --git a/smart_contracts/__main__.py b/smart_contracts/__main__.py
index 8e51de8..a2e70ab 100644
--- a/smart_contracts/__main__.py
+++ b/smart_contracts/__main__.py
@@ -160,6 +160,7 @@ def build(output_dir: Path, contract_path: Path) -> Path:
 
 
 def main(action: str, contract_name: str | None = None) -> None:
+    logger.info(f"Action: {action}, Contract: {contract_name or 'all'}")
     """Main entry point to build and/or deploy smart contracts."""
     artifact_path = root_path / "artifacts"
     # Filter contracts based on an optional specific contract name.
@@ -175,7 +176,11 @@ def main(action: str, contract_name: str | None = None) -> None:
                 logger.info(f"Building app at {contract.path}")
                 build(artifact_path / contract.name, contract.path)
         case "deploy":
+            logger.info(
+                f"Deploying contracts... {[c.name for c in filtered_contracts]}"
+            )
             for contract in filtered_contracts:
+                logger.info(f"Building app at {contract.path}")
                 output_dir = artifact_path / contract.name
                 app_spec_file_name = next(
                     (
@@ -186,7 +191,11 @@ def main(action: str, contract_name: str | None = None) -> None:
                     None,
                 )
                 if app_spec_file_name is None:
+                    logger.info(
+                        f"No .arc56.json file found for {contract.name}, building first..."
+                    )
                     raise Exception("Could not deploy app, .arc56.json file not found")
+                logger.info(f"Found {app_spec_file_name} for {contract.name}")
                 if contract.deploy:
                     logger.info(f"Deploying app {contract.name}")
                     contract.deploy()
diff --git a/smart_contracts/xgov_registry/deploy_config.py b/smart_contracts/xgov_registry/deploy_config.py
index e02638a..6e739f3 100644
--- a/smart_contracts/xgov_registry/deploy_config.py
+++ b/smart_contracts/xgov_registry/deploy_config.py
@@ -1,6 +1,7 @@
 import logging
 import os
 import random
+from typing import Optional
 
 from algokit_utils import (
     AlgoAmount,
@@ -11,11 +12,19 @@ from algokit_utils import (
     OnSchemaBreak,
     OnUpdate,
 )
+from algosdk import encoding
+from algosdk.transaction import Multisig
 
 from smart_contracts.artifacts.proposal.proposal_client import ProposalFactory
 from smart_contracts.xgov_registry.helpers import (
     load_proposal_contract_data_size_per_transaction,
 )
+from smart_contracts.xgov_registry.vault_tx_signer import (
+    HashicorpVaultMultisigTransactionSigner,
+    TransitSecretEngine,
+    _create_vault_auth_from_env,
+    create_vault_multisig_signer_from_env,
+)
 
 logger = logging.getLogger(__name__)
 
@@ -23,6 +32,102 @@ deployer_min_spending = AlgoAmount.from_algo(3)
 registry_min_spending = AlgoAmount.from_algo(4)  # min balance for proposal box storage
 
 
+def _create_vault_signer_from_env() -> (
+    tuple[Optional[HashicorpVaultMultisigTransactionSigner], str, Optional[object]]
+):
+    """Helper function to create vault multisig signer from environment variables.
+
+    Creates a 1-of-2 multisig where:
+    - One key comes from HashiCorp Vault (retrieved by VAULT_KEY_NAME)
+    - Other key is an Algorand address from environment (MULTISIG_ALGORAND_ADDRESS),
+      defaulting to DEPLOYER address if not set
+
+    The function connects to Vault, retrieves the public key for the specified key name,
+    converts it to an Algorand address, and creates a proper multisig with both addresses.
+
+    Environment variables needed:
+    - VAULT_URL: HashiCorp Vault URL
+    - VAULT_KEY_NAME: Name of the key in Vault's transit engine
+    - MULTISIG_ALGORAND_ADDRESS: Algorand address for the other multisig key
+    - VAULT_TRANSIT_MOUNT_PATH: Transit engine mount path (optional, defaults to "transit")
+    - Plus all standard Vault authentication variables (VAULT_TOKEN, VAULT_ROLE_ID, etc.)
+
+    Returns tuple of (vault_signer, deployer_address, deployer_account) where:
+    - vault_signer is the HashiCorp Vault multisig signer or None if not available
+    - deployer_address is the multisig address to use for deployment
+    - deployer_account is the AlgoKit account object or None if using vault
+    """
+    algorand_client = AlgorandClient.from_environment()
+    github_deployer = algorand_client.account.from_environment("DEPLOYER")
+
+    try:
+        # Get the Algorand address for the multisig
+        algorand_address = os.environ.get(
+            "MULTISIG_ALGORAND_ADDRESS", github_deployer.address
+        )
+        if not algorand_address:
+            raise ValueError(
+                "MULTISIG_ALGORAND_ADDRESS environment variable is required for vault multisig"
+            )
+
+        # Get the vault key name
+        vault_key_name = os.environ.get("VAULT_KEY_NAME")
+        if not vault_key_name:
+            raise ValueError("VAULT_KEY_NAME environment variable is required")
+
+        # Get Vault connection details
+        vault_url = os.environ.get("VAULT_URL")
+        transit_mount_path = os.environ.get("VAULT_TRANSIT_MOUNT_PATH", "transit")
+
+        if not vault_url:
+            raise ValueError("VAULT_URL environment variable is required")
+
+        # Create Vault authentication and transit engine to get the public key
+        vault_auth = _create_vault_auth_from_env()
+
+        transit_engine = TransitSecretEngine(
+            vault_url=vault_url, vault_auth=vault_auth, mount_path=transit_mount_path
+        )
+
+        # Get the public key bytes from Vault for the specified key
+        vault_public_key_bytes = transit_engine.setup_and_derive_public_key(
+            vault_key_name
+        )
+
+        # Convert to Algorand address
+        vault_address: str = encoding.encode_address(vault_public_key_bytes)  # type: ignore
+        logger.info(
+            f"Retrieved Vault public key for key '{vault_key_name}': {vault_address}"
+        )
+
+        # Set VAULT_KEY_NAMES for the multisig function (it expects comma-separated names)
+        # For a 1-of-2 multisig, we only need one vault key
+        os.environ["VAULT_KEY_NAMES"] = vault_key_name
+
+        # Create 1-of-2 multisig with both addresses (Vault key and provided Algorand address)
+        # Sort addresses to ensure consistent multisig address generation
+        addresses: list[str] = sorted([vault_address, algorand_address])
+        multisig = Multisig(  # type: ignore
+            version=1,
+            threshold=1,
+            addresses=addresses,
+        )
+
+        vault_signer = create_vault_multisig_signer_from_env(multisig)
+        deployer_address = vault_signer.address
+        logger.info(
+            f"Using Vault multisig transaction signer with address: {deployer_address}"
+        )
+        return vault_signer, deployer_address, None
+
+    except (ValueError, KeyError) as e:
+        logger.info(
+            f"Vault signer not available ({e}), falling back to environment-based deployer"
+        )
+        deployer = algorand_client.account.from_environment("DEPLOYER")
+        return None, deployer.address, deployer
+
+
 def _deploy_xgov_registry() -> None:
     from smart_contracts.artifacts.xgov_registry.x_gov_registry_client import (
         ConfigXgovRegistryArgs,
@@ -41,9 +146,12 @@ def _deploy_xgov_registry() -> None:
     )
 
     algorand_client = AlgorandClient.from_environment()
-    deployer = algorand_client.account.from_environment("DEPLOYER")
+
+    # Try to create Vault signer first, fallback to environment if not available
+    vault_signer, deployer_address, deployer = _create_vault_signer_from_env()
+
     algorand_client.account.ensure_funded_from_environment(
-        account_to_fund=deployer.address, min_spending_balance=deployer_min_spending
+        account_to_fund=deployer_address, min_spending_balance=deployer_min_spending
     )
 
     template_values = {"entropy": b""}
@@ -59,7 +167,8 @@ def _deploy_xgov_registry() -> None:
 
     factory = algorand_client.client.get_typed_app_factory(
         typed_factory=XGovRegistryFactory,
-        default_sender=deployer.address,
+        default_sender=deployer_address,
+        default_signer=vault_signer if vault_signer else (deployer.signer if deployer else None),  # type: ignore
         compilation_params=AppClientCompilationParams(
             deploy_time_params=template_values
         ),
@@ -112,8 +221,8 @@ def _deploy_xgov_registry() -> None:
             size=len(compiled_proposal.approval_program),
         ),
         params=CommonAppCallParams(
-            sender=deployer.address,
-            signer=deployer.signer,
+            sender=deployer_address,
+            signer=vault_signer if vault_signer else (deployer.signer if deployer else None),  # type: ignore
         ),
     )
 
@@ -125,6 +234,10 @@ def _deploy_xgov_registry() -> None:
         ]
         app_client.send.load_proposal_contract(
             args=(i * data_size_per_transaction, chunk),
+            params=CommonAppCallParams(
+                sender=deployer_address,
+                signer=vault_signer if vault_signer else (deployer.signer if deployer else None),  # type: ignore
+            ),
         )
 
     should_set_roles = os.environ.get("XGOV_REG_SET_ROLES", "false").lower() == "true"
@@ -136,17 +249,47 @@ def _deploy_xgov_registry() -> None:
         admin_roles.set_committee_manager(
             args=SetCommitteeManagerArgs(
                 manager=test_admin,
-            )
+            ),
+            params=CommonAppCallParams(
+                sender=deployer_address,
+                signer=vault_signer if vault_signer else (deployer.signer if deployer else None),  # type: ignore
+            ),
         )
         admin_roles.set_xgov_daemon(
-            args=SetXgovDaemonArgs(xgov_daemon=test_xgov_daemon)
+            args=SetXgovDaemonArgs(xgov_daemon=test_xgov_daemon),
+            params=CommonAppCallParams(
+                sender=deployer_address,
+                signer=vault_signer if vault_signer else (deployer.signer if deployer else None),  # type: ignore
+            ),
+        )
+        admin_roles.set_xgov_council(
+            args=SetXgovCouncilArgs(council=test_admin),
+            params=CommonAppCallParams(
+                sender=deployer_address,
+                signer=vault_signer if vault_signer else (deployer.signer if deployer else None),  # type: ignore
+            ),
         )
-        admin_roles.set_xgov_council(args=SetXgovCouncilArgs(council=test_admin))
         admin_roles.set_xgov_subscriber(
-            args=SetXgovSubscriberArgs(subscriber=test_admin)
+            args=SetXgovSubscriberArgs(subscriber=test_admin),
+            params=CommonAppCallParams(
+                sender=deployer_address,
+                signer=vault_signer if vault_signer else (deployer.signer if deployer else None),  # type: ignore
+            ),
+        )
+        admin_roles.set_payor(
+            args=SetPayorArgs(payor=test_admin),
+            params=CommonAppCallParams(
+                sender=deployer_address,
+                signer=vault_signer if vault_signer else (deployer.signer if deployer else None),  # type: ignore
+            ),
+        )
+        admin_roles.set_kyc_provider(
+            args=SetKycProviderArgs(provider=test_admin),
+            params=CommonAppCallParams(
+                sender=deployer_address,
+                signer=vault_signer if vault_signer else (deployer.signer if deployer else None),  # type: ignore
+            ),
         )
-        admin_roles.set_payor(args=SetPayorArgs(payor=test_admin))
-        admin_roles.set_kyc_provider(args=SetKycProviderArgs(provider=test_admin))
         admin_roles.send()
 
     else:
@@ -202,7 +345,11 @@ def _deploy_xgov_registry() -> None:
         app_client.send.config_xgov_registry(
             args=ConfigXgovRegistryArgs(
                 config=config,
-            )
+            ),
+            params=CommonAppCallParams(
+                sender=deployer_address,
+                signer=vault_signer if vault_signer else (deployer.signer if deployer else None),  # type: ignore
+            ),
         )
     else:
         logger.info("Skipping xGov registry configuration as requested")
@@ -222,41 +369,83 @@ def _set_roles() -> None:
     )
 
     algorand_client = AlgorandClient.from_environment()
-    deployer = algorand_client.account.from_environment("DEPLOYER")
+
+    # Try to create Vault signer first, fallback to environment if not available
+    vault_signer, deployer_address, deployer = _create_vault_signer_from_env()
+
     algorand_client.account.ensure_funded_from_environment(
-        account_to_fund=deployer.address, min_spending_balance=deployer_min_spending
+        account_to_fund=deployer_address, min_spending_balance=deployer_min_spending
     )
 
     factory = algorand_client.client.get_typed_app_factory(
         typed_factory=XGovRegistryFactory,
-        default_sender=deployer.address,
+        default_sender=deployer_address,
+        default_signer=vault_signer if vault_signer else (deployer.signer if deployer else None),  # type: ignore
     )
 
     app_client = factory.get_app_client_by_creator_and_name(
-        creator_address=deployer.address,
+        creator_address=deployer_address,
         app_name=APP_SPEC.name,
     )
 
     roles_group = app_client.new_group()
 
     if xgov_manager := os.environ.get("XGOV_REG_SET_ROLES_XGOV_MANAGER"):
-        roles_group.set_xgov_manager(args=SetXgovManagerArgs(manager=xgov_manager))
+        roles_group.set_xgov_manager(
+            args=SetXgovManagerArgs(manager=xgov_manager),
+            params=CommonAppCallParams(
+                sender=deployer_address,
+                signer=vault_signer if vault_signer else (deployer.signer if deployer else None),  # type: ignore
+            ),
+        )
     if payor := os.environ.get("XGOV_REG_SET_ROLES_PAYOR"):
-        roles_group.set_payor(args=SetPayorArgs(payor=payor))
+        roles_group.set_payor(
+            args=SetPayorArgs(payor=payor),
+            params=CommonAppCallParams(
+                sender=deployer_address,
+                signer=vault_signer if vault_signer else (deployer.signer if deployer else None),  # type: ignore
+            ),
+        )
     if xgov_council := os.environ.get("XGOV_REG_SET_ROLES_XGOV_COUNCIL"):
-        roles_group.set_xgov_council(args=SetXgovCouncilArgs(council=xgov_council))
+        roles_group.set_xgov_council(
+            args=SetXgovCouncilArgs(council=xgov_council),
+            params=CommonAppCallParams(
+                sender=deployer_address,
+                signer=vault_signer if vault_signer else (deployer.signer if deployer else None),  # type: ignore
+            ),
+        )
     if xgov_subscriber := os.environ.get("XGOV_REG_SET_ROLES_XGOV_SUBSCRIBER"):
         roles_group.set_xgov_subscriber(
-            args=SetXgovSubscriberArgs(subscriber=xgov_subscriber)
+            args=SetXgovSubscriberArgs(subscriber=xgov_subscriber),
+            params=CommonAppCallParams(
+                sender=deployer_address,
+                signer=vault_signer if vault_signer else (deployer.signer if deployer else None),  # type: ignore
+            ),
         )
     if kyc_provider := os.environ.get("XGOV_REG_SET_ROLES_KYC_PROVIDER"):
-        roles_group.set_kyc_provider(args=SetKycProviderArgs(provider=kyc_provider))
+        roles_group.set_kyc_provider(
+            args=SetKycProviderArgs(provider=kyc_provider),
+            params=CommonAppCallParams(
+                sender=deployer_address,
+                signer=vault_signer if vault_signer else (deployer.signer if deployer else None),  # type: ignore
+            ),
+        )
     if committee_manager := os.environ.get("XGOV_REG_SET_ROLES_COMMITTEE_MANAGER"):
         roles_group.set_committee_manager(
-            args=SetCommitteeManagerArgs(manager=committee_manager)
+            args=SetCommitteeManagerArgs(manager=committee_manager),
+            params=CommonAppCallParams(
+                sender=deployer_address,
+                signer=vault_signer if vault_signer else (deployer.signer if deployer else None),  # type: ignore
+            ),
         )
     if xgov_daemon := os.environ.get("XGOV_REG_SET_ROLES_XGOV_DAEMON"):
-        roles_group.set_xgov_daemon(args=SetXgovDaemonArgs(xgov_daemon=xgov_daemon))
+        roles_group.set_xgov_daemon(
+            args=SetXgovDaemonArgs(xgov_daemon=xgov_daemon),
+            params=CommonAppCallParams(
+                sender=deployer_address,
+                signer=vault_signer if vault_signer else (deployer.signer if deployer else None),  # type: ignore
+            ),
+        )
 
     try:
         roles_group.send()
@@ -275,18 +464,22 @@ def _configure_xgov_registry() -> None:
     )
 
     algorand_client = AlgorandClient.from_environment()
-    deployer = algorand_client.account.from_environment("DEPLOYER")
+
+    # Try to create Vault signer first, fallback to environment if not available
+    vault_signer, deployer_address, deployer = _create_vault_signer_from_env()
+
     algorand_client.account.ensure_funded_from_environment(
-        account_to_fund=deployer.address, min_spending_balance=deployer_min_spending
+        account_to_fund=deployer_address, min_spending_balance=deployer_min_spending
     )
 
     factory = algorand_client.client.get_typed_app_factory(
         typed_factory=XGovRegistryFactory,
-        default_sender=deployer.address,
+        default_sender=deployer_address,
+        default_signer=vault_signer if vault_signer else (deployer.signer if deployer else None),  # type: ignore
     )
 
     app_client = factory.get_app_client_by_creator_and_name(
-        creator_address=deployer.address,
+        creator_address=deployer_address,
         app_name=APP_SPEC.name,
     )
 
@@ -404,7 +597,11 @@ def _configure_xgov_registry() -> None:
         app_client.send.config_xgov_registry(
             args=ConfigXgovRegistryArgs(
                 config=config,
-            )
+            ),
+            params=CommonAppCallParams(
+                sender=deployer_address,
+                signer=vault_signer if vault_signer else (deployer.signer if deployer else None),  # type: ignore
+            ),
         )
         logger.info("xGov registry configured successfully")
     except Exception as e:
@@ -414,6 +611,7 @@ def _configure_xgov_registry() -> None:
 
 def deploy() -> None:
     command = os.environ.get("XGOV_REG_DEPLOY_COMMAND")
+    logger.info(f"XGOV_REG_DEPLOY_COMMAND: {command}")
     if command == "deploy":
         _deploy_xgov_registry()
     elif command == "set_roles":
diff --git a/smart_contracts/xgov_registry/vault_tx_signer.py b/smart_contracts/xgov_registry/vault_tx_signer.py
new file mode 100644
index 0000000..6171459
--- /dev/null
+++ b/smart_contracts/xgov_registry/vault_tx_signer.py
@@ -0,0 +1,995 @@
+import base64
+import os
+from abc import ABC, abstractmethod
+
+import hvac
+from algosdk import constants, encoding
+from algosdk.atomic_transaction_composer import (
+    TransactionSigner,
+)
+from algosdk.transaction import (
+    GenericSignedTransaction,
+    LogicSigTransaction,
+    Multisig,
+    MultisigTransaction,
+    SignedTransaction,
+    Transaction,
+)
+
+## TODO:
+# Add more auth methods as needed (AWS, GCP, etc.)
+
+
+class VaultAuth(ABC):
+    """Abstract base class for Vault authentication methods"""
+
+    @abstractmethod
+    def authenticate(self, vault_client: hvac.Client) -> None:
+        """Authenticate the vault client"""
+        pass
+
+
+class TokenAuth(VaultAuth):
+    """Token-based authentication"""
+
+    def __init__(self, token: str):
+        self.token = token
+
+    def authenticate(self, vault_client: hvac.Client) -> None:
+        vault_client.token = self.token
+        if not vault_client.is_authenticated():
+            raise ValueError("Failed to authenticate with HashiCorp Vault using token")
+
+
+class AppRoleAuth(VaultAuth):
+    """AppRole-based authentication"""
+
+    def __init__(self, role_id: str, secret_id: str, mount_point: str = "approle"):
+        self.role_id = role_id
+        self.secret_id = secret_id
+        self.mount_point = mount_point
+
+    def authenticate(self, vault_client: hvac.Client) -> None:
+        try:
+            auth_response = vault_client.auth.approle.login(  # type: ignore
+                role_id=self.role_id,
+                secret_id=self.secret_id,
+                mount_point=self.mount_point,
+            )
+            vault_client.token = auth_response["auth"]["client_token"]  # type: ignore
+
+            if not vault_client.is_authenticated():
+                raise ValueError(
+                    "Failed to authenticate with HashiCorp Vault using AppRole"
+                )
+        except Exception as e:
+            raise ValueError(f"AppRole authentication failed: {e!s}") from e
+
+
+class OIDCAuth(VaultAuth):
+    """OIDC-based authentication"""
+
+    def __init__(self, role: str, mount_point: str = "oidc"):
+        self.role = role
+        self.mount_point = mount_point
+
+    def authenticate(self, vault_client: hvac.Client) -> None:
+        try:
+            # Get the OIDC auth URL
+            auth_url_response = vault_client.auth.oidc.oidc_authorization_url_request(  # type: ignore
+                role=self.role, mount_point=self.mount_point
+            )
+            auth_url = auth_url_response["data"]["auth_url"]  # type: ignore
+
+            print("Please open the following URL in your browser to authenticate:")
+            print(f"{auth_url}")  # type: ignore
+            print("\nAfter authentication, you will be redirected to a callback URL.")
+            print(
+                "Please copy the 'code' parameter from the callback URL and paste it below:"
+            )
+
+            # Get the authorization code from user input
+            auth_code = input("Authorization code: ").strip()
+
+            if not auth_code:
+                raise ValueError(
+                    "Authorization code is required for OIDC authentication"
+                )
+
+            # Exchange the authorization code for a Vault token
+            callback_response = vault_client.auth.oidc.oidc_callback(  # type: ignore
+                code=auth_code, mount_point=self.mount_point
+            )
+
+            vault_client.token = callback_response["auth"]["client_token"]  # type: ignore
+
+            if not vault_client.is_authenticated():
+                raise ValueError(
+                    "Failed to authenticate with HashiCorp Vault using OIDC"
+                )
+
+        except Exception as exc:
+            raise ValueError(f"OIDC authentication failed: {exc}") from exc
+
+
+class OIDCCallbackAuth(VaultAuth):
+    """OIDC-based authentication using pre-obtained callback data"""
+
+    def __init__(self, role: str, auth_code: str, mount_point: str = "oidc"):
+        self.role = role
+        self.auth_code = auth_code
+        self.mount_point = mount_point
+
+    def authenticate(self, vault_client: hvac.Client) -> None:
+        try:
+            # Exchange the authorization code for a Vault token
+            callback_response = vault_client.auth.oidc.oidc_callback(  # type: ignore
+                code=self.auth_code, mount_point=self.mount_point
+            )
+
+            vault_client.token = callback_response["auth"]["client_token"]  # type: ignore
+
+            if not vault_client.is_authenticated():
+                raise ValueError(
+                    "Failed to authenticate with HashiCorp Vault using OIDC"
+                )
+
+        except Exception as exc:
+            raise ValueError(f"OIDC callback authentication failed: {exc}") from exc
+
+
+class OIDCJWTAuth(VaultAuth):
+    """OIDC JWT-based authentication (for service accounts)"""
+
+    def __init__(self, role: str, jwt: str, mount_point: str = "oidc"):
+        self.role = role
+        self.jwt = jwt
+        self.mount_point = mount_point
+
+    def authenticate(self, vault_client: hvac.Client) -> None:
+        try:
+            # Authenticate using JWT
+            auth_response = vault_client.auth.oidc.login(  # type: ignore
+                role=self.role, jwt=self.jwt, mount_point=self.mount_point
+            )
+
+            vault_client.token = auth_response["auth"]["client_token"]  # type: ignore
+
+            if not vault_client.is_authenticated():
+                raise ValueError(
+                    "Failed to authenticate with HashiCorp Vault using OIDC JWT"
+                )
+
+        except Exception as exc:
+            raise ValueError(f"OIDC JWT authentication failed: {exc}") from exc
+
+
+class GitHubActionsAuth(VaultAuth):
+    """GitHub Actions OIDC authentication - automatically gets the OIDC token"""
+
+    def __init__(self, role: str, mount_point: str = "oidc", audience: str = "vault"):
+        self.role = role
+        self.mount_point = mount_point
+        self.audience = audience
+
+    def authenticate(self, vault_client: hvac.Client) -> None:
+        try:
+            import json
+            import urllib.parse
+            import urllib.request
+
+            # Get the OIDC token from GitHub Actions
+            req_token = os.environ.get("ACTIONS_ID_TOKEN_REQUEST_TOKEN")
+            req_url = os.environ.get("ACTIONS_ID_TOKEN_REQUEST_URL")
+
+            if not req_token or not req_url:
+                raise ValueError(
+                    "GitHub Actions OIDC token request environment variables not found. "
+                    "Make sure 'id-token: write' permission is set in your workflow."
+                )
+
+            # Request the OIDC token from GitHub
+            token_url = f"{req_url}&audience={urllib.parse.quote(self.audience)}"
+            request = urllib.request.Request(token_url)
+            request.add_header("Authorization", f"bearer {req_token}")
+            request.add_header("Accept", "application/json; api-version=2.0")
+            request.add_header("Content-Type", "application/json")
+
+            response = urllib.request.urlopen(request)
+            response_data = json.loads(response.read().decode())  # type: ignore
+            jwt_token = response_data.get("value")  # type: ignore
+
+            if not jwt_token:  # type: ignore
+                raise ValueError("Failed to obtain OIDC token from GitHub Actions")
+
+            # Authenticate with Vault using the JWT token
+            auth_response = vault_client.auth.jwt.jwt_login(  # type: ignore
+                role=self.role, jwt=jwt_token, path=self.mount_point  # type: ignore
+            )
+
+            vault_client.token = auth_response["auth"]["client_token"]  # type: ignore
+
+            if not vault_client.is_authenticated():
+                raise ValueError(
+                    "Failed to authenticate with HashiCorp Vault using GitHub Actions OIDC"
+                )
+
+        except Exception as exc:
+            raise ValueError(
+                f"GitHub Actions OIDC authentication failed: {exc}"
+            ) from exc
+
+
+class VaultSecretEngine(ABC):
+    """Abstract base class for Vault secret engines"""
+
+    @abstractmethod
+    def setup_and_derive_public_key(self, key_name: str) -> bytes:
+        """Setup the secret engine and derive the public key bytes"""
+        pass
+
+    @abstractmethod
+    def sign_data(self, data_b64: str, key_name: str) -> str:
+        """Sign data and return the signature"""
+        pass
+
+
+class TransitSecretEngine(VaultSecretEngine):
+    """Transit secret engine implementation"""
+
+    def __init__(
+        self, vault_url: str, vault_auth: VaultAuth, mount_path: str = "transit"
+    ):
+        self.vault_url = vault_url
+        self.vault_auth = vault_auth
+        self.mount_path = mount_path
+
+        # Initialize the Vault client with namespace if provided
+        vault_namespace = os.environ.get("VAULT_NAMESPACE")
+        if vault_namespace:
+            self.vault_client = hvac.Client(
+                url=self.vault_url, namespace=vault_namespace
+            )
+        else:
+            self.vault_client = hvac.Client(url=self.vault_url)
+
+        # Authenticate using the provided auth method
+        self.vault_auth.authenticate(self.vault_client)
+
+    def setup_and_derive_public_key(self, key_name: str) -> bytes:
+        """Setup transit engine and derive the public key bytes from the Vault key"""
+        try:
+            # Get the public key from Vault (this also verifies the key exists)
+            try:
+                key_info = self.vault_client.secrets.transit.read_key(  # type: ignore
+                    name=key_name, mount_point=self.mount_path
+                )
+            except Exception as e:
+                raise ValueError(f"Key '{key_name}' not found in transit engine") from e
+            # Extract public key bytes
+            public_key_b64 = key_info["data"]["keys"]["1"]["public_key"]  # type: ignore
+            public_key_bytes = base64.b64decode(public_key_b64)  # type: ignore
+
+            return public_key_bytes
+
+        except Exception as exc:
+            raise ValueError(
+                f"Failed to setup Vault transit engine or derive public key: {exc}"
+            ) from exc
+
+    def sign_data(self, data_b64: str, key_name: str) -> str:
+        """Sign data using Vault transit engine"""
+        try:
+            # Sign with Vault transit engine
+            # For Ed25519 keys, we use the data directly without pre-hashing
+            sign_response = self.vault_client.secrets.transit.sign_data(  # type: ignore
+                name=key_name,
+                hash_input=data_b64,
+                prehashed=False,  # Ed25519 handles hashing internally
+                mount_point=self.mount_path,
+            )
+
+            # Extract signature from Vault response
+            vault_signature = sign_response["data"]["signature"]  # type: ignore
+            # Vault returns signature in format "vault:v1:base64signature"
+            signature_b64 = vault_signature.split(":")[-1]  # type: ignore
+
+            # Add padding if needed for proper base64 decoding
+            missing_padding = len(signature_b64) % 4  # type: ignore
+            if missing_padding:
+                signature_b64 += "=" * (4 - missing_padding)  # type: ignore
+
+            # Verify the signature is valid base64 and correct length
+            try:
+                signature_bytes = base64.b64decode(signature_b64)  # type: ignore
+                if len(signature_bytes) != 64:  # Ed25519 signatures are 64 bytes
+                    raise ValueError(
+                        f"Invalid signature length: {len(signature_bytes)}"
+                    )
+            except Exception as e:
+                raise ValueError(f"Invalid signature from Vault: {e}") from e
+
+            return signature_b64  # type: ignore
+
+        except Exception as exc:
+            raise ValueError(f"Failed to sign data with transit engine: {exc}") from exc
+
+
+class HashicorpVaultTransactionSigner(TransactionSigner):
+    def __init__(self, secret_engine: VaultSecretEngine, key_name: str):
+        """
+        Initialize HashiCorp Vault Transaction Signer
+
+        Args:
+            secret_engine: The secret engine implementation to use (already configured with Vault connection)
+            key_name: Name of the key to use for signing
+        """
+        self.secret_engine = secret_engine
+        self.key_name = key_name
+
+        # Setup secret engine and derive public key from Vault
+        self._public_key_bytes = self.secret_engine.setup_and_derive_public_key(
+            self.key_name
+        )
+
+        # Derive address from public key
+        self._address = encoding.encode_address(self._public_key_bytes)  # type: ignore
+
+    def sign_transactions(
+        self, txn_group: list[Transaction], indexes: list[int]
+    ) -> list[SignedTransaction | LogicSigTransaction | MultisigTransaction]:
+        """
+        Sign transactions using the configured secret engine
+
+        Args:
+            txn_group: list of transactions to sign
+            indexes: Indexes of transactions in the group that this signer should sign
+
+        Returns:
+            list of signed transaction bytes
+        """
+        try:
+            signed_txns: list[SignedTransaction] = []
+
+            for i in indexes:
+                if i >= len(txn_group):
+                    raise ValueError(f"Transaction index {i} out of range")
+
+                # Get the transaction to sign
+                txn = txn_group[i]
+
+                # Ensure we have a Transaction object
+                if not hasattr(txn, "dictify"):
+                    raise ValueError(
+                        f"Expected Transaction object, got {type(txn)}. Value: {txn}"
+                    )
+
+                encoded_txn = encoding.msgpack_encode(txn)  # type: ignore
+                to_sign = constants.txid_prefix + base64.b64decode(encoded_txn)  # type: ignore
+
+                # Convert to base64 for Vault API
+                to_sign_b64 = base64.b64encode(to_sign).decode("utf-8")
+
+                # Sign using the secret engine
+                signature_b64 = self.secret_engine.sign_data(to_sign_b64, self.key_name)
+
+                # Create signed transaction with the base64 signature
+                signed_txn = SignedTransaction(transaction=txn, signature=signature_b64)
+
+                signed_txns.append(signed_txn)
+
+            return signed_txns  # type: ignore
+
+        except Exception as exc:
+            raise RuntimeError(
+                f"Failed to sign transactions with Vault: {exc}"
+            ) from exc
+
+    @property
+    def address(self) -> str:
+        """Get the Algorand address associated with this signer"""
+        if not self._address:  # type: ignore
+            raise ValueError(
+                "Address not available. Failed to derive from Vault or not provided."
+            )
+        return self._address  # type: ignore
+
+    @property
+    def public_key_bytes(self) -> bytes:
+        """Get the public key bytes associated with this signer"""
+        if not self._public_key_bytes:
+            raise ValueError("Public key not available. Failed to derive from Vault.")
+        return self._public_key_bytes
+
+    def __repr__(self) -> str:
+        return (
+            f"HashicorpVaultTransactionSigner("
+            f"secret_engine={self.secret_engine.__class__.__name__}, "
+            f"key_name='{self.key_name}'"
+            f")"
+        )
+
+
+class HashicorpVaultMultisigTransactionSigner(TransactionSigner):
+    """
+    Represents a Transaction Signer for a Multisig using HashiCorp Vault.
+
+    Args:
+        msig (Multisig): Multisig account
+        vault_url: URL of the HashiCorp Vault instance
+        vault_token: Authentication token for Vault
+        secret_engine: The secret engine implementation to use
+    """
+
+    def __init__(
+        self, msig: Multisig, secret_engine: VaultSecretEngine, key_names: list[str]
+    ) -> None:
+        super().__init__()
+        self.msig = msig
+        self.vault_transaction_signers = [
+            HashicorpVaultTransactionSigner(
+                secret_engine=secret_engine, key_name=key_name
+            )
+            for key_name in key_names
+        ]
+        self._address = msig.address()  # type: ignore
+
+    def sign_transactions(
+        self, txn_group: list[Transaction], indexes: list[int]
+    ) -> list[GenericSignedTransaction]:
+        """
+        Sign transactions in a transaction group given the indexes.
+
+        Returns an array of encoded signed transactions. The length of the
+        array will be the same as the length of indexesToSign, and each index i in the array
+        corresponds to the signed transaction from txnGroup[indexesToSign[i]].
+
+        Args:
+            txn_group (list[Transaction]): atomic group of transactions
+            indexes (list[int]): array of indexes in the atomic transaction group that should be signed
+        """
+        self.msig.validate()  # type: ignore
+
+        pk_to_signed_txs: dict[bytes, list[SignedTransaction]] = {}
+        for signer in self.vault_transaction_signers:
+            signed_txns = signer.sign_transactions(txn_group, indexes)
+            pk = signer.public_key_bytes
+            pk_to_signed_txs[pk] = signed_txns  # type: ignore
+
+        stxns: list[GenericSignedTransaction] = []
+        for i in indexes:
+            mtxn = MultisigTransaction(txn_group[i], self.msig)
+            for subsig in mtxn.multisig.subsigs:
+                pk = subsig.public_key
+                if pk in pk_to_signed_txs:  # type: ignore
+                    stxns_part = pk_to_signed_txs[pk]  # type: ignore
+                    subsig.signature = base64.b64decode(stxns_part[i].signature)  # type: ignore
+            stxns.append(mtxn)
+        return stxns
+
+    @property
+    def address(self) -> str:
+        """Get the Algorand address associated with this signer"""
+        if not self._address:  # type: ignore
+            raise ValueError(
+                "Address not available. Failed to derive from Vault or not provided."
+            )
+        return self._address  # type: ignore
+
+
+# Helper function to create VaultAuth from environment variables
+def _create_vault_auth_from_env() -> VaultAuth:
+    """
+    Create a VaultAuth instance based on available environment variables.
+
+    Returns:
+        VaultAuth: Configured authentication method
+
+    Raises:
+        ValueError: If no valid authentication method is found
+    """
+    # Check authentication methods in order of preference
+
+    # 1. Check for GitHub Actions OIDC (automatic detection)
+    if (
+        os.environ.get("GITHUB_ACTIONS") == "true"
+        and os.environ.get("ACTIONS_ID_TOKEN_REQUEST_TOKEN")
+        and os.environ.get("VAULT_OIDC_ROLE")
+    ):
+        oidc_role = os.environ.get("VAULT_OIDC_ROLE", "")
+        oidc_mount_path = os.environ.get("VAULT_OIDC_MOUNT_PATH", "oidc")
+        github_audience = os.environ.get("VAULT_GITHUB_AUDIENCE", "vault")
+        return GitHubActionsAuth(
+            role=oidc_role, mount_point=oidc_mount_path, audience=github_audience
+        )
+
+    # 2. Check for OIDC JWT authentication (service account)
+    elif os.environ.get("VAULT_OIDC_ROLE") and os.environ.get("VAULT_OIDC_JWT"):
+        oidc_role = os.environ.get("VAULT_OIDC_ROLE", "")
+        oidc_jwt = os.environ.get("VAULT_OIDC_JWT", "")
+        oidc_mount_path = os.environ.get("VAULT_OIDC_MOUNT_PATH", "oidc")
+        return OIDCJWTAuth(role=oidc_role, jwt=oidc_jwt, mount_point=oidc_mount_path)
+
+    # 3. Check for OIDC with auth code
+    elif os.environ.get("VAULT_OIDC_ROLE") and os.environ.get("VAULT_OIDC_AUTH_CODE"):
+        oidc_role = os.environ.get("VAULT_OIDC_ROLE", "")
+        oidc_auth_code = os.environ.get("VAULT_OIDC_AUTH_CODE", "")
+        oidc_mount_path = os.environ.get("VAULT_OIDC_MOUNT_PATH", "oidc")
+        return OIDCCallbackAuth(
+            role=oidc_role, auth_code=oidc_auth_code, mount_point=oidc_mount_path
+        )
+
+    # 4. Check for interactive OIDC
+    elif os.environ.get("VAULT_OIDC_ROLE"):
+        oidc_role = os.environ.get("VAULT_OIDC_ROLE", "")
+        oidc_mount_path = os.environ.get("VAULT_OIDC_MOUNT_PATH", "oidc")
+        return OIDCAuth(role=oidc_role, mount_point=oidc_mount_path)
+
+    # 5. Check for AppRole authentication
+    elif os.environ.get("VAULT_ROLE_ID") and os.environ.get("VAULT_SECRET_ID"):
+        role_id = os.environ.get("VAULT_ROLE_ID", "")
+        secret_id = os.environ.get("VAULT_SECRET_ID", "")
+        approle_mount_path = os.environ.get("VAULT_APPROLE_MOUNT_PATH", "approle")
+        return AppRoleAuth(
+            role_id=role_id, secret_id=secret_id, mount_point=approle_mount_path
+        )
+
+    # 6. Fall back to token authentication
+    elif os.environ.get("VAULT_TOKEN"):
+        vault_token = os.environ.get("VAULT_TOKEN", "")
+        return TokenAuth(token=vault_token)
+
+    else:
+        raise ValueError(
+            "Authentication required. Please set one of:\n"
+            "- VAULT_TOKEN (for token auth)\n"
+            "- VAULT_ROLE_ID + VAULT_SECRET_ID (for AppRole auth)\n"
+            "- VAULT_OIDC_ROLE (for OIDC auth)\n"
+            "- VAULT_OIDC_ROLE + VAULT_OIDC_JWT (for OIDC JWT auth)\n"
+            "- VAULT_OIDC_ROLE + VAULT_OIDC_AUTH_CODE (for OIDC callback auth)"
+        )
+
+
+# Factory function to create multisig signer from environment variables (backwards compatible)
+def create_vault_multisig_signer_from_env(
+    msig: Multisig,
+) -> HashicorpVaultMultisigTransactionSigner:
+    """
+    Create a HashiCorp Vault multisig signer using environment variables with Transit engine
+    Supports Token, AppRole, and OIDC authentication methods.
+    Expected environment variables:
+    - VAULT_URL: HashiCorp Vault URL
+    - VAULT_TRANSIT_MOUNT_PATH: Transit engine mount path (optional, defaults to "transit")
+    - VAULT_KEY_NAMES: Comma-separated names of the keys in transit engine for each multisig signer
+
+    For Token authentication:
+    - VAULT_TOKEN: Authentication token
+
+    For AppRole authentication:
+    - VAULT_ROLE_ID: AppRole role ID
+    - VAULT_SECRET_ID: AppRole secret ID
+    - VAULT_APPROLE_MOUNT_PATH: AppRole mount path (optional, defaults to "approle")
+
+    For OIDC authentication:
+    - VAULT_OIDC_ROLE: OIDC role name
+    - VAULT_OIDC_MOUNT_PATH: OIDC mount path (optional, defaults to "oidc")
+
+    For OIDC with auth code:
+    - VAULT_OIDC_ROLE: OIDC role name
+    - VAULT_OIDC_AUTH_CODE: Pre-obtained authorization code
+    - VAULT_OIDC_MOUNT_PATH: OIDC mount path (optional, defaults to "oidc")
+
+    For OIDC JWT (service account):
+    - VAULT_OIDC_ROLE: OIDC role name
+    - VAULT_OIDC_JWT: JWT token
+    - VAULT_OIDC_MOUNT_PATH: OIDC mount path (optional, defaults to "oidc")
+
+    For GitHub Actions OIDC (automatic):
+    - VAULT_OIDC_ROLE: OIDC role name configured for GitHub Actions
+    - VAULT_OIDC_MOUNT_PATH: OIDC mount path (optional, defaults to "oidc")
+    - VAULT_GITHUB_AUDIENCE: Audience for GitHub OIDC token (optional, defaults to "vault")
+    Note: Requires 'id-token: write' permission in GitHub Actions workflow
+    """
+
+    vault_url = os.environ.get("VAULT_URL")
+    transit_mount_path = os.environ.get("VAULT_TRANSIT_MOUNT_PATH", "transit")
+    key_names_str = os.environ.get("VAULT_KEY_NAMES")
+
+    if not vault_url:
+        raise ValueError("VAULT_URL environment variable is required")
+    if not key_names_str:
+        raise ValueError("VAULT_KEY_NAMES environment variable is required")
+
+    key_names = [
+        key_name.strip() for key_name in key_names_str.split(",") if key_name.strip()
+    ]
+
+    # Get authentication method from environment
+    vault_auth = _create_vault_auth_from_env()
+
+    # Create transit engine with the specified parameters
+    transit_engine = TransitSecretEngine(
+        vault_url=vault_url, vault_auth=vault_auth, mount_path=transit_mount_path
+    )
+
+    return HashicorpVaultMultisigTransactionSigner(
+        msig=msig,
+        secret_engine=transit_engine,
+        key_names=key_names,
+    )
+
+
+# Factory function to create signer from environment variables (backwards compatible)
+def create_vault_signer_from_env() -> HashicorpVaultTransactionSigner:
+    """
+    Create a HashiCorp Vault signer using environment variables with Transit engine
+
+    Supports Token, AppRole, and OIDC authentication methods.
+
+    Expected environment variables:
+    - VAULT_URL: HashiCorp Vault URL
+    - VAULT_TRANSIT_MOUNT_PATH: Transit engine mount path (optional, defaults to "transit")
+    - VAULT_KEY_NAME: Name of the key in transit engine
+
+    For Token authentication:
+    - VAULT_TOKEN: Authentication token
+
+    For AppRole authentication:
+    - VAULT_ROLE_ID: AppRole role ID
+    - VAULT_SECRET_ID: AppRole secret ID
+    - VAULT_APPROLE_MOUNT_PATH: AppRole mount path (optional, defaults to "approle")
+
+    For OIDC authentication:
+    - VAULT_OIDC_ROLE: OIDC role name
+    - VAULT_OIDC_MOUNT_PATH: OIDC mount path (optional, defaults to "oidc")
+
+    For OIDC with auth code:
+    - VAULT_OIDC_ROLE: OIDC role name
+    - VAULT_OIDC_AUTH_CODE: Pre-obtained authorization code
+    - VAULT_OIDC_MOUNT_PATH: OIDC mount path (optional, defaults to "oidc")
+
+    For OIDC JWT (service account):
+    - VAULT_OIDC_ROLE: OIDC role name
+    - VAULT_OIDC_JWT: JWT token
+    - VAULT_OIDC_MOUNT_PATH: OIDC mount path (optional, defaults to "oidc")
+
+    For GitHub Actions OIDC (automatic):
+    - VAULT_OIDC_ROLE: OIDC role name configured for GitHub Actions
+    - VAULT_OIDC_MOUNT_PATH: OIDC mount path (optional, defaults to "oidc")
+    - VAULT_GITHUB_AUDIENCE: Audience for GitHub OIDC token (optional, defaults to "vault")
+    Note: Requires 'id-token: write' permission in GitHub Actions workflow
+    """
+    vault_url = os.environ.get("VAULT_URL")
+    transit_mount_path = os.environ.get("VAULT_TRANSIT_MOUNT_PATH", "transit")
+    key_name = os.environ.get("VAULT_KEY_NAME")
+
+    if not vault_url:
+        raise ValueError("VAULT_URL environment variable is required")
+    if not key_name:
+        raise ValueError("VAULT_KEY_NAME environment variable is required")
+
+    # Get authentication method from environment
+    vault_auth = _create_vault_auth_from_env()
+
+    # Create transit engine with the specified parameters
+    transit_engine = TransitSecretEngine(
+        vault_url=vault_url, vault_auth=vault_auth, mount_path=transit_mount_path
+    )
+
+    return HashicorpVaultTransactionSigner(
+        secret_engine=transit_engine,
+        key_name=key_name,
+    )
+
+
+# Backwards-compatible constructor for transit engine with token auth
+def create_transit_signer(
+    vault_url: str,
+    vault_token: str,
+    transit_mount_path: str = "transit",
+    key_name: str = "algorand-key",
+) -> HashicorpVaultTransactionSigner:
+    """
+    Create a HashiCorp Vault signer with Transit engine using token authentication (backwards compatible)
+
+    Args:
+        vault_url: URL of the HashiCorp Vault instance
+        vault_token: Authentication token for Vault
+        transit_mount_path: Mount path for the transit secrets engine (default: "transit")
+        key_name: Name of the key in Vault's transit engine
+    """
+    vault_auth = TokenAuth(token=vault_token)
+    transit_engine = TransitSecretEngine(
+        vault_url=vault_url, vault_auth=vault_auth, mount_path=transit_mount_path
+    )
+
+    return HashicorpVaultTransactionSigner(
+        secret_engine=transit_engine,
+        key_name=key_name,
+    )
+
+
+# New constructor for transit engine with AppRole auth
+def create_transit_signer_approle(
+    vault_url: str,
+    role_id: str,
+    secret_id: str,
+    transit_mount_path: str = "transit",
+    key_name: str = "algorand-key",
+    approle_mount_path: str = "approle",
+) -> HashicorpVaultTransactionSigner:
+    """
+    Create a HashiCorp Vault signer with Transit engine using AppRole authentication
+
+    Args:
+        vault_url: URL of the HashiCorp Vault instance
+        role_id: AppRole role ID
+        secret_id: AppRole secret ID
+        transit_mount_path: Mount path for the transit secrets engine (default: "transit")
+        key_name: Name of the key in Vault's transit engine
+        approle_mount_path: Mount path for AppRole auth method (default: "approle")
+    """
+    vault_auth = AppRoleAuth(
+        role_id=role_id, secret_id=secret_id, mount_point=approle_mount_path
+    )
+    transit_engine = TransitSecretEngine(
+        vault_url=vault_url, vault_auth=vault_auth, mount_path=transit_mount_path
+    )
+
+    return HashicorpVaultTransactionSigner(
+        secret_engine=transit_engine,
+        key_name=key_name,
+    )
+
+
+# New constructor for transit engine with OIDC auth (interactive)
+def create_transit_signer_oidc(
+    vault_url: str,
+    role: str,
+    transit_mount_path: str = "transit",
+    key_name: str = "algorand-key",
+    oidc_mount_path: str = "oidc",
+) -> HashicorpVaultTransactionSigner:
+    """
+    Create a HashiCorp Vault signer with Transit engine using OIDC authentication (interactive)
+
+    Args:
+        vault_url: URL of the HashiCorp Vault instance
+        role: OIDC role name
+        transit_mount_path: Mount path for the transit secrets engine (default: "transit")
+        key_name: Name of the key in Vault's transit engine
+        oidc_mount_path: Mount path for OIDC auth method (default: "oidc")
+    """
+    vault_auth = OIDCAuth(role=role, mount_point=oidc_mount_path)
+    transit_engine = TransitSecretEngine(
+        vault_url=vault_url, vault_auth=vault_auth, mount_path=transit_mount_path
+    )
+
+    return HashicorpVaultTransactionSigner(
+        secret_engine=transit_engine,
+        key_name=key_name,
+    )
+
+
+# New constructor for transit engine with OIDC callback auth
+def create_transit_signer_oidc_callback(
+    vault_url: str,
+    role: str,
+    auth_code: str,
+    transit_mount_path: str = "transit",
+    key_name: str = "algorand-key",
+    oidc_mount_path: str = "oidc",
+) -> HashicorpVaultTransactionSigner:
+    """
+    Create a HashiCorp Vault signer with Transit engine using OIDC callback authentication
+
+    Args:
+        vault_url: URL of the HashiCorp Vault instance
+        role: OIDC role name
+        auth_code: Authorization code from OIDC callback
+        transit_mount_path: Mount path for the transit secrets engine (default: "transit")
+        key_name: Name of the key in Vault's transit engine
+        oidc_mount_path: Mount path for OIDC auth method (default: "oidc")
+    """
+    vault_auth = OIDCCallbackAuth(
+        role=role, auth_code=auth_code, mount_point=oidc_mount_path
+    )
+    transit_engine = TransitSecretEngine(
+        vault_url=vault_url, vault_auth=vault_auth, mount_path=transit_mount_path
+    )
+
+    return HashicorpVaultTransactionSigner(
+        secret_engine=transit_engine,
+        key_name=key_name,
+    )
+
+
+# New constructor for transit engine with OIDC JWT auth (service account)
+def create_transit_signer_oidc_jwt(
+    vault_url: str,
+    role: str,
+    jwt: str,
+    transit_mount_path: str = "transit",
+    key_name: str = "algorand-key",
+    oidc_mount_path: str = "oidc",
+) -> HashicorpVaultTransactionSigner:
+    """
+    Create a HashiCorp Vault signer with Transit engine using OIDC JWT authentication (service account)
+
+    Args:
+        vault_url: URL of the HashiCorp Vault instance
+        role: OIDC role name
+        jwt: JWT token for service account authentication
+        transit_mount_path: Mount path for the transit secrets engine (default: "transit")
+        key_name: Name of the key in Vault's transit engine
+        oidc_mount_path: Mount path for OIDC auth method (default: "oidc")
+    """
+    vault_auth = OIDCJWTAuth(role=role, jwt=jwt, mount_point=oidc_mount_path)
+    transit_engine = TransitSecretEngine(
+        vault_url=vault_url, vault_auth=vault_auth, mount_path=transit_mount_path
+    )
+
+    return HashicorpVaultTransactionSigner(
+        secret_engine=transit_engine,
+        key_name=key_name,
+    )
+
+
+# New constructor for transit engine with GitHub Actions OIDC auth
+def create_transit_signer_github_actions(
+    vault_url: str,
+    role: str,
+    transit_mount_path: str = "transit",
+    key_name: str = "algorand-key",
+    oidc_mount_path: str = "oidc",
+    audience: str = "vault",
+) -> HashicorpVaultTransactionSigner:
+    """
+    Create a HashiCorp Vault signer with Transit engine using GitHub Actions OIDC authentication
+
+    Args:
+        vault_url: URL of the HashiCorp Vault instance
+        role: OIDC role name configured for GitHub Actions
+        transit_mount_path: Mount path for the transit secrets engine (default: "transit")
+        key_name: Name of the key in Vault's transit engine
+        oidc_mount_path: Mount path for OIDC auth method (default: "oidc")
+        audience: Audience for GitHub OIDC token (default: "vault")
+
+    Note: This function should only be called from within GitHub Actions with 'id-token: write' permission
+    """
+    vault_auth = GitHubActionsAuth(
+        role=role, mount_point=oidc_mount_path, audience=audience
+    )
+    transit_engine = TransitSecretEngine(
+        vault_url=vault_url, vault_auth=vault_auth, mount_path=transit_mount_path
+    )
+
+    return HashicorpVaultTransactionSigner(
+        secret_engine=transit_engine,
+        key_name=key_name,
+    )
+
+
+def create_transit_multisig_signer(
+    vault_url: str,
+    vault_token: str,
+    msig: Multisig,
+    key_names: list[str],
+    transit_mount_path: str = "transit",
+) -> HashicorpVaultMultisigTransactionSigner:
+    """
+    Create a HashiCorp Vault signer with Transit engine for multisig (backwards compatible)
+
+    Args:
+        vault_url: URL of the HashiCorp Vault instance
+        vault_token: Authentication token for Vault
+        transit_mount_path: Mount path for the transit secrets engine (default: "transit")
+        msig: Multisig configuration
+        key_names: list of key names in Vault's transit engine
+    """
+    vault_auth = TokenAuth(token=vault_token)
+    transit_engine = TransitSecretEngine(
+        vault_url=vault_url, vault_auth=vault_auth, mount_path=transit_mount_path
+    )
+
+    return HashicorpVaultMultisigTransactionSigner(
+        secret_engine=transit_engine, key_names=key_names, msig=msig
+    )
+
+
+# Utility function to create a new key in Vault transit engine with token auth
+def create_vault_key(
+    vault_url: str, vault_token: str, key_name: str, transit_mount_path: str = "transit"
+) -> str:
+    """
+    Create a new Ed25519 key in Vault transit engine using token authentication
+
+    Args:
+        vault_url: URL of the HashiCorp Vault instance
+        vault_token: Authentication token for Vault
+        key_name: Name for the new key
+        transit_mount_path: Mount path for transit engine
+
+    Returns:
+        The Algorand address corresponding to the created key
+    """
+    vault_auth = TokenAuth(token=vault_token)
+    return _create_vault_key_with_auth(
+        vault_url, vault_auth, key_name, transit_mount_path
+    )
+
+
+# Utility function to create a new key in Vault transit engine with AppRole auth
+def create_vault_key_approle(
+    vault_url: str,
+    role_id: str,
+    secret_id: str,
+    key_name: str,
+    transit_mount_path: str = "transit",
+    approle_mount_path: str = "approle",
+) -> str:
+    """
+    Create a new Ed25519 key in Vault transit engine using AppRole authentication
+
+    Args:
+        vault_url: URL of the HashiCorp Vault instance
+        role_id: AppRole role ID
+        secret_id: AppRole secret ID
+        key_name: Name for the new key
+        transit_mount_path: Mount path for transit engine
+        approle_mount_path: Mount path for AppRole auth method
+
+    Returns:
+        The Algorand address corresponding to the created key
+    """
+    vault_auth = AppRoleAuth(
+        role_id=role_id, secret_id=secret_id, mount_point=approle_mount_path
+    )
+    return _create_vault_key_with_auth(
+        vault_url, vault_auth, key_name, transit_mount_path
+    )
+
+
+# Internal helper function for key creation
+def _create_vault_key_with_auth(
+    vault_url: str, vault_auth: VaultAuth, key_name: str, transit_mount_path: str
+) -> str:
+    """
+    Internal function to create a new Ed25519 key in Vault transit engine with any auth method
+
+    Args:
+        vault_url: URL of the HashiCorp Vault instance
+        vault_auth: Vault authentication method
+        key_name: Name for the new key
+        transit_mount_path: Mount path for transit engine
+
+    Returns:
+        The Algorand address corresponding to the created key
+    """
+    # Initialize vault client with namespace if provided
+    vault_namespace = os.environ.get("VAULT_NAMESPACE")
+    if vault_namespace:
+        client = hvac.Client(url=vault_url, namespace=vault_namespace)
+    else:
+        client = hvac.Client(url=vault_url)
+
+    vault_auth.authenticate(client)
+
+    # Create the key
+    client.secrets.transit.create_key(  # type: ignore
+        name=key_name, key_type="ed25519", mount_point=transit_mount_path
+    )
+
+    # Get the public key
+    key_info = client.secrets.transit.read_key(  # type: ignore
+        name=key_name, mount_point=transit_mount_path
+    )
+
+    # Extract public key and convert to Algorand address
+    public_key_b64 = key_info["data"]["keys"]["1"]["public_key"]  # type: ignore
+    public_key_bytes = base64.b64decode(public_key_b64)  # type: ignore
+
+    # Convert Ed25519 public key to Algorand address
+    address = encoding.encode_address(public_key_bytes)  # type: ignore
+
+    return address  # type: ignore
